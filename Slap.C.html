<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="Slap.Z.html">
<link rel="Up" href="Slap.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Slap" rel="Chapter" href="Slap.html"><link title="BLAS interface" rel="Section" href="#2_BLASinterface">
<link title="LAPACK interface" rel="Section" href="#2_LAPACKinterface">
<link title="Level 1" rel="Subsection" href="#3_Level1">
<link title="Level 2" rel="Subsection" href="#3_Level2">
<link title="Level 3" rel="Subsection" href="#3_Level3">
<link title="Auxiliary routines" rel="Subsection" href="#3_Auxiliaryroutines">
<link title="Linear equations (computational routines)" rel="Subsection" href="#3_Linearequationscomputationalroutines">
<link title="Linear equations (simple drivers)" rel="Subsection" href="#3_Linearequationssimpledrivers">
<link title="Least squares (simple drivers)" rel="Subsection" href="#3_Leastsquaressimpledrivers">
<title>Slap.C</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Slap.Z.html" title="Slap.Z">Previous</a>
&nbsp;<a class="up" href="Slap.html" title="Slap">Up</a>
&nbsp;</div>
<h1>Module <a href="type_Slap.C.html">Slap.C</a></h1>

<pre><span class="keyword">module</span> C: <code class="code">sig</code> <a href="Slap.C.html">..</a> <code class="code">end</code></pre><div class="info module top">
32-bit complex BLAS and LAPACK functions.<br>
</div>
<hr width="100%">

<pre><span id="TYPEprec"><span class="keyword">type</span> <code class="type"></code>prec</span> = <code class="type">Bigarray.complex32_elt</code> </pre>


<pre><span id="TYPEnum_type"><span class="keyword">type</span> <code class="type"></code>num_type</span> = <code class="type">Complex.t</code> </pre>


<pre><span id="TYPEtrans3"><span class="keyword">type</span> <code class="type">'a</code> trans3</span> = <code class="type">'a <a href="Slap.Common.html#TYPEtrans3">Slap.Common.trans3</a></code> </pre>
<div class="info ">
Transpose parameter (<a href="Slap.Common.html#VALnormal"><code class="code">Slap.Common.normal</code></a>, <a href="Slap.Common.html#VALtrans"><code class="code">Slap.Common.trans</code></a> or
    <a href="Slap.Common.html#VALconjtr"><code class="code">Slap.Common.conjtr</code></a>).<br>
</div>


<pre><span id="TYPEvec"><span class="keyword">type</span> <code class="type">('n, 'cnt_or_dsc)</code> vec</span> = <code class="type">('n, <a href="Slap.C.html#TYPEnum_type">num_type</a>, <a href="Slap.C.html#TYPEprec">prec</a>, 'cnt_or_dsc) <a href="Slap.Vec.html#TYPEt">Slap.Vec.t</a></code> </pre>
<div class="info ">
Vectors.<br>
</div>


<pre><span id="TYPEmat"><span class="keyword">type</span> <code class="type">('m, 'n, 'cnt_or_dsc)</code> mat</span> = <code class="type">('m, 'n, <a href="Slap.C.html#TYPEnum_type">num_type</a>, <a href="Slap.C.html#TYPEprec">prec</a>, 'cnt_or_dsc) <a href="Slap.Mat.html#TYPEt">Slap.Mat.t</a></code> </pre>
<div class="info ">
Matrices.<br>
</div>


<pre><span id="TYPErprec"><span class="keyword">type</span> <code class="type"></code>rprec</span> = <code class="type">Bigarray.float32_elt</code> </pre>


<pre><span id="TYPErvec"><span class="keyword">type</span> <code class="type">('n, 'cnt_or_dsc)</code> rvec</span> = <code class="type">('n, float, <a href="Slap.C.html#TYPErprec">rprec</a>, 'cnt_or_dsc) <a href="Slap.Vec.html#TYPEt">Slap.Vec.t</a></code> </pre>
<div class="info ">
Real vectors. (In <a href="Slap.S.html"><code class="code">Slap.S</code></a> and <a href="Slap.D.html"><code class="code">Slap.D</code></a>, <code class="code">rvec</code> is equal to <code class="code">vec</code>.)<br>
</div>


<pre><span id="VALprec"><span class="keyword">val</span> prec</span> : <code class="type">(<a href="Slap.C.html#TYPEnum_type">num_type</a>, <a href="Slap.C.html#TYPEprec">prec</a>) Bigarray.kind</code></pre>
<pre><span id="VALrprec"><span class="keyword">val</span> rprec</span> : <code class="type">(float, <a href="Slap.C.html#TYPErprec">rprec</a>) Bigarray.kind</code></pre>
<pre><span class="keyword">module</span> <a href="Slap.C.Vec.html">Vec</a>: <code class="code">sig</code> <a href="Slap.C.Vec.html">..</a> <code class="code">end</code></pre>
<pre><span class="keyword">module</span> <a href="Slap.C.Mat.html">Mat</a>: <code class="code">sig</code> <a href="Slap.C.Mat.html">..</a> <code class="code">end</code></pre>
<pre><span id="VALpp_num"><span class="keyword">val</span> pp_num</span> : <code class="type">Format.formatter -> <a href="Slap.C.html#TYPEnum_type">num_type</a> -> unit</code></pre><div class="info ">
A pretty-printer for elements in vectors and matrices.<br>
</div>

<pre><span id="VALpp_vec"><span class="keyword">val</span> pp_vec</span> : <code class="type">Format.formatter -> ('n, <a href="Slap.html#TYPEcnt">Slap.cnt</a>) <a href="Slap.C.html#TYPEvec">vec</a> -> unit</code></pre><div class="info ">
A pretty-printer for column vectors.<br>
</div>

<pre><span id="VALpp_mat"><span class="keyword">val</span> pp_mat</span> : <code class="type">Format.formatter -> ('m, 'n, <a href="Slap.html#TYPEcnt">Slap.cnt</a>) <a href="Slap.C.html#TYPEmat">mat</a> -> unit</code></pre><div class="info ">
A pretty-printer for matrices.<br>
</div>
<br>
<h2 id="2_BLASinterface">BLAS interface</h2><br>
<br>
<h3 id="3_Level1">Level 1</h3><br>

<pre><span id="VALswap"><span class="keyword">val</span> swap</span> : <code class="type">x:('n, 'x_cd) <a href="Slap.C.html#TYPEvec">vec</a> -> ('n, 'y_cd) <a href="Slap.C.html#TYPEvec">vec</a> -> unit</code></pre>
<pre><span id="VALscal"><span class="keyword">val</span> scal</span> : <code class="type"><a href="Slap.C.html#TYPEnum_type">num_type</a> -> ('n, 'cd) <a href="Slap.C.html#TYPEvec">vec</a> -> unit</code></pre>
<pre><span id="VALcopy"><span class="keyword">val</span> copy</span> : <code class="type">?y:('n, 'y_cd) <a href="Slap.C.html#TYPEvec">vec</a> -> ('n, 'x_cd) <a href="Slap.C.html#TYPEvec">vec</a> -> ('n, 'y_cd) <a href="Slap.C.html#TYPEvec">vec</a></code></pre>
<pre><span id="VALnrm2"><span class="keyword">val</span> nrm2</span> : <code class="type">('n, 'cd) <a href="Slap.C.html#TYPEvec">vec</a> -> float</code></pre>
<pre><span id="VALaxpy"><span class="keyword">val</span> axpy</span> : <code class="type">?alpha:<a href="Slap.C.html#TYPEnum_type">num_type</a> -><br>       x:('n, 'x_cd) <a href="Slap.C.html#TYPEvec">vec</a> -> ('n, 'y_cd) <a href="Slap.C.html#TYPEvec">vec</a> -> unit</code></pre>
<pre><span id="VALiamax"><span class="keyword">val</span> iamax</span> : <code class="type">('n, 'cd) <a href="Slap.C.html#TYPEvec">vec</a> -> int</code></pre>
<pre><span id="VALamax"><span class="keyword">val</span> amax</span> : <code class="type">('n, 'cd) <a href="Slap.C.html#TYPEvec">vec</a> -> <a href="Slap.C.html#TYPEnum_type">num_type</a></code></pre><br>
<h3 id="3_Level2">Level 2</h3><br>

<pre><span id="VALgemv"><span class="keyword">val</span> gemv</span> : <code class="type">?beta:<a href="Slap.C.html#TYPEnum_type">num_type</a> -><br>       ?y:('m, 'y_cd) <a href="Slap.C.html#TYPEvec">vec</a> -><br>       trans:(('a_m, 'a_n, 'a_cd) <a href="Slap.C.html#TYPEmat">mat</a> -> ('m, 'n, 'a_cd) <a href="Slap.C.html#TYPEmat">mat</a>)<br>             <a href="Slap.C.html#TYPEtrans3">trans3</a> -><br>       ?alpha:<a href="Slap.C.html#TYPEnum_type">num_type</a> -><br>       ('a_m, 'a_n, 'a_cd) <a href="Slap.C.html#TYPEmat">mat</a> -><br>       ('n, 'x_cd) <a href="Slap.C.html#TYPEvec">vec</a> -> ('m, 'y_cd) <a href="Slap.C.html#TYPEvec">vec</a></code></pre>
<pre><span id="VALsymv"><span class="keyword">val</span> symv</span> : <code class="type">?beta:<a href="Slap.C.html#TYPEnum_type">num_type</a> -><br>       ?y:('n, 'y_cd) <a href="Slap.C.html#TYPEvec">vec</a> -><br>       ?up:bool -><br>       ?alpha:<a href="Slap.C.html#TYPEnum_type">num_type</a> -><br>       ('n, 'n, 'a_cd) <a href="Slap.C.html#TYPEmat">mat</a> -><br>       ('n, 'x_cd) <a href="Slap.C.html#TYPEvec">vec</a> -> ('n, 'y_cd) <a href="Slap.C.html#TYPEvec">vec</a></code></pre>
<pre><span id="VALtrmv"><span class="keyword">val</span> trmv</span> : <code class="type">trans:(('n, 'n, 'a_cd) <a href="Slap.C.html#TYPEmat">mat</a> -> ('n, 'n, 'a_cd) <a href="Slap.C.html#TYPEmat">mat</a>)<br>             <a href="Slap.C.html#TYPEtrans3">trans3</a> -><br>       ?diag:<a href="Slap.Common.html#TYPEdiag">Slap.Common.diag</a> -><br>       ?up:bool -> ('n, 'n, 'a_cd) <a href="Slap.C.html#TYPEmat">mat</a> -> ('n, 'x_cd) <a href="Slap.C.html#TYPEvec">vec</a> -> unit</code></pre>
<pre><span id="VALtrsv"><span class="keyword">val</span> trsv</span> : <code class="type">trans:(('n, 'n, 'a_cd) <a href="Slap.C.html#TYPEmat">mat</a> -> ('n, 'n, 'a_cd) <a href="Slap.C.html#TYPEmat">mat</a>)<br>             <a href="Slap.C.html#TYPEtrans3">trans3</a> -><br>       ?diag:<a href="Slap.Common.html#TYPEdiag">Slap.Common.diag</a> -><br>       ?up:bool -> ('n, 'n, 'a_cd) <a href="Slap.C.html#TYPEmat">mat</a> -> ('n, 'x_cd) <a href="Slap.C.html#TYPEvec">vec</a> -> unit</code></pre><br>
<h3 id="3_Level3">Level 3</h3><br>

<pre><span id="VALgemm"><span class="keyword">val</span> gemm</span> : <code class="type">?beta:<a href="Slap.C.html#TYPEnum_type">num_type</a> -><br>       ?c:('m, 'n, 'c_cd) <a href="Slap.C.html#TYPEmat">mat</a> -><br>       transa:(('a_m, 'a_k, 'a_cd) <a href="Slap.C.html#TYPEmat">mat</a> -> ('m, 'k, 'a_cd) <a href="Slap.C.html#TYPEmat">mat</a>)<br>              <a href="Slap.C.html#TYPEtrans3">trans3</a> -><br>       ?alpha:<a href="Slap.C.html#TYPEnum_type">num_type</a> -><br>       ('a_m, 'a_k, 'a_cd) <a href="Slap.C.html#TYPEmat">mat</a> -><br>       transb:(('b_k, 'b_n, 'b_cd) <a href="Slap.C.html#TYPEmat">mat</a> -> ('k, 'n, 'b_cd) <a href="Slap.C.html#TYPEmat">mat</a>)<br>              <a href="Slap.C.html#TYPEtrans3">trans3</a> -><br>       ('b_k, 'b_n, 'b_cd) <a href="Slap.C.html#TYPEmat">mat</a> -> ('m, 'n, 'c_cd) <a href="Slap.C.html#TYPEmat">mat</a></code></pre>
<pre><span id="VALsymm"><span class="keyword">val</span> symm</span> : <code class="type">side:('k, 'm, 'n) <a href="Slap.Common.html#TYPEside">Slap.Common.side</a> -><br>       ?up:bool -><br>       ?beta:<a href="Slap.C.html#TYPEnum_type">num_type</a> -><br>       ?c:('m, 'n, 'c_cd) <a href="Slap.C.html#TYPEmat">mat</a> -><br>       ?alpha:<a href="Slap.C.html#TYPEnum_type">num_type</a> -><br>       ('k, 'k, 'a_cd) <a href="Slap.C.html#TYPEmat">mat</a> -><br>       ('m, 'n, 'b_cd) <a href="Slap.C.html#TYPEmat">mat</a> -> ('m, 'n, 'c_cd) <a href="Slap.C.html#TYPEmat">mat</a></code></pre>
<pre><span id="VALtrmm"><span class="keyword">val</span> trmm</span> : <code class="type">side:('k, 'm, 'n) <a href="Slap.Common.html#TYPEside">Slap.Common.side</a> -><br>       ?up:bool -><br>       transa:(('k, 'k, 'a_cd) <a href="Slap.C.html#TYPEmat">mat</a> -> ('k, 'k, 'a_cd) <a href="Slap.C.html#TYPEmat">mat</a>)<br>              <a href="Slap.C.html#TYPEtrans3">trans3</a> -><br>       ?diag:<a href="Slap.Common.html#TYPEdiag">Slap.Common.diag</a> -><br>       ?alpha:<a href="Slap.C.html#TYPEnum_type">num_type</a> -><br>       a:('k, 'k, 'a_cd) <a href="Slap.C.html#TYPEmat">mat</a> -> ('m, 'n, 'b_cd) <a href="Slap.C.html#TYPEmat">mat</a> -> unit</code></pre>
<pre><span id="VALtrsm"><span class="keyword">val</span> trsm</span> : <code class="type">side:('k, 'm, 'n) <a href="Slap.Common.html#TYPEside">Slap.Common.side</a> -><br>       ?up:bool -><br>       transa:(('k, 'k, 'a_cd) <a href="Slap.C.html#TYPEmat">mat</a> -> ('k, 'k, 'a_cd) <a href="Slap.C.html#TYPEmat">mat</a>)<br>              <a href="Slap.C.html#TYPEtrans3">trans3</a> -><br>       ?diag:<a href="Slap.Common.html#TYPEdiag">Slap.Common.diag</a> -><br>       ?alpha:<a href="Slap.C.html#TYPEnum_type">num_type</a> -><br>       a:('k, 'k, 'a_cd) <a href="Slap.C.html#TYPEmat">mat</a> -> ('m, 'n, 'b_cd) <a href="Slap.C.html#TYPEmat">mat</a> -> unit</code></pre>
<pre><span id="VALsyrk"><span class="keyword">val</span> syrk</span> : <code class="type">?up:bool -><br>       ?beta:<a href="Slap.C.html#TYPEnum_type">num_type</a> -><br>       ?c:('n, 'n, 'c_cd) <a href="Slap.C.html#TYPEmat">mat</a> -><br>       trans:(('a_n, 'a_k, 'a_cd) <a href="Slap.C.html#TYPEmat">mat</a> -> ('n, 'k, 'a_cd) <a href="Slap.C.html#TYPEmat">mat</a>)<br>             <a href="Slap.Common.html#TYPEtrans2">Slap.Common.trans2</a> -><br>       ?alpha:<a href="Slap.C.html#TYPEnum_type">num_type</a> -><br>       ('a_n, 'a_k, 'a_cd) <a href="Slap.C.html#TYPEmat">mat</a> -> ('n, 'n, 'c_cd) <a href="Slap.C.html#TYPEmat">mat</a></code></pre>
<pre><span id="VALsyr2k"><span class="keyword">val</span> syr2k</span> : <code class="type">?up:bool -><br>       ?beta:<a href="Slap.C.html#TYPEnum_type">num_type</a> -><br>       ?c:('n, 'n, 'c_cd) <a href="Slap.C.html#TYPEmat">mat</a> -><br>       trans:(('n, 'k, 'a) <a href="Slap.C.html#TYPEmat">mat</a> -> ('p, 'q, 'b) <a href="Slap.C.html#TYPEmat">mat</a>) <a href="Slap.Common.html#TYPEtrans2">Slap.Common.trans2</a> -><br>       ?alpha:<a href="Slap.C.html#TYPEnum_type">num_type</a> -><br>       ('p, 'q, 'a_cd) <a href="Slap.C.html#TYPEmat">mat</a> -><br>       ('p, 'q, 'b_cd) <a href="Slap.C.html#TYPEmat">mat</a> -> ('n, 'n, 'c_cd) <a href="Slap.C.html#TYPEmat">mat</a></code></pre><div class="info ">
<code class="code">syr2k ?up ?beta ?c ~trans ?alpha a b</code> computes
<p>
<ul>
<li><code class="code">c := alpha * a * b^T + alpha * b * a^T + beta * c</code> if <code class="code">trans</code> is
      <a href="Slap.Common.html#VALnormal"><code class="code">Slap.Common.normal</code></a>, or</li>
<li><code class="code">c := alpha * a^T * b + alpha * b^T * a + beta * c</code> if <code class="code">trans</code> is
      <a href="Slap.Common.html#VALtrans"><code class="code">Slap.Common.trans</code></a></li>
</ul>

    with symmetric matrix <code class="code">c</code>, general matrices <code class="code">a</code> and <code class="code">b</code>.<br>
</div>
<br>
<h2 id="2_LAPACKinterface">LAPACK interface</h2><br>
<br>
<h3 id="3_Auxiliaryroutines">Auxiliary routines</h3><br>

<pre><span id="VALlacpy"><span class="keyword">val</span> lacpy</span> : <code class="type">?uplo:[ `L | `U ] -><br>       ?b:('m, 'n, 'b_cd) <a href="Slap.C.html#TYPEmat">mat</a> -><br>       ('m, 'n, 'a_cd) <a href="Slap.C.html#TYPEmat">mat</a> -> ('m, 'n, 'b_cd) <a href="Slap.C.html#TYPEmat">mat</a></code></pre><div class="info ">
<code class="code">lacpy ?uplo ?b a</code> copies the matrix <code class="code">a</code> into the matrix <code class="code">b</code>.<ul>
<li>If <code class="code">uplo</code> is omitted, all elements in <code class="code">a</code> is copied.</li>
<li>If <code class="code">uplo</code> is <code class="code">`U</code>, the upper trapezoidal part of <code class="code">a</code> is copied.</li>
<li>If <code class="code">uplo</code> is <code class="code">`L</code>, the lower trapezoidal part of <code class="code">a</code> is copied.</li>
</ul>
<br>
<b>Returns</b> <code class="code">b</code>, which is overwritten.<br>
</div>
<div class="param_info"><code class="code">uplo</code> : default = all elements in <code class="code">a</code> is copied.</div>
<div class="param_info"><code class="code">b</code> : default = a fresh matrix.</div>

<pre><span id="VALlassq"><span class="keyword">val</span> lassq</span> : <code class="type">?scale:float -> ?sumsq:float -> ('n, 'cd) <a href="Slap.C.html#TYPEvec">vec</a> -> float * float</code></pre><div class="info ">
<code class="code">lassq ?scale ?sumsq x</code> see LAPACK documentation.<br>
<b>Returns</b> <code class="code">(scl, ssq)</code><br>
</div>
<div class="param_info"><code class="code">scale</code> : default = 0.</div>
<div class="param_info"><code class="code">sumsq</code> : default = 1.</div>

<pre><span id="TYPElarnv_liseed"><span class="keyword">type</span> <code class="type"></code>larnv_liseed</span> = <code class="type"><a href="Slap.Size.html#TYPEz">Slap.Size.z</a> <a href="Slap.Size.html#TYPEs">Slap.Size.s</a> <a href="Slap.Size.html#TYPEs">Slap.Size.s</a> <a href="Slap.Size.html#TYPEs">Slap.Size.s</a> <a href="Slap.Size.html#TYPEs">Slap.Size.s</a></code> </pre>


<pre><span id="VALlarnv"><span class="keyword">val</span> larnv</span> : <code class="type">?idist:[ `Normal | `Uniform0 | `Uniform1 ] -><br>       ?iseed:(<a href="Slap.C.html#TYPElarnv_liseed">larnv_liseed</a>, <a href="Slap.html#TYPEcnt">Slap.cnt</a>) <a href="Slap.Common.html#TYPEint32_vec">Slap.Common.int32_vec</a> -><br>       x:('n, <a href="Slap.html#TYPEcnt">Slap.cnt</a>) <a href="Slap.C.html#TYPEvec">vec</a> -> unit -> ('n, 'cnt) <a href="Slap.C.html#TYPEvec">vec</a></code></pre>
<pre><span id="TYPElange_min_lwork"><span class="keyword">type</span> <code class="type">('m, 'a)</code> lange_min_lwork</span> </pre>


<pre><span id="VALlange_min_lwork"><span class="keyword">val</span> lange_min_lwork</span> : <code class="type">'m <a href="Slap.Size.html#TYPEt">Slap.Size.t</a> -><br>       'a <a href="Slap.Common.html#TYPEnorm4">Slap.Common.norm4</a> -> ('m, 'a) <a href="Slap.C.html#TYPElange_min_lwork">lange_min_lwork</a> <a href="Slap.Size.html#TYPEt">Slap.Size.t</a></code></pre>
<pre><span id="VALlange"><span class="keyword">val</span> lange</span> : <code class="type">?norm:'a <a href="Slap.Common.html#TYPEnorm4">Slap.Common.norm4</a> -><br>       ?work:('lwork, <a href="Slap.html#TYPEcnt">Slap.cnt</a>) <a href="Slap.C.html#TYPErvec">rvec</a> -> ('m, 'n, 'cd) <a href="Slap.C.html#TYPEmat">mat</a> -> float</code></pre><div class="info ">
<code class="code">lange ?norm ?work a</code><br>
<b>Returns</b> the norm of matrix <code class="code">a</code>.<br>
</div>
<div class="param_info"><code class="code">norm</code> : default = <a href="Slap.Common.html#VALnorm_1"><code class="code">Slap.Common.norm_1</code></a>.</div>
<div class="param_info"><code class="code">work</code> : default = allocated work space for norm <a href="Slap.Common.html#VALnorm_inf"><code class="code">Slap.Common.norm_inf</code></a>.</div>

<pre><span id="VALlauum"><span class="keyword">val</span> lauum</span> : <code class="type">?up:bool -> ('n, 'n, 'cd) <a href="Slap.C.html#TYPEmat">mat</a> -> unit</code></pre><div class="info ">
<code class="code">lauum ?up a</code> computes
<p>
<ul>
<li><code class="code">U * U^T</code> where <code class="code">U</code> is the upper triangular part of matrix <code class="code">a</code>
      if <code class="code">up</code> is <code class="code">true</code>.</li>
<li><code class="code">L^T * L</code> where <code class="code">L</code> is the lower triangular part of matrix <code class="code">a</code>
      if <code class="code">up</code> is <code class="code">false</code>.</li>
</ul>

    The upper or lower triangular part is overwritten.<br>
</div>
<div class="param_info"><code class="code">up</code> : default = <code class="code">true</code>.</div>
<br>
<h3 id="3_Linearequationscomputationalroutines">Linear equations (computational routines)</h3><br>

<pre><span id="VALgetrf"><span class="keyword">val</span> getrf</span> : <code class="type">?ipiv:(('m, 'n) <a href="Slap.Size.html#TYPEmin">Slap.Size.min</a>, <a href="Slap.html#TYPEcnt">Slap.cnt</a>) <a href="Slap.Common.html#TYPEint32_vec">Slap.Common.int32_vec</a> -><br>       ('m, 'n, 'cd) <a href="Slap.C.html#TYPEmat">mat</a> -><br>       (('m, 'n) <a href="Slap.Size.html#TYPEmin">Slap.Size.min</a>, 'cnt) <a href="Slap.Common.html#TYPEint32_vec">Slap.Common.int32_vec</a></code></pre>
<pre><span id="VALgetrs"><span class="keyword">val</span> getrs</span> : <code class="type">?ipiv:(('n, 'n) <a href="Slap.Size.html#TYPEmin">Slap.Size.min</a>, <a href="Slap.html#TYPEcnt">Slap.cnt</a>) <a href="Slap.Common.html#TYPEint32_vec">Slap.Common.int32_vec</a> -><br>       trans:(('n, 'n, 'a_cd) <a href="Slap.C.html#TYPEmat">mat</a> -> ('n, 'n, 'a_cd) <a href="Slap.C.html#TYPEmat">mat</a>)<br>             <a href="Slap.C.html#TYPEtrans3">trans3</a> -><br>       ('n, 'n, 'a_cd) <a href="Slap.C.html#TYPEmat">mat</a> -> ('n, 'n, 'b_cd) <a href="Slap.C.html#TYPEmat">mat</a> -> unit</code></pre>
<pre><span id="TYPEgetri_min_lwork"><span class="keyword">type</span> <code class="type">'n</code> getri_min_lwork</span> </pre>


<pre><span id="VALgetri_min_lwork"><span class="keyword">val</span> getri_min_lwork</span> : <code class="type">'n <a href="Slap.Size.html#TYPEt">Slap.Size.t</a> -> 'ngetri_min_lwork <a href="Slap.Size.html#TYPEt">Slap.Size.t</a></code></pre>
<pre><span id="VALgetri_opt_lwork"><span class="keyword">val</span> getri_opt_lwork</span> : <code class="type">('n, 'n, 'cd) <a href="Slap.C.html#TYPEmat">mat</a> -> (module Slap.Size.SIZE)</code></pre>
<pre><span id="VALgetri"><span class="keyword">val</span> getri</span> : <code class="type">?ipiv:(('n, 'n) <a href="Slap.Size.html#TYPEmin">Slap.Size.min</a>, <a href="Slap.html#TYPEcnt">Slap.cnt</a>) <a href="Slap.Common.html#TYPEint32_vec">Slap.Common.int32_vec</a> -><br>       ?work:('lwork, <a href="Slap.html#TYPEcnt">Slap.cnt</a>) <a href="Slap.C.html#TYPEvec">vec</a> -> ('n, 'n, 'cd) <a href="Slap.C.html#TYPEmat">mat</a> -> unit</code></pre><div class="info ">
<code class="code">getri ?ipiv ?work a</code> computes the inverse of general matrix <code class="code">a</code> by
    LU-factorization of <code class="code">getrf</code>.<br>
<b>Raises</b> <code>Failure</code> if the matrix is singular.<br>
</div>

<pre><span id="TYPEsytrf_min_lwork"><span class="keyword">type</span> <code class="type"></code>sytrf_min_lwork</span> </pre>


<pre><span id="VALsytrf_min_lwork"><span class="keyword">val</span> sytrf_min_lwork</span> : <code class="type">unit -> <a href="Slap.C.html#TYPEsytrf_min_lwork">sytrf_min_lwork</a> <a href="Slap.Size.html#TYPEt">Slap.Size.t</a></code></pre>
<pre><span id="VALsytrf_opt_lwork"><span class="keyword">val</span> sytrf_opt_lwork</span> : <code class="type">?up:bool -> ('n, 'n, 'cd) <a href="Slap.C.html#TYPEmat">mat</a> -> (module Slap.Size.SIZE)</code></pre>
<pre><span id="VALsytrf"><span class="keyword">val</span> sytrf</span> : <code class="type">?up:bool -><br>       ?ipiv:('n, <a href="Slap.html#TYPEcnt">Slap.cnt</a>) <a href="Slap.Common.html#TYPEint32_vec">Slap.Common.int32_vec</a> -><br>       ?work:('lwork, <a href="Slap.html#TYPEcnt">Slap.cnt</a>) <a href="Slap.C.html#TYPEvec">vec</a> -><br>       ('n, 'n, 'cd) <a href="Slap.C.html#TYPEmat">mat</a> -> ('n, 'cnt) <a href="Slap.Common.html#TYPEint32_vec">Slap.Common.int32_vec</a></code></pre>
<pre><span id="VALsytrs"><span class="keyword">val</span> sytrs</span> : <code class="type">?up:bool -><br>       ?ipiv:('n, <a href="Slap.html#TYPEcnt">Slap.cnt</a>) <a href="Slap.Common.html#TYPEint32_vec">Slap.Common.int32_vec</a> -><br>       ('n, 'n, 'a_cd) <a href="Slap.C.html#TYPEmat">mat</a> -> ('n, 'nrhs, 'b_cd) <a href="Slap.C.html#TYPEmat">mat</a> -> unit</code></pre>
<pre><span id="TYPEsytri_min_lwork"><span class="keyword">type</span> <code class="type">'n</code> sytri_min_lwork</span> </pre>


<pre><span id="VALsytri_min_lwork"><span class="keyword">val</span> sytri_min_lwork</span> : <code class="type">'n <a href="Slap.Size.html#TYPEt">Slap.Size.t</a> -> 'n <a href="Slap.C.html#TYPEsytri_min_lwork">sytri_min_lwork</a> <a href="Slap.Size.html#TYPEt">Slap.Size.t</a></code></pre>
<pre><span id="VALsytri"><span class="keyword">val</span> sytri</span> : <code class="type">?up:bool -><br>       ?ipiv:('n, <a href="Slap.html#TYPEcnt">Slap.cnt</a>) <a href="Slap.Common.html#TYPEint32_vec">Slap.Common.int32_vec</a> -><br>       ?work:('lwork, <a href="Slap.html#TYPEcnt">Slap.cnt</a>) <a href="Slap.C.html#TYPEvec">vec</a> -> ('n, 'n, 'cd) <a href="Slap.C.html#TYPEmat">mat</a> -> unit</code></pre>
<pre><span id="VALpotrf"><span class="keyword">val</span> potrf</span> : <code class="type">?up:bool -> ?jitter:<a href="Slap.C.html#TYPEnum_type">num_type</a> -> ('n, 'n, 'cd) <a href="Slap.C.html#TYPEmat">mat</a> -> unit</code></pre>
<pre><span id="VALpotrs"><span class="keyword">val</span> potrs</span> : <code class="type">?up:bool -><br>       ('n, 'n, 'a_cd) <a href="Slap.C.html#TYPEmat">mat</a> -><br>       ?factorize:bool -><br>       ?jitter:<a href="Slap.C.html#TYPEnum_type">num_type</a> -> ('n, 'nrhs, 'b_cd) <a href="Slap.C.html#TYPEmat">mat</a> -> unit</code></pre>
<pre><span id="VALpotri"><span class="keyword">val</span> potri</span> : <code class="type">?up:bool -><br>       ?factorize:bool -><br>       ?jitter:<a href="Slap.C.html#TYPEnum_type">num_type</a> -> ('n, 'n, 'cd) <a href="Slap.C.html#TYPEmat">mat</a> -> unit</code></pre>
<pre><span id="VALtrtrs"><span class="keyword">val</span> trtrs</span> : <code class="type">?up:bool -><br>       trans:(('n, 'n, 'a_cd) <a href="Slap.C.html#TYPEmat">mat</a> -> ('n, 'n, 'a_cd) <a href="Slap.C.html#TYPEmat">mat</a>)<br>             <a href="Slap.C.html#TYPEtrans3">trans3</a> -><br>       ?diag:<a href="Slap.Common.html#TYPEdiag">Slap.Common.diag</a> -><br>       ('n, 'n, 'a_cd) <a href="Slap.C.html#TYPEmat">mat</a> -> ('n, 'nrhs, 'b_cd) <a href="Slap.C.html#TYPEmat">mat</a> -> unit</code></pre>
<pre><span id="VALtrtri"><span class="keyword">val</span> trtri</span> : <code class="type">?up:bool -> ?diag:<a href="Slap.Common.html#TYPEdiag">Slap.Common.diag</a> -> ('n, 'n, 'cd) <a href="Slap.C.html#TYPEmat">mat</a> -> unit</code></pre>
<pre><span id="TYPEgeqrf_min_lwork"><span class="keyword">type</span> <code class="type">'n</code> geqrf_min_lwork</span> </pre>


<pre><span id="VALgeqrf_min_lwork"><span class="keyword">val</span> geqrf_min_lwork</span> : <code class="type">n:'n <a href="Slap.Size.html#TYPEt">Slap.Size.t</a> -> 'n <a href="Slap.C.html#TYPEgeqrf_min_lwork">geqrf_min_lwork</a> <a href="Slap.Size.html#TYPEt">Slap.Size.t</a></code></pre>
<pre><span id="VALgeqrf_opt_lwork"><span class="keyword">val</span> geqrf_opt_lwork</span> : <code class="type">('m, 'n, 'cd) <a href="Slap.C.html#TYPEmat">mat</a> -> (module Slap.Size.SIZE)</code></pre>
<pre><span id="VALgeqrf"><span class="keyword">val</span> geqrf</span> : <code class="type">?work:('lwork, <a href="Slap.html#TYPEcnt">Slap.cnt</a>) <a href="Slap.C.html#TYPEvec">vec</a> -><br>       ?tau:(('m, 'n) <a href="Slap.Size.html#TYPEmin">Slap.Size.min</a>, <a href="Slap.html#TYPEcnt">Slap.cnt</a>) <a href="Slap.C.html#TYPEvec">vec</a> -><br>       ('m, 'n, 'cd) <a href="Slap.C.html#TYPEmat">mat</a> -> (('m, 'n) <a href="Slap.Size.html#TYPEmin">Slap.Size.min</a>, 'cnt) <a href="Slap.C.html#TYPEvec">vec</a></code></pre><br>
<h3 id="3_Linearequationssimpledrivers">Linear equations (simple drivers)</h3><br>

<pre><span id="VALgesv"><span class="keyword">val</span> gesv</span> : <code class="type">?ipiv:('n, <a href="Slap.html#TYPEcnt">Slap.cnt</a>) <a href="Slap.Common.html#TYPEint32_vec">Slap.Common.int32_vec</a> -><br>       ('n, 'n, 'a_cd) <a href="Slap.C.html#TYPEmat">mat</a> -> ('n, 'nrhs, 'b_cd) <a href="Slap.C.html#TYPEmat">mat</a> -> unit</code></pre>
<pre><span id="VALposv"><span class="keyword">val</span> posv</span> : <code class="type">?up:bool -><br>       ('n, 'n, 'a_cd) <a href="Slap.C.html#TYPEmat">mat</a> -> ('n, 'nrhs, 'b_cd) <a href="Slap.C.html#TYPEmat">mat</a> -> unit</code></pre>
<pre><span id="VALsysv_opt_lwork"><span class="keyword">val</span> sysv_opt_lwork</span> : <code class="type">?up:bool -><br>       ('n, 'n, 'a_cd) <a href="Slap.C.html#TYPEmat">mat</a> -><br>       ('n, 'nrhs, 'b_cd) <a href="Slap.C.html#TYPEmat">mat</a> -> (module Slap.Size.SIZE)</code></pre>
<pre><span id="VALsysv"><span class="keyword">val</span> sysv</span> : <code class="type">?up:bool -><br>       ?ipiv:('n, <a href="Slap.html#TYPEcnt">Slap.cnt</a>) <a href="Slap.Common.html#TYPEint32_vec">Slap.Common.int32_vec</a> -><br>       ?work:('lwork, <a href="Slap.html#TYPEcnt">Slap.cnt</a>) <a href="Slap.C.html#TYPEvec">vec</a> -><br>       ('n, 'n, 'a_cd) <a href="Slap.C.html#TYPEmat">mat</a> -> ('n, 'nrhs, 'b_cd) <a href="Slap.C.html#TYPEmat">mat</a> -> unit</code></pre><br>
<h3 id="3_Leastsquaressimpledrivers">Least squares (simple drivers)</h3><br>

<pre><span id="TYPEgels_min_lwork"><span class="keyword">type</span> <code class="type">('m, 'n, 'nrhs)</code> gels_min_lwork</span> </pre>


<pre><span id="VALgels_min_lwork"><span class="keyword">val</span> gels_min_lwork</span> : <code class="type">m:'m <a href="Slap.Size.html#TYPEt">Slap.Size.t</a> -><br>       n:'n <a href="Slap.Size.html#TYPEt">Slap.Size.t</a> -><br>       nrhs:'nrhs <a href="Slap.Size.html#TYPEt">Slap.Size.t</a> -> ('m, 'n, 'nrhs) <a href="Slap.C.html#TYPEgels_min_lwork">gels_min_lwork</a> <a href="Slap.Size.html#TYPEt">Slap.Size.t</a></code></pre>
<pre><span id="VALgels_opt_lwork"><span class="keyword">val</span> gels_opt_lwork</span> : <code class="type">trans:(('am, 'an, 'a_cd) <a href="Slap.C.html#TYPEmat">mat</a> -> ('m, 'n, 'a_cd) <a href="Slap.C.html#TYPEmat">mat</a>)<br>             <a href="Slap.Common.html#TYPEtrans2">Slap.Common.trans2</a> -><br>       ('m, 'n, 'a_cd) <a href="Slap.C.html#TYPEmat">mat</a> -><br>       ('m, 'nrhs, 'b_cd) <a href="Slap.C.html#TYPEmat">mat</a> -> (module Slap.Size.SIZE)</code></pre>
<pre><span id="VALgels"><span class="keyword">val</span> gels</span> : <code class="type">?work:('work, <a href="Slap.html#TYPEcnt">Slap.cnt</a>) <a href="Slap.C.html#TYPEvec">vec</a> -><br>       trans:(('am, 'an, 'a_cd) <a href="Slap.C.html#TYPEmat">mat</a> -> ('m, 'n, 'a_cd) <a href="Slap.C.html#TYPEmat">mat</a>)<br>             <a href="Slap.Common.html#TYPEtrans2">Slap.Common.trans2</a> -><br>       ('m, 'n, 'a_cd) <a href="Slap.C.html#TYPEmat">mat</a> -> ('m, 'nrhs, 'b_cd) <a href="Slap.C.html#TYPEmat">mat</a> -> unit</code></pre><div class="info ">
<code class="code">gels ?work ~trans a b</code> see LAPACK documentation.<br>
</div>
<div class="param_info"><code class="code">work</code> : default = an optimum-length vector.</div>
</body></html>