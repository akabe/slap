<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="Slap.Z.Vec.html">
<link rel="Up" href="Slap.Z.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Slap" rel="Chapter" href="Slap.html"><link title="Creation of matrices" rel="Section" href="#2_Creationofmatrices">
<link title="Accessors" rel="Section" href="#2_Accessors">
<link title="Basic operations" rel="Section" href="#2_Basicoperations">
<link title="Type conversion" rel="Section" href="#2_Typeconversion">
<link title="Iterators" rel="Section" href="#2_Iterators">
<link title="Matrix transformations" rel="Section" href="#2_Matrixtransformations">
<link title="Arithmetic operations" rel="Section" href="#2_Arithmeticoperations">
<link title="Submatrices" rel="Section" href="#2_Submatrices">
<link title="Creation of vectors" rel="Section" href="#2_Creationofvectors">
<title>Slap.Z.Mat</title>
</head>
<body>
<div class="navbar"><a href="Slap.Z.Vec.html">Previous</a>
&nbsp;<a href="Slap.Z.html">Up</a>
&nbsp;</div>
<center><h1>Module <a href="type_Slap.Z.Mat.html">Slap.Z.Mat</a></h1></center>
<br>
<pre><span class="keyword">module</span> Mat: <code class="code">sig</code> <a href="Slap.Z.Mat.html">..</a> <code class="code">end</code></pre><hr width="100%">
<pre><span class="keyword">module type</span> <a href="Slap.Z.Mat.CNTMAT.html">CNTMAT</a> = <code class="code">sig</code> <a href="Slap.Z.Mat.CNTMAT.html">..</a> <code class="code">end</code></pre><div class="info">
The signature of modules containing dynamically-sized contiguous matrices.
</div>
<pre><span class="keyword">module type</span> <a href="Slap.Z.Mat.DSCMAT.html">DSCMAT</a> = <code class="code">sig</code> <a href="Slap.Z.Mat.DSCMAT.html">..</a> <code class="code">end</code></pre><div class="info">
The signature of modules containing dynamically-sized discrete matrices.
</div>
<pre><span id="VALcnt"><span class="keyword">val</span> cnt</span> : <code class="type">('a, 'b, <a href="Slap.html#TYPEcnt">Slap.cnt</a>) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -> ('a, 'b, 'c) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a></code></pre><div class="info">
Recover polymorphism of the fifth type parameter.<br>
</div>
<br>
<span id="2_Creationofmatrices"><h2>Creation of matrices</h2></span><br>
<pre><span id="VALempty"><span class="keyword">val</span> empty</span> : <code class="type">(<a href="Slap.Size.html#TYPEz">Slap.Size.z</a>, <a href="Slap.Size.html#TYPEz">Slap.Size.z</a>, 'a) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a></code></pre><div class="info">
An empty matrix.<br>
</div>
<pre><span id="VALcreate"><span class="keyword">val</span> create</span> : <code class="type">'a <a href="Slap.Size.html#TYPEt">Slap.Size.t</a> -> 'b <a href="Slap.Size.html#TYPEt">Slap.Size.t</a> -> ('a, 'b, 'c) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a></code></pre><div class="info">
<code class="code">create m n</code><br>
<b>Returns</b> a fresh <code class="code">m</code>-by-<code class="code">n</code> matrix (not initialized).<br>
</div>
<pre><span id="VALmake"><span class="keyword">val</span> make</span> : <code class="type">'a <a href="Slap.Size.html#TYPEt">Slap.Size.t</a> -><br>       'b <a href="Slap.Size.html#TYPEt">Slap.Size.t</a> -> <a href="Slap.Z.html#TYPEnum_type">Slap.Z.num_type</a> -> ('a, 'b, 'c) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a></code></pre><div class="info">
<code class="code">make m n x</code><br>
<b>Returns</b> a fresh <code class="code">m</code>-by-<code class="code">n</code> matrix initialized with <code class="code">x</code>.<br>
</div>
<pre><span id="VALmake0"><span class="keyword">val</span> make0</span> : <code class="type">'a <a href="Slap.Size.html#TYPEt">Slap.Size.t</a> -> 'b <a href="Slap.Size.html#TYPEt">Slap.Size.t</a> -> ('a, 'b, 'c) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a></code></pre><div class="info">
<code class="code">make0 m n</code><br>
<b>Returns</b> a fresh <code class="code">m</code>-by-<code class="code">n</code> matrix initialized with <code class="code">0</code>.<br>
</div>
<pre><span id="VALmake1"><span class="keyword">val</span> make1</span> : <code class="type">'a <a href="Slap.Size.html#TYPEt">Slap.Size.t</a> -> 'b <a href="Slap.Size.html#TYPEt">Slap.Size.t</a> -> ('a, 'b, 'c) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a></code></pre><div class="info">
<code class="code">make1 m n</code><br>
<b>Returns</b> a fresh <code class="code">m</code>-by-<code class="code">n</code> matrix initialized with <code class="code">1</code>.<br>
</div>
<pre><span id="VALidentity"><span class="keyword">val</span> identity</span> : <code class="type">'a <a href="Slap.Size.html#TYPEt">Slap.Size.t</a> -> ('a, 'a, 'b) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a></code></pre><div class="info">
<code class="code">identity n</code><br>
<b>Returns</b> a fresh <code class="code">n</code>-by-<code class="code">n</code> identity matrix.<br>
</div>
<pre><span id="VALinit"><span class="keyword">val</span> init</span> : <code class="type">'a <a href="Slap.Size.html#TYPEt">Slap.Size.t</a> -><br>       'b <a href="Slap.Size.html#TYPEt">Slap.Size.t</a> -> (int -> int -> <a href="Slap.Z.html#TYPEnum_type">Slap.Z.num_type</a>) -> ('a, 'b, 'c) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a></code></pre><div class="info">
An alias of <code class="code">init_cols</code>.<br>
</div>
<pre><span id="VALinit_cols"><span class="keyword">val</span> init_cols</span> : <code class="type">'a <a href="Slap.Size.html#TYPEt">Slap.Size.t</a> -><br>       'b <a href="Slap.Size.html#TYPEt">Slap.Size.t</a> -> (int -> int -> <a href="Slap.Z.html#TYPEnum_type">Slap.Z.num_type</a>) -> ('a, 'b, 'c) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a></code></pre><div class="info">
<code class="code">init_cols m n f</code> returns a fresh <code class="code">m</code>-by-<code class="code">n</code> matrix whose
    the <code class="code">(i,j)</code> element is initialized by the result of calling <code class="code">f i j</code>.
    The elements are passed column-wise.<br>
</div>
<pre><span id="VALinit_rows"><span class="keyword">val</span> init_rows</span> : <code class="type">'a <a href="Slap.Size.html#TYPEt">Slap.Size.t</a> -><br>       'b <a href="Slap.Size.html#TYPEt">Slap.Size.t</a> -> (int -> int -> <a href="Slap.Z.html#TYPEnum_type">Slap.Z.num_type</a>) -> ('a, 'b, 'c) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a></code></pre><div class="info">
<code class="code">init_rows m n f</code> returns a fresh <code class="code">m</code>-by-<code class="code">n</code> matrix whose
    the <code class="code">(i,j)</code> element is initialized by the result of calling <code class="code">f i j</code>.
    The elements are passed row-wise.<br>
</div>
<br>
<span id="2_Accessors"><h2>Accessors</h2></span><br>
<pre><span id="VALdim"><span class="keyword">val</span> dim</span> : <code class="type">('a, 'b, 'c) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -> 'a <a href="Slap.Size.html#TYPEt">Slap.Size.t</a> * 'b <a href="Slap.Size.html#TYPEt">Slap.Size.t</a></code></pre><div class="info">
<code class="code">dim a</code> is <code class="code">(dim1 a, dim2 a)</code>.<br>
</div>
<pre><span id="VALdim1"><span class="keyword">val</span> dim1</span> : <code class="type">('a, 'b, 'c) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -> 'a <a href="Slap.Size.html#TYPEt">Slap.Size.t</a></code></pre><div class="info">
<code class="code">dim1 a</code><br>
<b>Returns</b> the number of rows in <code class="code">a</code>.<br>
</div>
<pre><span id="VALdim2"><span class="keyword">val</span> dim2</span> : <code class="type">('a, 'b, 'c) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -> 'b <a href="Slap.Size.html#TYPEt">Slap.Size.t</a></code></pre><div class="info">
<code class="code">dim1 a</code><br>
<b>Returns</b> the number of columns in <code class="code">a</code>.<br>
</div>
<pre><span id="VALget_dyn"><span class="keyword">val</span> get_dyn</span> : <code class="type">('a, 'b, 'c) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -> int -> int -> <a href="Slap.Z.html#TYPEnum_type">Slap.Z.num_type</a></code></pre><div class="info">
<code class="code">get_dyn a i j</code><br>
<b>Returns</b> the <code class="code">(i,j)</code> element of the matrix <code class="code">a</code>.<br>
</div>
<pre><span id="VALset_dyn"><span class="keyword">val</span> set_dyn</span> : <code class="type">('a, 'b, 'c) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -> int -> int -> <a href="Slap.Z.html#TYPEnum_type">Slap.Z.num_type</a> -> unit</code></pre><div class="info">
<code class="code">set_dyn a i j x</code> assigns <code class="code">x</code> to the <code class="code">(i,j)</code> element of the matrix <code class="code">a</code>.<br>
</div>
<pre><span id="VALunsafe_get"><span class="keyword">val</span> unsafe_get</span> : <code class="type">('a, 'b, 'c) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -> int -> int -> <a href="Slap.Z.html#TYPEnum_type">Slap.Z.num_type</a></code></pre><div class="info">
Like <a href="Slap.Mat.html#VALget_dyn"><code class="code">Slap.Mat.get_dyn</code></a>, but size checking is not always performed.<br>
</div>
<pre><span id="VALunsafe_set"><span class="keyword">val</span> unsafe_set</span> : <code class="type">('a, 'b, 'c) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -> int -> int -> <a href="Slap.Z.html#TYPEnum_type">Slap.Z.num_type</a> -> unit</code></pre><div class="info">
Like <a href="Slap.Mat.html#VALset_dyn"><code class="code">Slap.Mat.set_dyn</code></a>, but size checking is not always performed.<br>
</div>
<pre><span id="VALcol_dyn"><span class="keyword">val</span> col_dyn</span> : <code class="type">('a, 'b, 'c) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -> int -> ('a, 'd) <a href="Slap.Z.html#TYPEvec">Slap.Z.vec</a></code></pre><div class="info">
<code class="code">col_dyn a i</code><br>
<b>Returns</b> the <code class="code">i</code>-th column of the matrix <code class="code">a</code>. The data are shared.<br>
</div>
<pre><span id="VALrow_dyn"><span class="keyword">val</span> row_dyn</span> : <code class="type">('a, 'b, 'c) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -> int -> ('b, <a href="Slap.html#TYPEdsc">Slap.dsc</a>) <a href="Slap.Z.html#TYPEvec">Slap.Z.vec</a></code></pre><div class="info">
<code class="code">row_dyn a i</code><br>
<b>Returns</b> the <code class="code">i</code>-th row of the matrix <code class="code">a</code>. The data are shared.<br>
</div>
<pre><span id="VALcopy_row_dyn"><span class="keyword">val</span> copy_row_dyn</span> : <code class="type">('a, 'b, 'c) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -> int -> ('b, 'd) <a href="Slap.Z.html#TYPEvec">Slap.Z.vec</a></code></pre><div class="info">
<code class="code">copy_row_dyn a i</code> is <code class="code">Vec.copy (Mat.row_dyn a i)</code>.<br>
</div>
<pre><span id="VALdiag"><span class="keyword">val</span> diag</span> : <code class="type">('a, 'a, 'b) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -> ('a, <a href="Slap.html#TYPEdsc">Slap.dsc</a>) <a href="Slap.Z.html#TYPEvec">Slap.Z.vec</a></code></pre><div class="info">
<code class="code">diag a</code><br>
<b>Returns</b> the diagonal elements of the matrix <code class="code">a</code>. The data are shared.<br>
</div>
<pre><span id="VALcopy_diag"><span class="keyword">val</span> copy_diag</span> : <code class="type">('a, 'a, 'b) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -> ('a, 'c) <a href="Slap.Z.html#TYPEvec">Slap.Z.vec</a></code></pre><div class="info">
<code class="code">copy_diag a</code> is <code class="code">Vec.copy (Mat.diag a)</code>.<br>
</div>
<pre><span id="VALas_vec"><span class="keyword">val</span> as_vec</span> : <code class="type">('a, 'b, <a href="Slap.html#TYPEcnt">Slap.cnt</a>) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -> (('a, 'b) <a href="Slap.Size.html#TYPEmul">Slap.Size.mul</a>, 'c) <a href="Slap.Z.html#TYPEvec">Slap.Z.vec</a></code></pre><div class="info">
<code class="code">as_vec a</code><br>
<b>Returns</b> the vector containing all elements of the matrix in column-major
    order. The data are shared.<br>
</div>
<br>
<span id="2_Basicoperations"><h2>Basic operations</h2></span><br>
<pre><span id="VALfill"><span class="keyword">val</span> fill</span> : <code class="type">('a, 'b, 'c) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -> <a href="Slap.Z.html#TYPEnum_type">Slap.Z.num_type</a> -> unit</code></pre><div class="info">
Fill the given matrix with the given value.<br>
<b>Since</b> 0.1.0<br>
</div>
<pre><span id="VALcopy"><span class="keyword">val</span> copy</span> : <code class="type">?uplo:[ `L | `U ] -><br>       ?b:('a, 'b, 'c) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -><br>       ('a, 'b, 'd) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -> ('a, 'b, 'c) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a></code></pre><div class="info">
<code class="code">copy ?uplo ?b a</code> copies the matrix <code class="code">a</code> into the matrix <code class="code">b</code> with
    the LAPACK function <code class="code">lacpy</code>.<ul>
<li>If <code class="code">uplo</code> is omitted, all elements in <code class="code">a</code> is copied.</li>
<li>If <code class="code">uplo</code> is <code class="code">`U</code>, the upper trapezoidal part of <code class="code">a</code> is copied.</li>
<li>If <code class="code">uplo</code> is <code class="code">`L</code>, the lower trapezoidal part of <code class="code">a</code> is copied.</li>
</ul>
<br>
<b>Returns</b> <code class="code">b</code>, which is overwritten.<br>
</div>
<div class="param_info"><code class="code">uplo</code> : default = all elements in <code class="code">a</code> is copied.</div>
<div class="param_info"><code class="code">b</code> : default = a fresh matrix.</div>
<pre><span id="VALof_col_vecs_dyn"><span class="keyword">val</span> of_col_vecs_dyn</span> : <code class="type">'a <a href="Slap.Size.html#TYPEt">Slap.Size.t</a> -><br>       'b <a href="Slap.Size.html#TYPEt">Slap.Size.t</a> -> ('a, <a href="Slap.html#TYPEcnt">Slap.cnt</a>) <a href="Slap.Z.html#TYPEvec">Slap.Z.vec</a> array -> ('a, 'b, 'c) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a></code></pre><br>
<span id="2_Typeconversion"><h2>Type conversion</h2></span><br>
<pre><span id="VALto_array"><span class="keyword">val</span> to_array</span> : <code class="type">('a, 'b, 'c) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -> <a href="Slap.Z.html#TYPEnum_type">Slap.Z.num_type</a> array array</code></pre><div class="info">
<code class="code">to_array a</code><br>
<b>Returns</b> the array of arrays of all the elements of <code class="code">a</code>.<br>
</div>
<pre><span id="VALof_array_dyn"><span class="keyword">val</span> of_array_dyn</span> : <code class="type">'a <a href="Slap.Size.html#TYPEt">Slap.Size.t</a> -><br>       'b <a href="Slap.Size.html#TYPEt">Slap.Size.t</a> -> <a href="Slap.Z.html#TYPEnum_type">Slap.Z.num_type</a> array array -> ('a, 'b, 'c) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a></code></pre><div class="info">
Build a matrix initialized from the given array of arrays.<br>
<b>Raises</b> <code>Invalid_argument</code> the given array of arrays is not rectangular or
    its size is not <code class="code">m</code>-by-<code class="code">n</code>.<br>
</div>
<pre><span id="VALof_array"><span class="keyword">val</span> of_array</span> : <code class="type"><a href="Slap.Z.html#TYPEnum_type">Slap.Z.num_type</a> array array -> (module Slap.Z.Mat.CNTMAT)</code></pre><div class="info">
<code class="code">module M = (val of_array aa : CNTMAT)</code><br>
<b>Raises</b> <code>Invalid_argument</code> the given array of arrays is not rectangular.<br>
<b>Returns</b> module <code class="code">M</code> containing the matrix <code class="code">M.value</code> that
    has the type <code class="code">(M.m, M.n, 'cnt) mat</code> with a generative phantom types <code class="code">M.m</code>
    and <code class="code">M.n</code> as a package of an existential quantified sized type like
    <code class="code">exists m, n. (m, n, 'cnt) mat</code>.<br>
</div>
<pre><span class="keyword">module</span> <a href="Slap.Z.Mat.Of_array.html">Of_array</a>: <div class="sig_block"><code class="code">functor (</code><code class="code">X</code><code class="code"> : </code><code class="code">sig</code><div class="sig_block"><pre><span id="VALvalue"><span class="keyword">val</span> value</span> : <code class="type"><a href="Slap.Z.html#TYPEnum_type">Slap.Z.num_type</a> array array</code></pre></div><code class="code">end</code><code class="code">) -&gt; </code><code class="type"><a href="Slap.Z.Mat.CNTMAT.html">CNTMAT</a></code><code class="type"> </code></div></pre><div class="info">
A functor vesion of <code class="code">of_array</code>.
</div>
<pre><span id="VALto_list"><span class="keyword">val</span> to_list</span> : <code class="type">('a, 'b, 'c) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -> <a href="Slap.Z.html#TYPEnum_type">Slap.Z.num_type</a> list list</code></pre><div class="info">
<code class="code">to_list a</code><br>
<b>Returns</b> the list of lists of all the elements of <code class="code">a</code>.<br>
</div>
<pre><span id="VALof_list_dyn"><span class="keyword">val</span> of_list_dyn</span> : <code class="type">'a <a href="Slap.Size.html#TYPEt">Slap.Size.t</a> -><br>       'b <a href="Slap.Size.html#TYPEt">Slap.Size.t</a> -> <a href="Slap.Z.html#TYPEnum_type">Slap.Z.num_type</a> list list -> ('a, 'b, 'c) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a></code></pre><div class="info">
Build a matrix initialized from the given list of lists.<br>
<b>Raises</b> <code>Invalid_argument</code> the given list of lists is not rectangular or
    its size is not <code class="code">m</code>-by-<code class="code">n</code>.<br>
</div>
<pre><span id="VALof_list"><span class="keyword">val</span> of_list</span> : <code class="type"><a href="Slap.Z.html#TYPEnum_type">Slap.Z.num_type</a> list list -> (module Slap.Z.Mat.CNTMAT)</code></pre><div class="info">
<code class="code">module M = (val of_list ll : CNTMAT)</code><br>
<b>Raises</b> <code>Invalid_argument</code> the given list of lists is not rectangular.<br>
<b>Returns</b> module <code class="code">M</code> containing the matrix <code class="code">M.value</code> that
    has the type <code class="code">(M.m, M.n, 'cnt) mat</code> with a generative phantom types <code class="code">M.m</code>
    and <code class="code">M.n</code> as a package of an existential quantified sized type like
    <code class="code">exists m, n. (m, n, 'cnt) mat</code>.<br>
</div>
<pre><span class="keyword">module</span> <a href="Slap.Z.Mat.Of_list.html">Of_list</a>: <div class="sig_block"><code class="code">functor (</code><code class="code">X</code><code class="code"> : </code><code class="code">sig</code><div class="sig_block"><pre><span id="VALvalue"><span class="keyword">val</span> value</span> : <code class="type"><a href="Slap.Z.html#TYPEnum_type">Slap.Z.num_type</a> list list</code></pre></div><code class="code">end</code><code class="code">) -&gt; </code><code class="type"><a href="Slap.Z.Mat.CNTMAT.html">CNTMAT</a></code><code class="type"> </code></div></pre><div class="info">
A functor vesion of <code class="code">of_list</code>.
</div>
<br>
<span id="2_Iterators"><h2>Iterators</h2></span><br>
<pre><span id="VALmap"><span class="keyword">val</span> map</span> : <code class="type">(<a href="Slap.Z.html#TYPEnum_type">Slap.Z.num_type</a> -> <a href="Slap.Z.html#TYPEnum_type">Slap.Z.num_type</a>) -><br>       ?b:('a, 'b, 'c) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -><br>       ('a, 'b, 'd) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -> ('a, 'b, 'c) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a></code></pre><pre><span id="VALmapi"><span class="keyword">val</span> mapi</span> : <code class="type">(int -> int -> <a href="Slap.Z.html#TYPEnum_type">Slap.Z.num_type</a> -> <a href="Slap.Z.html#TYPEnum_type">Slap.Z.num_type</a>) -><br>       ?b:('a, 'b, 'c) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -><br>       ('a, 'b, 'd) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -> ('a, 'b, 'c) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a></code></pre><pre><span id="VALfold_left"><span class="keyword">val</span> fold_left</span> : <code class="type">('a -> ('b, 'c) <a href="Slap.Z.html#TYPEvec">Slap.Z.vec</a> -> 'a) -> 'a -> ('b, 'd, 'e) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -> 'a</code></pre><div class="info">
<code class="code">fold_left f init a</code> folds column vectors of matrix <code class="code">a</code> by <code class="code">f</code> in the order
    left to right.<br>
</div>
<pre><span id="VALfold_lefti"><span class="keyword">val</span> fold_lefti</span> : <code class="type">(int -> 'a -> ('b, 'c) <a href="Slap.Z.html#TYPEvec">Slap.Z.vec</a> -> 'a) -><br>       'a -> ('b, 'd, 'e) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -> 'a</code></pre><div class="info">
<code class="code">fold_lefti f init a</code> folds column vectors of matrix <code class="code">a</code> by <code class="code">f</code> in the order
    left to right.<br>
</div>
<pre><span id="VALfold_right"><span class="keyword">val</span> fold_right</span> : <code class="type">(('a, 'b) <a href="Slap.Z.html#TYPEvec">Slap.Z.vec</a> -> 'c -> 'c) -> ('a, 'd, 'e) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -> 'c -> 'c</code></pre><div class="info">
<code class="code">fold_right f a init</code> folds column vectors of matrix <code class="code">a</code> by <code class="code">f</code> in the
    order right to left.<br>
</div>
<pre><span id="VALfold_righti"><span class="keyword">val</span> fold_righti</span> : <code class="type">(int -> ('a, 'b) <a href="Slap.Z.html#TYPEvec">Slap.Z.vec</a> -> 'c -> 'c) -><br>       ('a, 'd, 'e) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -> 'c -> 'c</code></pre><div class="info">
<code class="code">fold_righti f a init</code> folds column vectors of matrix <code class="code">a</code> by <code class="code">f</code> in the
    order right to left.<br>
</div>
<pre><span id="VALfold_top"><span class="keyword">val</span> fold_top</span> : <code class="type">('a -> ('b, <a href="Slap.html#TYPEdsc">Slap.dsc</a>) <a href="Slap.Z.html#TYPEvec">Slap.Z.vec</a> -> 'a) -><br>       'a -> ('c, 'b, 'd) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -> 'a</code></pre><div class="info">
<code class="code">fold_top f init a</code> folds row vectors of matrix <code class="code">a</code> by <code class="code">f</code> in the order
    top to bottom.<br>
</div>
<pre><span id="VALfold_topi"><span class="keyword">val</span> fold_topi</span> : <code class="type">(int -> 'a -> ('b, <a href="Slap.html#TYPEdsc">Slap.dsc</a>) <a href="Slap.Z.html#TYPEvec">Slap.Z.vec</a> -> 'a) -><br>       'a -> ('c, 'b, 'd) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -> 'a</code></pre><div class="info">
<code class="code">fold_topi f init a</code> folds row vectors of matrix <code class="code">a</code> by <code class="code">f</code> in the order
    top to bottom.<br>
</div>
<pre><span id="VALfold_bottom"><span class="keyword">val</span> fold_bottom</span> : <code class="type">(('a, <a href="Slap.html#TYPEdsc">Slap.dsc</a>) <a href="Slap.Z.html#TYPEvec">Slap.Z.vec</a> -> 'b -> 'b) -><br>       ('a, 'c, 'd) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -> 'b -> 'b</code></pre><div class="info">
<code class="code">fold_bottom f a init</code> folds row vectors of matrix <code class="code">a</code> by <code class="code">f</code> in the
    order bottom to top.<br>
</div>
<pre><span id="VALfold_bottomi"><span class="keyword">val</span> fold_bottomi</span> : <code class="type">(int -> ('a, <a href="Slap.html#TYPEdsc">Slap.dsc</a>) <a href="Slap.Z.html#TYPEvec">Slap.Z.vec</a> -> 'b -> 'b) -><br>       ('a, 'c, 'd) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -> 'b -> 'b</code></pre><div class="info">
<code class="code">fold_bottomi f a init</code> folds row vectors of matrix <code class="code">a</code> by <code class="code">f</code> in the
    order bottom to top.<br>
</div>
<pre><span id="VALreplace_all"><span class="keyword">val</span> replace_all</span> : <code class="type">('a, 'b, 'c) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -> (<a href="Slap.Z.html#TYPEnum_type">Slap.Z.num_type</a> -> <a href="Slap.Z.html#TYPEnum_type">Slap.Z.num_type</a>) -> unit</code></pre><div class="info">
<code class="code">replace_all a f</code> modifies the matrix <code class="code">a</code> in place
    -- the <code class="code">(i,j)</code>-element <code class="code">aij</code> of <code class="code">a</code> will be set to <code class="code">f aij</code>.<br>
</div>
<pre><span id="VALreplace_alli"><span class="keyword">val</span> replace_alli</span> : <code class="type">('a, 'b, 'c) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -><br>       (int -> int -> <a href="Slap.Z.html#TYPEnum_type">Slap.Z.num_type</a> -> <a href="Slap.Z.html#TYPEnum_type">Slap.Z.num_type</a>) -> unit</code></pre><div class="info">
<code class="code">replace_all a f</code> modifies the matrix <code class="code">a</code> in place
    -- the <code class="code">(i,j)</code>-element <code class="code">aij</code> of <code class="code">a</code> will be set to <code class="code">f i j aij</code>.<br>
</div>
<br>
<span id="2_Matrixtransformations"><h2>Matrix transformations</h2></span><br>
<pre><span id="VALtranspose_copy"><span class="keyword">val</span> transpose_copy</span> : <code class="type">('a, 'b, 'c) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -> ('b, 'a, 'd) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -> unit</code></pre><div class="info">
<code class="code">transpose_copy a b</code> copies the transpose of <code class="code">a</code> into <code class="code">b</code>.<br>
<b>Since</b> 0.1.0<br>
</div>
<pre><span id="VALtranspose"><span class="keyword">val</span> transpose</span> : <code class="type">('a, 'b, 'c) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -> ('b, 'a, 'd) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a></code></pre><div class="info">
<code class="code">transpose a</code> returns the transpose of <code class="code">a</code>.<br>
<b>Since</b> 0.1.0<br>
</div>
<pre><span id="VALdetri"><span class="keyword">val</span> detri</span> : <code class="type">?up:bool -> ('a, 'a, 'b) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -> unit</code></pre><div class="info">
<code class="code">detri ?up a</code> converts triangular matrix <code class="code">a</code> to a symmetric matrix, i.e.,
    copies the upper or lower triangular part of <code class="code">a</code> into another part.<br>
<b>Since</b> 0.1.0<br>
</div>
<div class="param_info"><code class="code">up</code> : default = <code class="code">true</code></div>
<pre><span id="VALpacked"><span class="keyword">val</span> packed</span> : <code class="type">?up:bool -><br>       ?x:('a <a href="Slap.Size.html#TYPEpacked">Slap.Size.packed</a>, <a href="Slap.html#TYPEcnt">Slap.cnt</a>) <a href="Slap.Z.html#TYPEvec">Slap.Z.vec</a> -><br>       ('a, 'a, 'b) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -> ('a <a href="Slap.Size.html#TYPEpacked">Slap.Size.packed</a>, 'c) <a href="Slap.Z.html#TYPEvec">Slap.Z.vec</a></code></pre><div class="info">
<code class="code">packed ?up ?x a</code> transforms matrix <code class="code">a</code> into packed storage format.<br>
<b>Since</b> 0.2.0<br>
<b>Returns</b> vector <code class="code">x</code>, which is overwritten.<br>
</div>
<div class="param_info"><code class="code">up</code> : default = <code class="code">true</code><ul>
<li>If <code class="code">up</code> = <code class="code">true</code>, then the upper triangular part of <code class="code">a</code> is packed;</li>
<li>If <code class="code">up</code> = <code class="code">false</code>, then the lower triangular part of <code class="code">a</code> is packed.</li>
</ul>
</div>
<pre><span id="VALunpacked"><span class="keyword">val</span> unpacked</span> : <code class="type">?up:bool -><br>       ?fill_num:<a href="Slap.Z.html#TYPEnum_type">Slap.Z.num_type</a> option -><br>       ?a:('a, 'a, 'b) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -><br>       ('a <a href="Slap.Size.html#TYPEpacked">Slap.Size.packed</a>, <a href="Slap.html#TYPEcnt">Slap.cnt</a>) <a href="Slap.Z.html#TYPEvec">Slap.Z.vec</a> -> ('a, 'a, 'b) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a></code></pre><div class="info">
<code class="code">unpacked ?up ?fill_num ?a x</code> generates an upper or lower triangular matrix
    from packed-storage-format vector <code class="code">x</code>.<br>
<b>Since</b> 0.2.0<br>
<b>Returns</b> matrix <code class="code">a</code>, which is overwritten.<br>
</div>
<div class="param_info"><code class="code">up</code> : default = <code class="code">true</code><ul>
<li>If <code class="code">up</code> = <code class="code">true</code>, then the upper triangular matrix is generated;</li>
<li>If <code class="code">up</code> = <code class="code">false</code>, then the lower triangular matrix is generated.</li>
</ul>
</div>
<div class="param_info"><code class="code">fill_num</code> : default = <code class="code">Some 0</code><ul>
<li>If <code class="code">fill_num</code> is <code class="code">None</code>, the elements in the generated matrix are not
        initialized;</li>
<li>If <code class="code">fill_num</code> is <code class="code">Some c</code>, the elements in the generated matrix are
        initialized by <code class="code">c</code>.</li>
</ul>
</div>
<pre><span id="VALgeband_dyn"><span class="keyword">val</span> geband_dyn</span> : <code class="type">'a <a href="Slap.Size.html#TYPEt">Slap.Size.t</a> -><br>       'b <a href="Slap.Size.html#TYPEt">Slap.Size.t</a> -><br>       ?b:(('c, 'd, 'a, 'b) <a href="Slap.Size.html#TYPEgeband">Slap.Size.geband</a>, 'd, 'e) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -><br>       ('c, 'd, 'f) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -><br>       (('c, 'd, 'a, 'b) <a href="Slap.Size.html#TYPEgeband">Slap.Size.geband</a>, 'd, 'e) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a></code></pre><div class="info">
<code class="code">geband_dyn kl ku ?b a</code> converts matrix <code class="code">a</code> into a matrix stored in band
    storage.<br>
<b>Since</b> 0.2.0<br>
<b>Raises</b> <code>Invalid_arg</code> if <code class="code">kl &gt;= dim1 a</code> or <code class="code">ku &gt;= dim2 a</code>.<br>
<b>Returns</b> matrix <code class="code">b</code>, which is overwritten.<br>
</div>
<pre><span id="VALungeband"><span class="keyword">val</span> ungeband</span> : <code class="type">'a <a href="Slap.Size.html#TYPEt">Slap.Size.t</a> -><br>       'b <a href="Slap.Size.html#TYPEt">Slap.Size.t</a> -><br>       'c <a href="Slap.Size.html#TYPEt">Slap.Size.t</a> -><br>       ?fill_num:<a href="Slap.Z.html#TYPEnum_type">Slap.Z.num_type</a> option -><br>       ?a:('a, 'd, 'e) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -><br>       (('a, 'd, 'b, 'c) <a href="Slap.Size.html#TYPEgeband">Slap.Size.geband</a>, 'd, 'f) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -><br>       ('a, 'd, 'e) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a></code></pre><div class="info">
<code class="code">ungeband m kl ku ?a b</code> converts matrix <code class="code">b</code> stored in band storage into
    a matrix stored in the normal order.<br>
<b>Since</b> 0.2.0<br>
<b>Returns</b> matrix <code class="code">a</code>, which is overwritten.<br>
</div>
<div class="param_info"><code class="code">fill_num</code> : default = <code class="code">Some 0</code><ul>
<li>If <code class="code">fill_num</code> = <code class="code">None</code>, the elements in the generated matrix are not
        initialized;</li>
<li>If <code class="code">fill_num</code> = <code class="code">Some c</code>, the elements in the generated matrix are
        initialized by <code class="code">c</code>.</li>
</ul>
</div>
<pre><span id="VALsyband_dyn"><span class="keyword">val</span> syband_dyn</span> : <code class="type">'a <a href="Slap.Size.html#TYPEt">Slap.Size.t</a> -><br>       ?up:bool -><br>       ?b:(('b, 'a) <a href="Slap.Size.html#TYPEsyband">Slap.Size.syband</a>, 'b, 'c) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -><br>       ('b, 'b, 'd) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -> (('b, 'a) <a href="Slap.Size.html#TYPEsyband">Slap.Size.syband</a>, 'b, 'c) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a></code></pre><div class="info">
<code class="code">syband_dyn kd ?b a</code> converts matrix <code class="code">a</code> into a matrix stored in
    symmetric or Hermitian band storage.<br>
<b>Since</b> 0.2.0<br>
<b>Raises</b> <code>Invalid_arg</code> if <code class="code">kd &gt;= dim1 a</code>.<br>
<b>Returns</b> matrix <code class="code">b</code>, which is overwritten.<br>
</div>
<div class="param_info"><code class="code">up</code> : default = <code class="code">true</code><ul>
<li>If <code class="code">up</code> = <code class="code">true</code>, then the upper triangular part of <code class="code">a</code> is used;</li>
<li>If <code class="code">up</code> = <code class="code">false</code>, then the lower triangular part of <code class="code">a</code> is used.</li>
</ul>
</div>
<pre><span id="VALunsyband"><span class="keyword">val</span> unsyband</span> : <code class="type">'a <a href="Slap.Size.html#TYPEt">Slap.Size.t</a> -><br>       ?up:bool -><br>       ?fill_num:<a href="Slap.Z.html#TYPEnum_type">Slap.Z.num_type</a> option -><br>       ?a:('b, 'b, 'c) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -><br>       (('b, 'a) <a href="Slap.Size.html#TYPEsyband">Slap.Size.syband</a>, 'b, 'd) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -> ('b, 'b, 'c) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a></code></pre><div class="info">
<code class="code">unsyband kd ?a b</code> converts matrix <code class="code">b</code> stored in symmetric or Hermitian
    band storage into a matrix stored in the normal order.<br>
<b>Since</b> 0.2.0<br>
<b>Returns</b> matrix <code class="code">a</code>, which is overwritten.<br>
</div>
<div class="param_info"><code class="code">up</code> : default = <code class="code">true</code><ul>
<li>If <code class="code">up</code> = <code class="code">true</code>, then <code class="code">b</code> is treated as the upper triangular part of
        symmetric or Hermitian matrix <code class="code">a</code>;</li>
<li>If <code class="code">up</code> = <code class="code">false</code>, then <code class="code">b</code> is treated as the lower triangular part of
        symmetric or Hermitian matrix <code class="code">a</code>;</li>
</ul>
</div>
<div class="param_info"><code class="code">fill_num</code> : default = <code class="code">Some 0</code><ul>
<li>If <code class="code">fill_num</code> = <code class="code">None</code>, the elements in the generated matrix are not
        initialized;</li>
<li>If <code class="code">fill_num</code> = <code class="code">Some c</code>, the elements in the generated matrix are
        initialized by <code class="code">c</code>.</li>
</ul>
</div>
<pre><span id="VALluband_dyn"><span class="keyword">val</span> luband_dyn</span> : <code class="type">'a <a href="Slap.Size.html#TYPEt">Slap.Size.t</a> -><br>       'b <a href="Slap.Size.html#TYPEt">Slap.Size.t</a> -><br>       ?ab:(('c, 'd, 'a, 'b) <a href="Slap.Size.html#TYPEluband">Slap.Size.luband</a>, 'd, 'e) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -><br>       ('c, 'd, 'f) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -><br>       (('c, 'd, 'a, 'b) <a href="Slap.Size.html#TYPEluband">Slap.Size.luband</a>, 'd, 'e) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a></code></pre><div class="info">
<code class="code">luband_dyn kl ku ?ab a</code> converts matrix <code class="code">a</code> into a matrix stored in band
    storage for LU factorization.<br>
<b>Since</b> 0.2.0<br>
<b>Raises</b> <code>Invalid_arg</code> if <code class="code">kl &gt;= dim1 a</code> or <code class="code">ku &gt;= dim2 a</code>.<br>
<b>Returns</b> matrix <code class="code">ab</code>, which is overwritten.<br>
</div>
<pre><span id="VALunluband"><span class="keyword">val</span> unluband</span> : <code class="type">'a <a href="Slap.Size.html#TYPEt">Slap.Size.t</a> -><br>       'b <a href="Slap.Size.html#TYPEt">Slap.Size.t</a> -><br>       'c <a href="Slap.Size.html#TYPEt">Slap.Size.t</a> -><br>       ?fill_num:<a href="Slap.Z.html#TYPEnum_type">Slap.Z.num_type</a> option -><br>       ?a:('a, 'd, 'e) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -><br>       (('a, 'd, 'b, 'c) <a href="Slap.Size.html#TYPEluband">Slap.Size.luband</a>, 'd, 'f) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -><br>       ('a, 'd, 'e) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a></code></pre><div class="info">
<code class="code">unluband m kl ku ?a ab</code> converts matrix <code class="code">ab</code> stored in band storage for LU
    factorization into a matrix stored in the normal order.<br>
<b>Since</b> 0.2.0<br>
<b>Returns</b> matrix <code class="code">a</code>, which is overwritten.<br>
</div>
<div class="param_info"><code class="code">fill_num</code> : default = <code class="code">Some 0</code><ul>
<li>If <code class="code">fill_num</code> = <code class="code">None</code>, the elements in the generated matrix are not
        initialized;</li>
<li>If <code class="code">fill_num</code> = <code class="code">Some c</code>, the elements in the generated matrix are
        initialized by <code class="code">c</code>.</li>
</ul>
</div>
<br>
<span id="2_Arithmeticoperations"><h2>Arithmetic operations</h2></span><br>
<pre><span id="VALadd_const"><span class="keyword">val</span> add_const</span> : <code class="type"><a href="Slap.Z.html#TYPEnum_type">Slap.Z.num_type</a> -><br>       ?b:('a, 'b, 'c) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -><br>       ('a, 'b, 'd) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -> ('a, 'b, 'c) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a></code></pre><div class="info">
<code class="code">add_const c ?b a</code> adds constant value <code class="code">c</code> to all elements in <code class="code">a</code>.<br>
<b>Since</b> 0.1.0<br>
<b>Returns</b> the matrix <code class="code">b</code>, which is overwritten.<br>
</div>
<pre><span id="VALsum"><span class="keyword">val</span> sum</span> : <code class="type">('a, 'b, 'c) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -> <a href="Slap.Z.html#TYPEnum_type">Slap.Z.num_type</a></code></pre><div class="info">
<code class="code">sum a</code> returns the sum of all elements in <code class="code">a</code>.<br>
<b>Since</b> 0.1.0<br>
</div>
<pre><span id="VALtrace"><span class="keyword">val</span> trace</span> : <code class="type">('a, 'b, 'c) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -> <a href="Slap.Z.html#TYPEnum_type">Slap.Z.num_type</a></code></pre><div class="info">
<code class="code">trace a</code><br>
<b>Returns</b> the sum of diagonal elements of the matrix <code class="code">a</code>.<br>
</div>
<pre><span id="VALscal"><span class="keyword">val</span> scal</span> : <code class="type"><a href="Slap.Z.html#TYPEnum_type">Slap.Z.num_type</a> -> ('a, 'b, 'c) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -> unit</code></pre><div class="info">
<code class="code">scal alpha a</code> computes <code class="code">a := alpha * a</code> with the scalar value <code class="code">alpha</code> and
    the matrix <code class="code">a</code>.<br>
</div>
<pre><span id="VALscal_cols"><span class="keyword">val</span> scal_cols</span> : <code class="type">('a, 'b, 'c) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -> ('b, <a href="Slap.html#TYPEcnt">Slap.cnt</a>) <a href="Slap.Z.html#TYPEvec">Slap.Z.vec</a> -> unit</code></pre><div class="info">
A column-wise <code class="code">scal</code> function for matrices.<br>
</div>
<pre><span id="VALscal_rows"><span class="keyword">val</span> scal_rows</span> : <code class="type">('a, <a href="Slap.html#TYPEcnt">Slap.cnt</a>) <a href="Slap.Z.html#TYPEvec">Slap.Z.vec</a> -> ('a, 'b, 'c) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -> unit</code></pre><div class="info">
A row-wise <code class="code">scal</code> function for matrices.<br>
</div>
<pre><span id="VALaxpy"><span class="keyword">val</span> axpy</span> : <code class="type">?alpha:<a href="Slap.Z.html#TYPEnum_type">Slap.Z.num_type</a> -><br>       x:('a, 'b, 'c) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -> ('a, 'b, 'd) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -> unit</code></pre><div class="info">
<code class="code">axpy ?alpha ~x y</code> computes <code class="code">y := alpha * x + y</code>.<br>
</div>
<pre><span id="VALgemm_diag"><span class="keyword">val</span> gemm_diag</span> : <code class="type">?beta:<a href="Slap.Z.html#TYPEnum_type">Slap.Z.num_type</a> -><br>       ?y:('a, <a href="Slap.html#TYPEcnt">Slap.cnt</a>) <a href="Slap.Z.html#TYPEvec">Slap.Z.vec</a> -><br>       transa:(('b, 'c, 'd) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -> ('a, 'e, 'd) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a>) <a href="Slap.Z.html#TYPEtrans3">Slap.Z.trans3</a> -><br>       ?alpha:<a href="Slap.Z.html#TYPEnum_type">Slap.Z.num_type</a> -><br>       ('b, 'c, 'd) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -><br>       transb:(('f, 'g, 'h) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -> ('e, 'a, 'h) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a>) <a href="Slap.Z.html#TYPEtrans3">Slap.Z.trans3</a> -><br>       ('f, 'g, 'h) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -> ('a, 'i) <a href="Slap.Z.html#TYPEvec">Slap.Z.vec</a></code></pre><div class="info">
<code class="code">gemm_diag ?beta ?y ~transa ?alpha a ~transb b</code> executes
    <code class="code">y := DIAG(alpha * OP(a) * OP(b)) + beta * y</code> where
    <code class="code">DIAG(x)</code> is the vector of the diagonal elements in matrix <code class="code">x</code>, and
    <code class="code">OP(x)</code> is one of <code class="code">OP(x)</code> = <code class="code">x</code>, <code class="code">OP(x)</code> = <code class="code">x^T</code>, or <code class="code">OP(x)</code> = <code class="code">x^H</code>
    (the conjugate transpose of <code class="code">x</code>).<br>
<b>Since</b> 0.1.0<br>
<b>Returns</b> the vector <code class="code">y</code>, which is overwritten.<br>
</div>
<div class="param_info"><code class="code">beta</code> : default = <code class="code">0.0</code></div>
<div class="param_info"><code class="code">transa</code> : the transpose flag for <code class="code">a</code>:<ul>
<li>if <a href="Slap.Common.html#VALnormal"><code class="code">Slap.Common.normal</code></a>, then <code class="code">OP(a)</code> = <code class="code">a</code>;</li>
<li>if <a href="Slap.Common.html#VALtrans"><code class="code">Slap.Common.trans</code></a>, then <code class="code">OP(a)</code> = <code class="code">a^T</code>;</li>
<li>if <a href="Slap.Common.html#VALconjtr"><code class="code">Slap.Common.conjtr</code></a>, then <code class="code">OP(a)</code> = <code class="code">a^H</code>.</li>
</ul>
</div>
<div class="param_info"><code class="code">alpha</code> : default = <code class="code">1.0</code></div>
<div class="param_info"><code class="code">transb</code> : the transpose flag for <code class="code">b</code>:<ul>
<li>if <a href="Slap.Common.html#VALnormal"><code class="code">Slap.Common.normal</code></a>, then <code class="code">OP(b)</code> = <code class="code">b</code>;</li>
<li>if <a href="Slap.Common.html#VALtrans"><code class="code">Slap.Common.trans</code></a>, then <code class="code">OP(b)</code> = <code class="code">b^T</code>;</li>
<li>if <a href="Slap.Common.html#VALconjtr"><code class="code">Slap.Common.conjtr</code></a>, then <code class="code">OP(b)</code> = <code class="code">b^H</code>.</li>
</ul>
</div>
<pre><span id="VALsyrk_diag"><span class="keyword">val</span> syrk_diag</span> : <code class="type">?beta:<a href="Slap.Z.html#TYPEnum_type">Slap.Z.num_type</a> -><br>       ?y:('a, <a href="Slap.html#TYPEcnt">Slap.cnt</a>) <a href="Slap.Z.html#TYPEvec">Slap.Z.vec</a> -><br>       trans:(('b, 'c, 'd) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -> ('a, 'e, 'd) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a>) <a href="Slap.Common.html#TYPEtrans2">Slap.Common.trans2</a> -><br>       ?alpha:<a href="Slap.Z.html#TYPEnum_type">Slap.Z.num_type</a> -> ('b, 'c, 'd) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -> ('a, 'f) <a href="Slap.Z.html#TYPEvec">Slap.Z.vec</a></code></pre><div class="info">
<code class="code">syrk_diag ?beta ?y ~transa ?alpha a</code> executes
<p>
<ul>
<li><code class="code">y := alpha * DIAG(a * a^T) + beta * y</code>
      (if <code class="code">trans</code> = <a href="Slap.Common.html#VALnormal"><code class="code">Slap.Common.normal</code></a>) or</li>
<li><code class="code">y := alpha * DIAG(a^T * a) + beta * y</code>
      (if <code class="code">trans</code> = <a href="Slap.Common.html#VALtrans"><code class="code">Slap.Common.trans</code></a>)</li>
</ul>

    where <code class="code">DIAG(x)</code> is the vector of the diagonal elements in matrix <code class="code">x</code>.<br>
<b>Returns</b> the vector <code class="code">y</code>, which is overwritten.<br>
</div>
<div class="param_info"><code class="code">beta</code> : default = <code class="code">0.0</code></div>
<div class="param_info"><code class="code">alpha</code> : default = <code class="code">1.0</code></div>
<pre><span id="VALgemm_trace"><span class="keyword">val</span> gemm_trace</span> : <code class="type">transa:(('a, 'b, 'c) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -> ('d, 'e, 'c) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a>) <a href="Slap.Z.html#TYPEtrans3">Slap.Z.trans3</a> -><br>       ('a, 'b, 'c) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -><br>       transb:(('f, 'g, 'h) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -> ('e, 'd, 'h) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a>) <a href="Slap.Z.html#TYPEtrans3">Slap.Z.trans3</a> -><br>       ('f, 'g, 'h) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -> <a href="Slap.Z.html#TYPEnum_type">Slap.Z.num_type</a></code></pre><div class="info">
<code class="code">gemm_trace ~transa a ~transb b</code><br>
<b>Returns</b> the trace of <code class="code">OP(a) * OP(b)</code>.<br>
</div>
<div class="param_info"><code class="code">transa</code> : the transpose flag for <code class="code">a</code>:<ul>
<li>if <a href="Slap.Common.html#VALnormal"><code class="code">Slap.Common.normal</code></a>, then <code class="code">OP(a)</code> = <code class="code">a</code>;</li>
<li>if <a href="Slap.Common.html#VALtrans"><code class="code">Slap.Common.trans</code></a>, then <code class="code">OP(a)</code> = <code class="code">a^T</code>;</li>
<li>if <a href="Slap.Common.html#VALconjtr"><code class="code">Slap.Common.conjtr</code></a>, then <code class="code">OP(a)</code> = <code class="code">a^H</code>.</li>
</ul>
</div>
<div class="param_info"><code class="code">transb</code> : the transpose flag for <code class="code">b</code>:<ul>
<li>if <a href="Slap.Common.html#VALnormal"><code class="code">Slap.Common.normal</code></a>, then <code class="code">OP(b)</code> = <code class="code">b</code>;</li>
<li>if <a href="Slap.Common.html#VALtrans"><code class="code">Slap.Common.trans</code></a>, then <code class="code">OP(b)</code> = <code class="code">b^T</code>;</li>
<li>if <a href="Slap.Common.html#VALconjtr"><code class="code">Slap.Common.conjtr</code></a>, then <code class="code">OP(b)</code> = <code class="code">b^H</code>.</li>
</ul>
</div>
<pre><span id="VALsyrk_trace"><span class="keyword">val</span> syrk_trace</span> : <code class="type">('a, 'b, 'c) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -> <a href="Slap.Z.html#TYPEnum_type">Slap.Z.num_type</a></code></pre><div class="info">
<code class="code">syrk_trace a</code> computes the trace of <code class="code">a * a^T</code> or <code class="code">a^T * a</code>.<br>
<b>Since</b> 0.1.0<br>
</div>
<pre><span id="VALsymm2_trace"><span class="keyword">val</span> symm2_trace</span> : <code class="type">?upa:bool -><br>       ('a, 'a, 'b) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -><br>       ?upb:bool -> ('a, 'a, 'c) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -> <a href="Slap.Z.html#TYPEnum_type">Slap.Z.num_type</a></code></pre><div class="info">
<code class="code">symm2_trace ?upa a ?upb b</code> computes the trace of <code class="code">a * b</code> with symmetric
    matrices <code class="code">a</code> and <code class="code">b</code>.<br>
</div>
<div class="param_info"><code class="code">upa</code> : default = <code class="code">true</code><ul>
<li>If <code class="code">upa</code> = <code class="code">true</code>, then the upper triangular part of <code class="code">a</code> is used;</li>
<li>If <code class="code">upa</code> = <code class="code">false</code>, then the lower triangular part of <code class="code">a</code> is used.</li>
</ul>
</div>
<div class="param_info"><code class="code">upb</code> : default = <code class="code">true</code><ul>
<li>If <code class="code">upb</code> = <code class="code">true</code>, then the upper triangular part of <code class="code">b</code> is used;</li>
<li>If <code class="code">upb</code> = <code class="code">false</code>, then the lower triangular part of <code class="code">b</code> is used.</li>
</ul>
</div>
<br>
<span id="2_Submatrices"><h2>Submatrices</h2></span><br>
<pre><span id="VALsubmat_dyn"><span class="keyword">val</span> submat_dyn</span> : <code class="type">'a <a href="Slap.Size.html#TYPEt">Slap.Size.t</a> -><br>       'b <a href="Slap.Size.html#TYPEt">Slap.Size.t</a> -><br>       ?ar:int -><br>       ?ac:int -> ('c, 'd, 'e) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a> -> ('a, 'b, <a href="Slap.html#TYPEdsc">Slap.dsc</a>) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a></code></pre><div class="info">
<code class="code">submat_dyn m n ?ar ?ac a</code><br>
<b>Returns</b> a <code class="code">m</code>-by-<code class="code">n</code> submatrix of the matrix <code class="code">a</code>.
    The <code class="code">(i,j)</code> element of the returned matrix refers the <code class="code">(ar+i-1,ac+j-1)</code>
    element of <code class="code">a</code>. The data are shared.<br>
</div>
<div class="param_info"><code class="code">ar</code> : default = 1</div>
<div class="param_info"><code class="code">ac</code> : default = 1</div>
<br>
<span id="2_Creationofvectors"><h2>Creation of vectors</h2></span><br>
<pre><span id="VALrandom"><span class="keyword">val</span> random</span> : <code class="type">?rnd_state:Random.State.t -><br>       ?re_from:float -><br>       ?re_range:float -><br>       ?im_from:float -><br>       ?im_range:float -><br>       'a <a href="Slap.Size.html#TYPEt">Slap.Size.t</a> -> 'b <a href="Slap.Size.html#TYPEt">Slap.Size.t</a> -> ('a, 'b, 'c) <a href="Slap.Z.html#TYPEmat">Slap.Z.mat</a></code></pre><div class="info">
<code class="code">random ?rnd_state ?from ?range m n</code> creates a <code class="code">m</code>-by-<code class="code">n</code> matrix randomly
    initialized with the uniform distribution between <code class="code">re_from</code>/<code class="code">im_from</code> and
    <code class="code">re_from+re_range</code>/<code class="code">im_from+im_range</code> for real and imaginary parts,
    respectively.<br>
<b>Since</b> 0.2.0<br>
</div>
<div class="param_info"><code class="code">rnd_state</code> : default = <code class="code">Random.get_state ()</code>.</div>
<div class="param_info"><code class="code">re_from</code> : default = <code class="code">-1.0</code>.</div>
<div class="param_info"><code class="code">re_range</code> : default = <code class="code">2.0</code>.</div>
<div class="param_info"><code class="code">im_from</code> : default = <code class="code">-1.0</code>.</div>
<div class="param_info"><code class="code">im_range</code> : default = <code class="code">2.0</code>.</div>
</body></html>