<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="Slap_io.html">
<link rel="next" href="Slap_D.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Slap" rel="Chapter" href="Slap.html">
<link title="Slap_misc" rel="Chapter" href="Slap_misc.html">
<link title="Slap_common" rel="Chapter" href="Slap_common.html">
<link title="Slap_size" rel="Chapter" href="Slap_size.html">
<link title="Slap_vec" rel="Chapter" href="Slap_vec.html">
<link title="Slap_mat" rel="Chapter" href="Slap_mat.html">
<link title="Slap_io" rel="Chapter" href="Slap_io.html">
<link title="Slap_S" rel="Chapter" href="Slap_S.html">
<link title="Slap_D" rel="Chapter" href="Slap_D.html">
<link title="Slap_C" rel="Chapter" href="Slap_C.html">
<link title="Slap_Z" rel="Chapter" href="Slap_Z.html">
<link title="Slap_version" rel="Chapter" href="Slap_version.html"><link title="BLAS interface" rel="Section" href="#2_BLASinterface">
<link title="BLAS interface" rel="Section" href="#2_BLASinterface">
<link title="LAPACK interface" rel="Section" href="#2_LAPACKinterface">
<link title="LAPACK interface" rel="Section" href="#2_LAPACKinterface">
<link title="BLAS interface" rel="Section" href="#2_BLASinterface">
<link title="BLAS interface" rel="Section" href="#2_BLASinterface">
<link title="LAPACK interface" rel="Section" href="#2_LAPACKinterface">
<link title="LAPACK interface" rel="Section" href="#2_LAPACKinterface">
<link title="LAPACK interface" rel="Section" href="#2_LAPACKinterface">
<link title="Level 1" rel="Subsection" href="#3_Level1">
<link title="Level 2" rel="Subsection" href="#3_Level2">
<link title="Level 3" rel="Subsection" href="#3_Level3">
<link title="Auxiliary routines" rel="Subsection" href="#3_Auxiliaryroutines">
<link title="Linear equations (computational routines)" rel="Subsection" href="#3_Linearequationscomputationalroutines">
<link title="Linear equations (simple drivers)" rel="Subsection" href="#3_Linearequationssimpledrivers">
<link title="Least squares (simple drivers)" rel="Subsection" href="#3_Leastsquaressimpledrivers">
<link title="Level 1" rel="Subsection" href="#3_Level1">
<link title="Level 2" rel="Subsection" href="#3_Level2">
<link title="Auxiliary routines" rel="Subsection" href="#3_Auxiliaryroutines">
<link title="Auxiliary routines" rel="Subsection" href="#3_Auxiliaryroutines">
<link title="Linear equations (computational routines)" rel="Subsection" href="#3_Linearequationscomputationalroutines">
<link title="Linear equations (computational routines)" rel="Subsection" href="#3_Linearequationscomputationalroutines">
<link title="Least squares (expert drivers)" rel="Subsection" href="#3_Leastsquaresexpertdrivers">
<link title="Least squares (expert drivers)" rel="Subsection" href="#3_Leastsquaresexpertdrivers">
<link title="General SVD routines" rel="Subsection" href="#3_GeneralSVDroutines">
<link title="General SVD routines" rel="Subsection" href="#3_GeneralSVDroutines">
<link title="General eigenvalue problem (simple drivers)" rel="Subsection" href="#3_Generaleigenvalueproblemsimpledrivers">
<link title="General eigenvalue problem (simple drivers)" rel="Subsection" href="#3_Generaleigenvalueproblemsimpledrivers">
<link title="Symmetric-matrix eigenvalue and singular value problems
         (simple drivers)" rel="Subsection" href="#3_Symmetricmatrixeigenvalueandsingularvalueproblemssimpledrivers">
<link title="Symmetric-matrix eigenvalue and singular value problems
         (simple drivers)" rel="Subsection" href="#3_Symmetricmatrixeigenvalueandsingularvalueproblemssimpledrivers">
<link title="Symmetric-matrix eigenvalue and singular value problems
       (expert & RRR drivers)" rel="Subsection" href="#3_SymmetricmatrixeigenvalueandsingularvalueproblemsexpertRRRdrivers">
<link title="Symmetric-matrix eigenvalue and singular value problems
       (expert & RRR drivers)" rel="Subsection" href="#3_SymmetricmatrixeigenvalueandsingularvalueproblemsexpertRRRdrivers">
<title>Slap_S</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Slap_io.html" title="Slap_io">Previous</a>
&nbsp;<a class="up" href="index.html" title="Index">Up</a>
&nbsp;<a class="post" href="Slap_D.html" title="Slap_D">Next</a>
</div>
<h1>Module <a href="type_Slap_S.html">Slap_S</a></h1>

<pre><span class="keyword">module</span> Slap_S: <code class="code">sig</code> <a href="Slap_S.html">..</a> <code class="code">end</code></pre><div class="info module top">
<a href="Slap.S.html"><code class="code">Slap.S</code></a> provides 32-bit real BLAS and LAPACK functions.<br>
</div>
<hr width="100%">

<pre><span id="TYPEprec"><span class="keyword">type</span> <code class="type"></code>prec</span> = <code class="type">Bigarray.float32_elt</code> </pre>


<pre><span id="TYPEnum_type"><span class="keyword">type</span> <code class="type"></code>num_type</span> = <code class="type">float</code> </pre>


<pre><span id="TYPEtrans3"><span class="keyword">type</span> <code class="type">'a</code> trans3</span> = <code class="type">'a <a href="Slap_common.html#TYPEtrans2">Slap_common.trans2</a></code> </pre>
<div class="info ">
A type of transpose parameters (<a href="Slap_common.html#VALnormal"><code class="code">Slap_common.normal</code></a> and
    <a href="Slap_common.html#VALtrans"><code class="code">Slap_common.trans</code></a>).
    For complex matrices, <a href="Slap_common.html#VALconjtr"><code class="code">Slap_common.conjtr</code></a> is also offered, hence the name.<br>
</div>


<pre><span id="TYPEvec"><span class="keyword">type</span> <code class="type">('n, 'cnt_or_dsc)</code> vec</span> = <code class="type">('n, <a href="Slap_S.html#TYPEnum_type">num_type</a>, <a href="Slap_S.html#TYPEprec">prec</a>, 'cnt_or_dsc) <a href="Slap_vec.html#TYPEt">Slap_vec.t</a></code> </pre>
<div class="info ">
Vectors.<br>
</div>


<pre><span id="TYPEmat"><span class="keyword">type</span> <code class="type">('m, 'n, 'cnt_or_dsc)</code> mat</span> = <code class="type">('m, 'n, <a href="Slap_S.html#TYPEnum_type">num_type</a>, <a href="Slap_S.html#TYPEprec">prec</a>, 'cnt_or_dsc) <a href="Slap_mat.html#TYPEt">Slap_mat.t</a></code> </pre>
<div class="info ">
Matrices.<br>
</div>


<pre><span id="TYPErprec"><span class="keyword">type</span> <code class="type"></code>rprec</span> = <code class="type">Bigarray.float32_elt</code> </pre>


<pre><span id="TYPErvec"><span class="keyword">type</span> <code class="type">('n, 'cnt_or_dsc)</code> rvec</span> = <code class="type">('n, float, <a href="Slap_S.html#TYPErprec">rprec</a>, 'cnt_or_dsc) <a href="Slap_vec.html#TYPEt">Slap_vec.t</a></code> </pre>
<div class="info ">
Real vectors. (In <a href="Slap.S.html"><code class="code">Slap.S</code></a> and <a href="Slap.D.html"><code class="code">Slap.D</code></a>, <code class="code">rvec</code> is equal to <code class="code">vec</code>.)<br>
</div>


<pre><span id="VALprec"><span class="keyword">val</span> prec</span> : <code class="type">(<a href="Slap_S.html#TYPEnum_type">num_type</a>, <a href="Slap_S.html#TYPEprec">prec</a>) Bigarray.kind</code></pre>
<pre><span id="VALrprec"><span class="keyword">val</span> rprec</span> : <code class="type">(float, <a href="Slap_S.html#TYPErprec">rprec</a>) Bigarray.kind</code></pre>
<pre><span class="keyword">module</span> <a href="Slap_S.Vec.html">Vec</a>: <code class="code">sig</code> <a href="Slap_S.Vec.html">..</a> <code class="code">end</code></pre>
<pre><span class="keyword">module</span> <a href="Slap_S.Mat.html">Mat</a>: <code class="code">sig</code> <a href="Slap_S.Mat.html">..</a> <code class="code">end</code></pre>
<pre><span id="VALpp_num"><span class="keyword">val</span> pp_num</span> : <code class="type">Format.formatter -> <a href="Slap_S.html#TYPEnum_type">num_type</a> -> unit</code></pre><div class="info ">
A pretty-printer for elements in vectors and matrices.<br>
</div>

<pre><span id="VALpp_vec"><span class="keyword">val</span> pp_vec</span> : <code class="type">Format.formatter -> ('n, 'cnt_or_dsc) <a href="Slap_S.html#TYPEvec">vec</a> -> unit</code></pre><div class="info ">
A pretty-printer for column vectors.<br>
</div>

<pre><span id="VALpp_mat"><span class="keyword">val</span> pp_mat</span> : <code class="type">Format.formatter -> ('m, 'n, 'cnt_or_dsc) <a href="Slap_S.html#TYPEmat">mat</a> -> unit</code></pre><div class="info ">
A pretty-printer for matrices.<br>
</div>
<br>
<h2 id="2_BLASinterface">BLAS interface</h2><br>
<br>
<h2 id="2_BLASinterface">BLAS interface</h2><br>
<br>
<h3 id="3_Level1">Level 1</h3><br>

<pre><span id="VALswap"><span class="keyword">val</span> swap</span> : <code class="type">('n, 'x_cd) <a href="Slap_S.html#TYPEvec">vec</a> -> ('n, 'y_cd) <a href="Slap_S.html#TYPEvec">vec</a> -> unit</code></pre><div class="info ">
<code class="code">swap x y</code> swaps elements in <code class="code">x</code> and <code class="code">y</code>.<br>
</div>

<pre><span id="VALscal"><span class="keyword">val</span> scal</span> : <code class="type"><a href="Slap_S.html#TYPEnum_type">num_type</a> -> ('n, 'cd) <a href="Slap_S.html#TYPEvec">vec</a> -> unit</code></pre><div class="info ">
<code class="code">scal c x</code> multiplies all elements in <code class="code">x</code> by scalar value <code class="code">c</code>,
    and destructively assigns the result to <code class="code">x</code>.<br>
</div>

<pre><span id="VALcopy"><span class="keyword">val</span> copy</span> : <code class="type">?y:('n, 'y_cd) <a href="Slap_S.html#TYPEvec">vec</a> -> ('n, 'x_cd) <a href="Slap_S.html#TYPEvec">vec</a> -> ('n, 'y_cd) <a href="Slap_S.html#TYPEvec">vec</a></code></pre><div class="info ">
<code class="code">copy ?y x</code> copies <code class="code">x</code> into <code class="code">y</code>.<br>
<b>Returns</b> vector <code class="code">y</code>, which is overwritten.<br>
</div>

<pre><span id="VALnrm2"><span class="keyword">val</span> nrm2</span> : <code class="type">('n, 'cd) <a href="Slap_S.html#TYPEvec">vec</a> -> float</code></pre><div class="info ">
<code class="code">nrm2 x</code> retruns the L2 norm of vector <code class="code">x</code>: <code class="code">||x||</code>.<br>
</div>

<pre><span id="VALaxpy"><span class="keyword">val</span> axpy</span> : <code class="type">?alpha:<a href="Slap_S.html#TYPEnum_type">num_type</a> -><br>       ('n, 'x_cd) <a href="Slap_S.html#TYPEvec">vec</a> -> ('n, 'y_cd) <a href="Slap_S.html#TYPEvec">vec</a> -> unit</code></pre><div class="info ">
<code class="code">axpy ?alpha x y</code> executes <code class="code">y := alpha * x + y</code> with scalar value <code class="code">alpha</code>,
    and vectors <code class="code">x</code> and <code class="code">y</code>.<br>
</div>
<div class="param_info"><code class="code">alpha</code> : default = <code class="code">1.0</code></div>

<pre><span id="VALiamax"><span class="keyword">val</span> iamax</span> : <code class="type">('n, 'cd) <a href="Slap_S.html#TYPEvec">vec</a> -> int</code></pre><div class="info ">
<code class="code">iamax x</code> returns the index of the maximum value of all elements in <code class="code">x</code>.<br>
</div>

<pre><span id="VALamax"><span class="keyword">val</span> amax</span> : <code class="type">('n, 'cd) <a href="Slap_S.html#TYPEvec">vec</a> -> <a href="Slap_S.html#TYPEnum_type">num_type</a></code></pre><div class="info ">
<code class="code">amax x</code> finds the maximum value of all elements in <code class="code">x</code>.<br>
</div>
<br>
<h3 id="3_Level2">Level 2</h3><br>

<pre><span id="VALgemv"><span class="keyword">val</span> gemv</span> : <code class="type">?beta:<a href="Slap_S.html#TYPEnum_type">num_type</a> -><br>       ?y:('m, 'y_cd) <a href="Slap_S.html#TYPEvec">vec</a> -><br>       trans:(('a_m, 'a_n, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> ('m, 'n, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a>)<br>             <a href="Slap_S.html#TYPEtrans3">trans3</a> -><br>       ?alpha:<a href="Slap_S.html#TYPEnum_type">num_type</a> -><br>       ('a_m, 'a_n, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a> -><br>       ('n, 'x_cd) <a href="Slap_S.html#TYPEvec">vec</a> -> ('m, 'y_cd) <a href="Slap_S.html#TYPEvec">vec</a></code></pre><div class="info ">
<code class="code">gemv ?beta ?y ~trans ?alpha a x</code> executes
    <code class="code">y := alpha * OP(a) * x + beta * y</code>.<br>
</div>
<div class="param_info"><code class="code">beta</code> : default = <code class="code">0.0</code></div>
<div class="param_info"><code class="code">trans</code> : the transpose flag for <code class="code">a</code>:<ul>
<li>If <code class="code">trans</code> = <a href="Slap_common.html#VALnormal"><code class="code">Slap_common.normal</code></a>, then <code class="code">OP(a)</code> = <code class="code">a</code>;</li>
<li>If <code class="code">trans</code> = <a href="Slap_common.html#VALtrans"><code class="code">Slap_common.trans</code></a>, then <code class="code">OP(a)</code> = <code class="code">a^T</code>;</li>
<li>If <code class="code">trans</code> = <a href="Slap_common.html#VALconjtr"><code class="code">Slap_common.conjtr</code></a>, then <code class="code">OP(a)</code> = <code class="code">a^H</code>
      (the conjugate transpose of <code class="code">a</code>).</li>
</ul>
</div>
<div class="param_info"><code class="code">alpha</code> : default = <code class="code">1.0</code></div>

<pre><span id="VALgbmv"><span class="keyword">val</span> gbmv</span> : <code class="type">m:'a_m <a href="Slap_size.html#TYPEt">Slap_size.t</a> -><br>       ?beta:<a href="Slap_S.html#TYPEnum_type">num_type</a> -><br>       ?y:('m, 'y_cd) <a href="Slap_S.html#TYPEvec">vec</a> -><br>       trans:(('a_m, 'a_n, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> ('m, 'n, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a>)<br>             <a href="Slap_S.html#TYPEtrans3">trans3</a> -><br>       ?alpha:<a href="Slap_S.html#TYPEnum_type">num_type</a> -><br>       (('a_m, 'a_n, 'kl, 'ku) <a href="Slap_size.html#TYPEgeband">Slap_size.geband</a>, 'a_n, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a> -><br>       'kl <a href="Slap_size.html#TYPEt">Slap_size.t</a> -><br>       'ku <a href="Slap_size.html#TYPEt">Slap_size.t</a> -> ('n, 'x_cd) <a href="Slap_S.html#TYPEvec">vec</a> -> ('m, 'y_cd) <a href="Slap_S.html#TYPEvec">vec</a></code></pre><div class="info ">
<code class="code">gbmv ~m ?beta ?y ~trans ?alpha a kl ku x</code> computes
    <code class="code">y := alpha * OP(a) * x + beta * y</code> where <code class="code">a</code> is a band matrix stored in
    band storage.<br>
<b>Since</b> 0.2.0<br>
<b>Returns</b> vector <code class="code">y</code>, which is overwritten.<br>
</div>
<div class="param_info"><code class="code">beta</code> : default = <code class="code">0.0</code></div>
<div class="param_info"><code class="code">trans</code> : the transpose flag for <code class="code">a</code>:<ul>
<li>If <code class="code">trans</code> = <a href="Slap_common.html#VALnormal"><code class="code">Slap_common.normal</code></a>, then <code class="code">OP(a)</code> = <code class="code">a</code>;</li>
<li>If <code class="code">trans</code> = <a href="Slap_common.html#VALtrans"><code class="code">Slap_common.trans</code></a>, then <code class="code">OP(a)</code> = <code class="code">a^T</code>;</li>
<li>If <code class="code">trans</code> = <a href="Slap_common.html#VALconjtr"><code class="code">Slap_common.conjtr</code></a>, then <code class="code">OP(a)</code> = <code class="code">a^H</code>
      (the conjugate transpose of <code class="code">a</code>).</li>
</ul>
</div>
<div class="param_info"><code class="code">alpha</code> : default = <code class="code">1.0</code></div>

<pre><span id="VALsymv"><span class="keyword">val</span> symv</span> : <code class="type">?beta:<a href="Slap_S.html#TYPEnum_type">num_type</a> -><br>       ?y:('n, 'y_cd) <a href="Slap_S.html#TYPEvec">vec</a> -><br>       ?up:bool -><br>       ?alpha:<a href="Slap_S.html#TYPEnum_type">num_type</a> -><br>       ('n, 'n, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a> -><br>       ('n, 'x_cd) <a href="Slap_S.html#TYPEvec">vec</a> -> ('n, 'y_cd) <a href="Slap_S.html#TYPEvec">vec</a></code></pre><div class="info ">
<code class="code">symv ?beta ?y ?up ?alpha a x</code> executes
    <code class="code">y := alpha * a * x + beta * y</code>.<br>
</div>
<div class="param_info"><code class="code">beta</code> : default = <code class="code">0.0</code></div>
<div class="param_info"><code class="code">up</code> : default = <code class="code">true</code><ul>
<li>If <code class="code">up</code> = <code class="code">true</code>, then the upper triangular part of <code class="code">a</code> is used;</li>
<li>If <code class="code">up</code> = <code class="code">false</code>, then the lower triangular part of <code class="code">a</code> is used.</li>
</ul>
</div>
<div class="param_info"><code class="code">alpha</code> : default = <code class="code">1.0</code></div>

<pre><span id="VALtrmv"><span class="keyword">val</span> trmv</span> : <code class="type">trans:(('n, 'n, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> ('n, 'n, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a>)<br>             <a href="Slap_S.html#TYPEtrans3">trans3</a> -><br>       ?diag:<a href="Slap_common.html#TYPEdiag">Slap_common.diag</a> -><br>       ?up:bool -> ('n, 'n, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> ('n, 'x_cd) <a href="Slap_S.html#TYPEvec">vec</a> -> unit</code></pre><div class="info ">
<code class="code">trmv ~trans ?diag ?up a x</code> executes <code class="code">x := OP(a) * x</code>.<br>
</div>
<div class="param_info"><code class="code">trans</code> : the transpose flag for <code class="code">a</code>:<ul>
<li>If <code class="code">trans</code> = <a href="Slap_common.html#VALnormal"><code class="code">Slap_common.normal</code></a>, then <code class="code">OP(a)</code> = <code class="code">a</code>;</li>
<li>If <code class="code">trans</code> = <a href="Slap_common.html#VALtrans"><code class="code">Slap_common.trans</code></a>, then <code class="code">OP(a)</code> = <code class="code">a^T</code>;</li>
<li>If <code class="code">trans</code> = <a href="Slap_common.html#VALconjtr"><code class="code">Slap_common.conjtr</code></a>, then <code class="code">OP(a)</code> = <code class="code">a^H</code>
      (the conjugate transpose of <code class="code">a</code>).</li>
</ul>
</div>
<div class="param_info"><code class="code">diag</code> : default = <code class="code">`N</code><ul>
<li>If <code class="code">diag</code> = <code class="code">`U</code>, then <code class="code">a</code> is unit triangular;</li>
<li>If <code class="code">diag</code> = <code class="code">`N</code>, then <code class="code">a</code> is not unit triangular.</li>
</ul>
</div>
<div class="param_info"><code class="code">up</code> : default = <code class="code">true</code><ul>
<li>If <code class="code">up</code> = <code class="code">true</code>, then the upper triangular part of <code class="code">a</code> is used;</li>
<li>If <code class="code">up</code> = <code class="code">false</code>, then the lower triangular part of <code class="code">a</code> is used.</li>
</ul>
</div>

<pre><span id="VALtrsv"><span class="keyword">val</span> trsv</span> : <code class="type">trans:(('n, 'n, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> ('n, 'n, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a>)<br>             <a href="Slap_S.html#TYPEtrans3">trans3</a> -><br>       ?diag:<a href="Slap_common.html#TYPEdiag">Slap_common.diag</a> -><br>       ?up:bool -> ('n, 'n, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> ('n, 'b_cd) <a href="Slap_S.html#TYPEvec">vec</a> -> unit</code></pre><div class="info ">
<code class="code">trmv ~trans ?diag ?up a b</code> solves linear system <code class="code">OP(a) * x = b</code>
    and destructively assigns <code class="code">x</code> to <code class="code">b</code>.<br>
</div>
<div class="param_info"><code class="code">trans</code> : the transpose flag for <code class="code">a</code>:<ul>
<li>If <code class="code">trans</code> = <a href="Slap_common.html#VALnormal"><code class="code">Slap_common.normal</code></a>, then <code class="code">OP(a)</code> = <code class="code">a</code>;</li>
<li>If <code class="code">trans</code> = <a href="Slap_common.html#VALtrans"><code class="code">Slap_common.trans</code></a>, then <code class="code">OP(a)</code> = <code class="code">a^T</code>;</li>
<li>If <code class="code">trans</code> = <a href="Slap_common.html#VALconjtr"><code class="code">Slap_common.conjtr</code></a>, then <code class="code">OP(a)</code> = <code class="code">a^H</code>
      (the conjugate transpose of <code class="code">a</code>).</li>
</ul>
</div>
<div class="param_info"><code class="code">diag</code> : default = <code class="code">`N</code><ul>
<li>If <code class="code">diag</code> = <code class="code">`U</code>, then <code class="code">a</code> is unit triangular;</li>
<li>If <code class="code">diag</code> = <code class="code">`N</code>, then <code class="code">a</code> is not unit triangular.</li>
</ul>
</div>
<div class="param_info"><code class="code">up</code> : default = <code class="code">true</code><ul>
<li>If <code class="code">up</code> = <code class="code">true</code>, then the upper triangular part of <code class="code">a</code> is used;</li>
<li>If <code class="code">up</code> = <code class="code">false</code>, then the lower triangular part of <code class="code">a</code> is used.</li>
</ul>
</div>

<pre><span id="VALtpmv"><span class="keyword">val</span> tpmv</span> : <code class="type">trans:(('n, 'n, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> ('n, 'n, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a>)<br>             <a href="Slap_S.html#TYPEtrans3">trans3</a> -><br>       ?diag:<a href="Slap_common.html#TYPEdiag">Slap_common.diag</a> -><br>       ?up:bool -><br>       ('n <a href="Slap_size.html#TYPEpacked">Slap_size.packed</a>, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_S.html#TYPEvec">vec</a> -><br>       ('n, 'x_cd) <a href="Slap_S.html#TYPEvec">vec</a> -> unit</code></pre><div class="info ">
<code class="code">tpmv ~trans ?diag ?up a x</code> executes <code class="code">x := OP(a) * x</code>
    where <code class="code">a</code> is a packed triangular matrix.<br>
<b>Since</b> 0.2.0<br>
</div>
<div class="param_info"><code class="code">trans</code> : the transpose flag for <code class="code">a</code>:<ul>
<li>If <code class="code">trans</code> = <a href="Slap_common.html#VALnormal"><code class="code">Slap_common.normal</code></a>, then <code class="code">OP(a)</code> = <code class="code">a</code>;</li>
<li>If <code class="code">trans</code> = <a href="Slap_common.html#VALtrans"><code class="code">Slap_common.trans</code></a>, then <code class="code">OP(a)</code> = <code class="code">a^T</code>;</li>
<li>If <code class="code">trans</code> = <a href="Slap_common.html#VALconjtr"><code class="code">Slap_common.conjtr</code></a>, then <code class="code">OP(a)</code> = <code class="code">a^H</code>
      (the conjugate transpose of <code class="code">a</code>).</li>
</ul>
</div>
<div class="param_info"><code class="code">diag</code> : default = <code class="code">`N</code><ul>
<li>If <code class="code">diag</code> = <code class="code">`U</code>, then <code class="code">a</code> is unit triangular;</li>
<li>If <code class="code">diag</code> = <code class="code">`N</code>, then <code class="code">a</code> is not unit triangular.</li>
</ul>
</div>
<div class="param_info"><code class="code">up</code> : default = <code class="code">true</code><ul>
<li>If <code class="code">up</code> = <code class="code">true</code>, then the upper triangular part of <code class="code">a</code> is used;</li>
<li>If <code class="code">up</code> = <code class="code">false</code>, then the lower triangular part of <code class="code">a</code> is used.</li>
</ul>
</div>

<pre><span id="VALtpsv"><span class="keyword">val</span> tpsv</span> : <code class="type">trans:(('n, 'n, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> ('n, 'n, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a>)<br>             <a href="Slap_S.html#TYPEtrans3">trans3</a> -><br>       ?diag:<a href="Slap_common.html#TYPEdiag">Slap_common.diag</a> -><br>       ?up:bool -><br>       ('n <a href="Slap_size.html#TYPEpacked">Slap_size.packed</a>, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_S.html#TYPEvec">vec</a> -><br>       ('n, 'x_cd) <a href="Slap_S.html#TYPEvec">vec</a> -> unit</code></pre><div class="info ">
<code class="code">tpsv ~trans ?diag ?up a b</code> solves linear system <code class="code">OP(a) * x = b</code>
    and destructively assigns <code class="code">x</code> to <code class="code">b</code> where <code class="code">a</code> is a packed triangular
    matrix.<br>
<b>Since</b> 0.2.0<br>
</div>
<div class="param_info"><code class="code">trans</code> : the transpose flag for <code class="code">a</code>:<ul>
<li>If <code class="code">trans</code> = <a href="Slap_common.html#VALnormal"><code class="code">Slap_common.normal</code></a>, then <code class="code">OP(a)</code> = <code class="code">a</code>;</li>
<li>If <code class="code">trans</code> = <a href="Slap_common.html#VALtrans"><code class="code">Slap_common.trans</code></a>, then <code class="code">OP(a)</code> = <code class="code">a^T</code>;</li>
<li>If <code class="code">trans</code> = <a href="Slap_common.html#VALconjtr"><code class="code">Slap_common.conjtr</code></a>, then <code class="code">OP(a)</code> = <code class="code">a^H</code>
      (the conjugate transpose of <code class="code">a</code>).</li>
</ul>
</div>
<div class="param_info"><code class="code">diag</code> : default = <code class="code">`N</code><ul>
<li>If <code class="code">diag</code> = <code class="code">`U</code>, then <code class="code">a</code> is unit triangular;</li>
<li>If <code class="code">diag</code> = <code class="code">`N</code>, then <code class="code">a</code> is not unit triangular.</li>
</ul>
</div>
<div class="param_info"><code class="code">up</code> : default = <code class="code">true</code><ul>
<li>If <code class="code">up</code> = <code class="code">true</code>, then the upper triangular part of <code class="code">a</code> is used;</li>
<li>If <code class="code">up</code> = <code class="code">false</code>, then the lower triangular part of <code class="code">a</code> is used.</li>
</ul>
</div>
<br>
<h3 id="3_Level3">Level 3</h3><br>

<pre><span id="VALgemm"><span class="keyword">val</span> gemm</span> : <code class="type">?beta:<a href="Slap_S.html#TYPEnum_type">num_type</a> -><br>       ?c:('m, 'n, 'c_cd) <a href="Slap_S.html#TYPEmat">mat</a> -><br>       transa:(('a_m, 'a_k, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> ('m, 'k, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a>)<br>              <a href="Slap_S.html#TYPEtrans3">trans3</a> -><br>       ?alpha:<a href="Slap_S.html#TYPEnum_type">num_type</a> -><br>       ('a_m, 'a_k, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a> -><br>       transb:(('b_k, 'b_n, 'b_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> ('k, 'n, 'b_cd) <a href="Slap_S.html#TYPEmat">mat</a>)<br>              <a href="Slap_S.html#TYPEtrans3">trans3</a> -><br>       ('b_k, 'b_n, 'b_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> ('m, 'n, 'c_cd) <a href="Slap_S.html#TYPEmat">mat</a></code></pre><div class="info ">
<code class="code">gemm ?beta ?c ~transa ?alpha a ~transb b</code> executes
    <code class="code">c := alpha * OP(a) * OP(b) + beta * c</code>.<br>
</div>
<div class="param_info"><code class="code">beta</code> : default = <code class="code">0.0</code></div>
<div class="param_info"><code class="code">transa</code> : the transpose flag for <code class="code">a</code>:<ul>
<li>If <code class="code">transa</code> = <a href="Slap_common.html#VALnormal"><code class="code">Slap_common.normal</code></a>, then <code class="code">OP(a)</code> = <code class="code">a</code>;</li>
<li>If <code class="code">transa</code> = <a href="Slap_common.html#VALtrans"><code class="code">Slap_common.trans</code></a>, then <code class="code">OP(a)</code> = <code class="code">a^T</code>;</li>
<li>If <code class="code">transa</code> = <a href="Slap_common.html#VALconjtr"><code class="code">Slap_common.conjtr</code></a>, then <code class="code">OP(a)</code> = <code class="code">a^H</code>
      (the conjugate transpose of <code class="code">a</code>).</li>
</ul>
</div>
<div class="param_info"><code class="code">alpha</code> : default = <code class="code">1.0</code></div>
<div class="param_info"><code class="code">transb</code> : the transpose flag for <code class="code">b</code>:<ul>
<li>If <code class="code">transb</code> = <a href="Slap_common.html#VALnormal"><code class="code">Slap_common.normal</code></a>, then <code class="code">OP(b)</code> = <code class="code">b</code>;</li>
<li>If <code class="code">transb</code> = <a href="Slap_common.html#VALtrans"><code class="code">Slap_common.trans</code></a>, then <code class="code">OP(b)</code> = <code class="code">b^T</code>;</li>
<li>If <code class="code">transb</code> = <a href="Slap_common.html#VALconjtr"><code class="code">Slap_common.conjtr</code></a>, then <code class="code">OP(b)</code> = <code class="code">b^H</code>
      (the conjugate transpose of <code class="code">b</code>).</li>
</ul>
</div>

<pre><span id="VALsymm"><span class="keyword">val</span> symm</span> : <code class="type">side:('k, 'm, 'n) <a href="Slap_common.html#TYPEside">Slap_common.side</a> -><br>       ?up:bool -><br>       ?beta:<a href="Slap_S.html#TYPEnum_type">num_type</a> -><br>       ?c:('m, 'n, 'c_cd) <a href="Slap_S.html#TYPEmat">mat</a> -><br>       ?alpha:<a href="Slap_S.html#TYPEnum_type">num_type</a> -><br>       ('k, 'k, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a> -><br>       ('m, 'n, 'b_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> ('m, 'n, 'c_cd) <a href="Slap_S.html#TYPEmat">mat</a></code></pre><div class="info ">
<code class="code">symm ~side ?up ?beta ?c ?alpha a b</code> executes
<p>
<ul>
<li><code class="code">c := alpha * a * b + beta * c</code> (if <code class="code">side</code> = <a href="Slap_common.html#VALleft"><code class="code">Slap_common.left</code></a>) or</li>
<li><code class="code">c := alpha * b * a + beta * c</code> (if <code class="code">side</code> = <a href="Slap_common.html#VALright"><code class="code">Slap_common.right</code></a>)</li>
</ul>

    where <code class="code">a</code> is a symmterix matrix, and <code class="code">b</code> and <code class="code">c</code> are general matrices.<br>
</div>
<div class="param_info"><code class="code">side</code> : the side flag to specify direction of multiplication of <code class="code">a</code> and
                <code class="code">b</code>.</div>
<div class="param_info"><code class="code">up</code> : default = <code class="code">true</code><ul>
<li>If <code class="code">up</code> = <code class="code">true</code>, then the upper triangular part of <code class="code">a</code> is used;</li>
<li>If <code class="code">up</code> = <code class="code">false</code>, then the lower triangular part of <code class="code">a</code> is used.</li>
</ul>
</div>
<div class="param_info"><code class="code">beta</code> : default = <code class="code">0.0</code></div>
<div class="param_info"><code class="code">alpha</code> : default = <code class="code">1.0</code></div>

<pre><span id="VALtrmm"><span class="keyword">val</span> trmm</span> : <code class="type">side:('k, 'm, 'n) <a href="Slap_common.html#TYPEside">Slap_common.side</a> -><br>       ?up:bool -><br>       transa:(('k, 'k, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> ('k, 'k, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a>)<br>              <a href="Slap_S.html#TYPEtrans3">trans3</a> -><br>       ?diag:<a href="Slap_common.html#TYPEdiag">Slap_common.diag</a> -><br>       ?alpha:<a href="Slap_S.html#TYPEnum_type">num_type</a> -><br>       a:('k, 'k, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> ('m, 'n, 'b_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> unit</code></pre><div class="info ">
<code class="code">trmm ~side ?up ~transa ?diag ?alpha ~a b</code> executes
<p>
<ul>
<li><code class="code">b := alpha * OP(a) * b</code> (if <code class="code">side</code> = <a href="Slap_common.html#VALleft"><code class="code">Slap_common.left</code></a>) or</li>
<li><code class="code">b := alpha * b * OP(a)</code> (if <code class="code">side</code> = <a href="Slap_common.html#VALright"><code class="code">Slap_common.right</code></a>)</li>
</ul>

    where <code class="code">a</code> is a triangular matrix, and <code class="code">b</code> is a general matrix.<br>
</div>
<div class="param_info"><code class="code">side</code> : the side flag to specify direction of multiplication of <code class="code">a</code> and
                <code class="code">b</code>.</div>
<div class="param_info"><code class="code">up</code> : default = <code class="code">true</code><ul>
<li>If <code class="code">up</code> = <code class="code">true</code>, then the upper triangular part of <code class="code">a</code> is used;</li>
<li>If <code class="code">up</code> = <code class="code">false</code>, then the lower triangular part of <code class="code">a</code> is used.</li>
</ul>
</div>
<div class="param_info"><code class="code">transa</code> : the transpose flag for <code class="code">a</code>:<ul>
<li>If <code class="code">transa</code> = <a href="Slap_common.html#VALnormal"><code class="code">Slap_common.normal</code></a>, then <code class="code">OP(a)</code> = <code class="code">a</code>;</li>
<li>If <code class="code">transa</code> = <a href="Slap_common.html#VALtrans"><code class="code">Slap_common.trans</code></a>, then <code class="code">OP(a)</code> = <code class="code">a^T</code>;</li>
<li>If <code class="code">transa</code> = <a href="Slap_common.html#VALconjtr"><code class="code">Slap_common.conjtr</code></a>, then <code class="code">OP(a)</code> = <code class="code">a^H</code>
        (the conjugate transpose of <code class="code">a</code>).</li>
</ul>
</div>
<div class="param_info"><code class="code">diag</code> : default = <code class="code">`N</code><ul>
<li>If <code class="code">diag</code> = <code class="code">`U</code>, then <code class="code">a</code> is unit triangular;</li>
<li>If <code class="code">diag</code> = <code class="code">`N</code>, then <code class="code">a</code> is not unit triangular.</li>
</ul>
</div>
<div class="param_info"><code class="code">alpha</code> : default = <code class="code">1.0</code></div>

<pre><span id="VALtrsm"><span class="keyword">val</span> trsm</span> : <code class="type">side:('k, 'm, 'n) <a href="Slap_common.html#TYPEside">Slap_common.side</a> -><br>       ?up:bool -><br>       transa:(('k, 'k, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> ('k, 'k, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a>)<br>              <a href="Slap_S.html#TYPEtrans3">trans3</a> -><br>       ?diag:<a href="Slap_common.html#TYPEdiag">Slap_common.diag</a> -><br>       ?alpha:<a href="Slap_S.html#TYPEnum_type">num_type</a> -><br>       a:('k, 'k, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> ('m, 'n, 'b_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> unit</code></pre><div class="info ">
<code class="code">trsm ~side ?up ~transa ?diag ?alpha ~a b</code> solves a system of linear
    equations
<p>
<ul>
<li><code class="code">OP(a) * x = alpha * b</code> (if <code class="code">side</code> = <a href="Slap_common.html#VALleft"><code class="code">Slap_common.left</code></a>) or</li>
<li><code class="code">x * OP(a) = alpha * b</code> (if <code class="code">side</code> = <a href="Slap_common.html#VALright"><code class="code">Slap_common.right</code></a>)</li>
</ul>

    where <code class="code">a</code> is a triangular matrix, and <code class="code">b</code> is a general matrix.
    The solution <code class="code">x</code> is returned by <code class="code">b</code>.<br>
</div>
<div class="param_info"><code class="code">side</code> : the side flag to specify direction of multiplication of <code class="code">a</code> and
                <code class="code">b</code>.</div>
<div class="param_info"><code class="code">up</code> : default = <code class="code">true</code><ul>
<li>If <code class="code">up</code> = <code class="code">true</code>, then the upper triangular part of <code class="code">a</code> is used;</li>
<li>If <code class="code">up</code> = <code class="code">false</code>, then the lower triangular part of <code class="code">a</code> is used.</li>
</ul>
</div>
<div class="param_info"><code class="code">transa</code> : the transpose flag for <code class="code">a</code>:<ul>
<li>If <code class="code">transa</code> = <a href="Slap_common.html#VALnormal"><code class="code">Slap_common.normal</code></a>, then <code class="code">OP(a)</code> = <code class="code">a</code>;</li>
<li>If <code class="code">transa</code> = <a href="Slap_common.html#VALtrans"><code class="code">Slap_common.trans</code></a>, then <code class="code">OP(a)</code> = <code class="code">a^T</code>;</li>
<li>If <code class="code">transa</code> = <a href="Slap_common.html#VALconjtr"><code class="code">Slap_common.conjtr</code></a>, then <code class="code">OP(a)</code> = <code class="code">a^H</code>
        (the conjugate transpose of <code class="code">a</code>).</li>
</ul>
</div>
<div class="param_info"><code class="code">diag</code> : default = <code class="code">`N</code><ul>
<li>If <code class="code">diag</code> = <code class="code">`U</code>, then <code class="code">a</code> is unit triangular;</li>
<li>If <code class="code">diag</code> = <code class="code">`N</code>, then <code class="code">a</code> is not unit triangular.</li>
</ul>
</div>
<div class="param_info"><code class="code">alpha</code> : default = <code class="code">1.0</code></div>

<pre><span id="VALsyrk"><span class="keyword">val</span> syrk</span> : <code class="type">?up:bool -><br>       ?beta:<a href="Slap_S.html#TYPEnum_type">num_type</a> -><br>       ?c:('n, 'n, 'c_cd) <a href="Slap_S.html#TYPEmat">mat</a> -><br>       trans:(('a_n, 'a_k, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> ('n, 'k, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a>)<br>             <a href="Slap_common.html#TYPEtrans2">Slap_common.trans2</a> -><br>       ?alpha:<a href="Slap_S.html#TYPEnum_type">num_type</a> -><br>       ('a_n, 'a_k, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> ('n, 'n, 'c_cd) <a href="Slap_S.html#TYPEmat">mat</a></code></pre><div class="info ">
<code class="code">syrk ?up ?beta ?c ~trans ?alpha a</code> executes
<p>
<ul>
<li><code class="code">c := alpha * a * a^T + beta * c</code> (if <code class="code">trans</code> = <a href="Slap_common.html#VALnormal"><code class="code">Slap_common.normal</code></a>) or</li>
<li><code class="code">c := alpha * a^T * a + beta * c</code> (if <code class="code">trans</code> = <a href="Slap_common.html#VALtrans"><code class="code">Slap_common.trans</code></a>)</li>
</ul>

    where <code class="code">a</code> is a general matrix and <code class="code">c</code> is a symmetric matrix.<br>
</div>
<div class="param_info"><code class="code">up</code> : default = <code class="code">true</code><ul>
<li>If <code class="code">up</code> = <code class="code">true</code>, then the upper triangular part of <code class="code">a</code> is used;</li>
<li>If <code class="code">up</code> = <code class="code">false</code>, then the lower triangular part of <code class="code">a</code> is used.</li>
</ul>
</div>
<div class="param_info"><code class="code">beta</code> : default = <code class="code">0.0</code></div>
<div class="param_info"><code class="code">trans</code> : the transpose flag for <code class="code">a</code></div>
<div class="param_info"><code class="code">alpha</code> : default = <code class="code">1.0</code></div>

<pre><span id="VALsyr2k"><span class="keyword">val</span> syr2k</span> : <code class="type">?up:bool -><br>       ?beta:<a href="Slap_S.html#TYPEnum_type">num_type</a> -><br>       ?c:('n, 'n, 'c_cd) <a href="Slap_S.html#TYPEmat">mat</a> -><br>       trans:(('p, 'q, 'a) <a href="Slap_S.html#TYPEmat">mat</a> -> ('n, 'k, 'b) <a href="Slap_S.html#TYPEmat">mat</a>) <a href="Slap_common.html#TYPEtrans2">Slap_common.trans2</a> -><br>       ?alpha:<a href="Slap_S.html#TYPEnum_type">num_type</a> -><br>       ('p, 'q, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a> -><br>       ('p, 'q, 'b_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> ('n, 'n, 'c_cd) <a href="Slap_S.html#TYPEmat">mat</a></code></pre><div class="info ">
<code class="code">syr2k ?up ?beta ?c ~trans ?alpha a b</code> computes
<p>
<ul>
<li><code class="code">c := alpha * a * b^T + alpha * b * a^T + beta * c</code>
      (if <code class="code">trans</code> = <a href="Slap_common.html#VALnormal"><code class="code">Slap_common.normal</code></a>) or</li>
<li><code class="code">c := alpha * a^T * b + alpha * b^T * a + beta * c</code>
      (if <code class="code">trans</code> = <a href="Slap_common.html#VALtrans"><code class="code">Slap_common.trans</code></a>)</li>
</ul>

    with symmetric matrix <code class="code">c</code>, and general matrices <code class="code">a</code> and <code class="code">b</code>.<br>
</div>
<div class="param_info"><code class="code">up</code> : default = <code class="code">true</code><ul>
<li>If <code class="code">up</code> = <code class="code">true</code>, then the upper triangular part of <code class="code">a</code> is used;</li>
<li>If <code class="code">up</code> = <code class="code">false</code>, then the lower triangular part of <code class="code">a</code> is used.</li>
</ul>
</div>
<div class="param_info"><code class="code">beta</code> : default = <code class="code">0.0</code></div>
<div class="param_info"><code class="code">trans</code> : the transpose flag for <code class="code">a</code></div>
<div class="param_info"><code class="code">alpha</code> : default = <code class="code">1.0</code></div>
<br>
<h2 id="2_LAPACKinterface">LAPACK interface</h2><br>
<br>
<h2 id="2_LAPACKinterface">LAPACK interface</h2><br>
<br>
<h3 id="3_Auxiliaryroutines">Auxiliary routines</h3><br>

<pre><span id="VALlacpy"><span class="keyword">val</span> lacpy</span> : <code class="type">?uplo:[ `L | `U ] -><br>       ?b:('m, 'n, 'b_cd) <a href="Slap_S.html#TYPEmat">mat</a> -><br>       ('m, 'n, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> ('m, 'n, 'b_cd) <a href="Slap_S.html#TYPEmat">mat</a></code></pre><div class="info ">
<code class="code">lacpy ?uplo ?b a</code> copies the matrix <code class="code">a</code> into the matrix <code class="code">b</code>.<ul>
<li>If <code class="code">uplo</code> is omitted, all elements in <code class="code">a</code> is copied.</li>
<li>If <code class="code">uplo</code> is <code class="code">`U</code>, the upper trapezoidal part of <code class="code">a</code> is copied.</li>
<li>If <code class="code">uplo</code> is <code class="code">`L</code>, the lower trapezoidal part of <code class="code">a</code> is copied.</li>
</ul>
<br>
<b>Returns</b> <code class="code">b</code>, which is overwritten.<br>
</div>
<div class="param_info"><code class="code">uplo</code> : default = all elements in <code class="code">a</code> is copied.</div>
<div class="param_info"><code class="code">b</code> : default = a fresh matrix.</div>

<pre><span id="VALlassq"><span class="keyword">val</span> lassq</span> : <code class="type">?scale:float -> ?sumsq:float -> ('n, 'cd) <a href="Slap_S.html#TYPEvec">vec</a> -> float * float</code></pre><div class="info ">
<code class="code">lassq ?scale ?sumsq x</code><br>
<b>Returns</b> <code class="code">(scl, smsq)</code> where <code class="code">scl</code> and <code class="code">smsq</code> satisfy
    <code class="code">scl^2 * smsq = x1^2 + x2^2 + ... + xn^2 + scale^2 * smsq</code>.<br>
</div>
<div class="param_info"><code class="code">scale</code> : default = <code class="code">0.0</code></div>
<div class="param_info"><code class="code">sumsq</code> : default = <code class="code">1.0</code></div>

<pre><span id="TYPElarnv_liseed"><span class="keyword">type</span> <code class="type"></code>larnv_liseed</span> = <code class="type"><a href="Slap_size.html#TYPEfour">Slap_size.four</a></code> </pre>


<pre><span id="VALlarnv"><span class="keyword">val</span> larnv</span> : <code class="type">?idist:[ `Normal | `Uniform0 | `Uniform1 ] -><br>       ?iseed:(<a href="Slap_S.html#TYPElarnv_liseed">larnv_liseed</a>, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_common.html#TYPEint32_vec">Slap_common.int32_vec</a> -><br>       x:('n, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_S.html#TYPEvec">vec</a> -> unit -> ('n, 'cnt) <a href="Slap_S.html#TYPEvec">vec</a></code></pre><div class="info ">
<code class="code">larnv ?idist ?iseed ~x ()</code> generates a random vector with the random
    distribution specified by <code class="code">idist</code> and random seed <code class="code">iseed</code>.<br>
<b>Returns</b> vector <code class="code">x</code>, which is overwritten.<br>
</div>
<div class="param_info"><code class="code">idist</code> : default = <code class="code">`Normal</code></div>
<div class="param_info"><code class="code">iseed</code> : a four-dimensional integer vector with all ones.</div>

<pre><span id="TYPElange_min_lwork"><span class="keyword">type</span> <code class="type">('m, 'a)</code> lange_min_lwork</span> </pre>


<pre><span id="VALlange_min_lwork"><span class="keyword">val</span> lange_min_lwork</span> : <code class="type">'m <a href="Slap_size.html#TYPEt">Slap_size.t</a> -><br>       'a <a href="Slap_common.html#TYPEnorm4">Slap_common.norm4</a> -> ('m, 'a) <a href="Slap_S.html#TYPElange_min_lwork">lange_min_lwork</a> <a href="Slap_size.html#TYPEt">Slap_size.t</a></code></pre><div class="info ">
<code class="code">lange_min_lwork m norm</code> computes the minimum length of workspace for
    <code class="code">lange</code> routine. <code class="code">m</code> is the number of rows in a matrix, and <code class="code">norm</code> is
    the sort of matrix norms.<br>
</div>

<pre><span id="VALlange"><span class="keyword">val</span> lange</span> : <code class="type">?norm:'a <a href="Slap_common.html#TYPEnorm4">Slap_common.norm4</a> -><br>       ?work:('lwork, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_S.html#TYPErvec">rvec</a> -><br>       ('m, 'n, 'cd) <a href="Slap_S.html#TYPEmat">mat</a> -> float</code></pre><div class="info ">
<code class="code">lange ?norm ?work a</code><br>
<b>Returns</b> the norm of matrix <code class="code">a</code>.<br>
</div>
<div class="param_info"><code class="code">norm</code> : default = <a href="Slap_common.html#VALnorm_1"><code class="code">Slap_common.norm_1</code></a>.<ul>
<li>If <code class="code">norm</code> = <a href="Slap_common.html#VALnorm_1"><code class="code">Slap_common.norm_1</code></a>, the one norm is returned;</li>
<li>If <code class="code">norm</code> = <a href="Slap_common.html#VALnorm_inf"><code class="code">Slap_common.norm_inf</code></a>, the infinity norm is returned;</li>
<li>If <code class="code">norm</code> = <a href="Slap_common.html#VALnorm_amax"><code class="code">Slap_common.norm_amax</code></a>, the largest absolute value of
        elements in matrix <code class="code">a</code> (not a matrix norm) is returned;</li>
<li>If <code class="code">norm</code> = <a href="Slap_common.html#VALnorm_frob"><code class="code">Slap_common.norm_frob</code></a>, the Frobenius norm is returned.</li>
</ul>
</div>
<div class="param_info"><code class="code">work</code> : default = an optimum-length vector.</div>

<pre><span id="VALlauum"><span class="keyword">val</span> lauum</span> : <code class="type">?up:bool -> ('n, 'n, 'cd) <a href="Slap_S.html#TYPEmat">mat</a> -> unit</code></pre><div class="info ">
<code class="code">lauum ?up a</code> computes
<p>
<ul>
<li><code class="code">U * U^T</code> where <code class="code">U</code> is the upper triangular part of matrix <code class="code">a</code>
      if <code class="code">up</code> is <code class="code">true</code>.</li>
<li><code class="code">L^T * L</code> where <code class="code">L</code> is the lower triangular part of matrix <code class="code">a</code>
      if <code class="code">up</code> is <code class="code">false</code>.</li>
</ul>

    The upper or lower triangular part is overwritten.<br>
</div>
<div class="param_info"><code class="code">up</code> : default = <code class="code">true</code>.</div>
<br>
<h3 id="3_Linearequationscomputationalroutines">Linear equations (computational routines)</h3><br>

<pre><span id="VALgetrf"><span class="keyword">val</span> getrf</span> : <code class="type">?ipiv:(('m, 'n) <a href="Slap_size.html#TYPEmin">Slap_size.min</a>, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_common.html#TYPEint32_vec">Slap_common.int32_vec</a> -><br>       ('m, 'n, 'cd) <a href="Slap_S.html#TYPEmat">mat</a> -><br>       (('m, 'n) <a href="Slap_size.html#TYPEmin">Slap_size.min</a>, 'cnt) <a href="Slap_common.html#TYPEint32_vec">Slap_common.int32_vec</a></code></pre><div class="info ">
<code class="code">getrf ?ipiv a</code> computes LU factorization of matrix <code class="code">a</code> using partial
    pivoting with row interchanges: <code class="code">a = P * L * U</code> where <code class="code">P</code> is a permutation
    matrix, and <code class="code">L</code> and <code class="code">U</code> are lower and upper triangular matrices,
    respectively. the permutation matrix is returned in <code class="code">ipiv</code>.<br>
<b>Raises</b> <code>Failure</code> if the matrix is singular.<br>
<b>Returns</b> vector <code class="code">ipiv</code>, which is overwritten.<br>
</div>

<pre><span id="VALgetrs"><span class="keyword">val</span> getrs</span> : <code class="type">?ipiv:(('n, 'n) <a href="Slap_size.html#TYPEmin">Slap_size.min</a>, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_common.html#TYPEint32_vec">Slap_common.int32_vec</a> -><br>       trans:(('n, 'n, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> ('n, 'n, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a>)<br>             <a href="Slap_S.html#TYPEtrans3">trans3</a> -><br>       ('n, 'n, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> ('n, 'n, 'b_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> unit</code></pre><div class="info ">
<code class="code">getrs ?ipiv trans a b</code> solves systems of linear equations <code class="code">OP(a) * x = b</code>
    where <code class="code">a</code> a <code class="code">'n</code>-by-<code class="code">'n</code> general matrix, each column of matrix <code class="code">b</code> is the
    r.h.s. vector, and each column of matrix <code class="code">x</code> is the corresponding solution.
    The solution <code class="code">x</code> is returned in <code class="code">b</code>.<br>
<b>Raises</b> <code>Failure</code> if the matrix is singular.<br>
</div>
<div class="param_info"><code class="code">ipiv</code> : a result of <code class="code">gesv</code> or <code class="code">getrf</code>. It is internally computed by
                 <code class="code">getrf</code> if omitted.</div>
<div class="param_info"><code class="code">trans</code> : the transpose flag for <code class="code">a</code>:<ul>
<li>If <code class="code">trans</code> = <a href="Slap_common.html#VALnormal"><code class="code">Slap_common.normal</code></a>, then <code class="code">OP(a)</code> = <code class="code">a</code>;</li>
<li>If <code class="code">trans</code> = <a href="Slap_common.html#VALtrans"><code class="code">Slap_common.trans</code></a>, then <code class="code">OP(a)</code> = <code class="code">a^T</code>;</li>
<li>If <code class="code">trans</code> = <a href="Slap_common.html#VALconjtr"><code class="code">Slap_common.conjtr</code></a>, then <code class="code">OP(a)</code> = <code class="code">a^H</code>
      (the conjugate transpose of <code class="code">a</code>).</li>
</ul>
</div>

<pre><span id="TYPEgetri_min_lwork"><span class="keyword">type</span> <code class="type">'n</code> getri_min_lwork</span> </pre>


<pre><span id="VALgetri_min_lwork"><span class="keyword">val</span> getri_min_lwork</span> : <code class="type">'n <a href="Slap_size.html#TYPEt">Slap_size.t</a> -> 'n <a href="Slap_S.html#TYPEgetri_min_lwork">getri_min_lwork</a> <a href="Slap_size.html#TYPEt">Slap_size.t</a></code></pre><div class="info ">
<code class="code">getri_min_lwork n</code> computes the minimum length of workspace for <code class="code">getri</code>
    routine. <code class="code">n</code> is the number of columns or rows in a matrix.<br>
</div>

<pre><span id="VALgetri_opt_lwork"><span class="keyword">val</span> getri_opt_lwork</span> : <code class="type">('n, 'n, 'cd) <a href="Slap_S.html#TYPEmat">mat</a> -> (module Slap_size.SIZE)</code></pre><div class="info ">
<code class="code">getri_opt_lwork a</code> computes the optimal length of workspace for <code class="code">getri</code>
    routine.<br>
</div>

<pre><span id="VALgetri"><span class="keyword">val</span> getri</span> : <code class="type">?ipiv:(('n, 'n) <a href="Slap_size.html#TYPEmin">Slap_size.min</a>, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_common.html#TYPEint32_vec">Slap_common.int32_vec</a> -><br>       ?work:('lwork, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_S.html#TYPEvec">vec</a> -> ('n, 'n, 'cd) <a href="Slap_S.html#TYPEmat">mat</a> -> unit</code></pre><div class="info ">
<code class="code">getri ?ipiv ?work a</code> computes the inverse of general matrix <code class="code">a</code> by
    LU-factorization. The inverse matrix is returned in <code class="code">a</code>.<br>
<b>Raises</b> <code>Failure</code> if the matrix is singular.<br>
</div>
<div class="param_info"><code class="code">ipiv</code> : a result of <code class="code">gesv</code> or <code class="code">getrf</code>. It is internally computed by
                <code class="code">getrf</code> if omitted.</div>
<div class="param_info"><code class="code">work</code> : default = an optimum-length vector.</div>

<pre><span id="TYPEsytrf_min_lwork"><span class="keyword">type</span> <code class="type"></code>sytrf_min_lwork</span> </pre>


<pre><span id="VALsytrf_min_lwork"><span class="keyword">val</span> sytrf_min_lwork</span> : <code class="type">unit -> <a href="Slap_S.html#TYPEsytrf_min_lwork">sytrf_min_lwork</a> <a href="Slap_size.html#TYPEt">Slap_size.t</a></code></pre><div class="info ">
<code class="code">sytrf_min_lwork ()</code> computes the minimum length of workspace for <code class="code">sytrf</code>
    routine.<br>
</div>

<pre><span id="VALsytrf_opt_lwork"><span class="keyword">val</span> sytrf_opt_lwork</span> : <code class="type">?up:bool -> ('n, 'n, 'cd) <a href="Slap_S.html#TYPEmat">mat</a> -> (module Slap_size.SIZE)</code></pre><div class="info ">
<code class="code">sytrf_opt_lwork ?up a</code> computes the optimal length of workspace for <code class="code">sytrf</code>
    routine.<br>
</div>
<div class="param_info"><code class="code">up</code> : default = <code class="code">true</code><ul>
<li>If <code class="code">up</code> = <code class="code">true</code>, then the upper triangular part of <code class="code">a</code> is used;</li>
<li>If <code class="code">up</code> = <code class="code">false</code>, then the lower triangular part of <code class="code">a</code> is used.</li>
</ul>
</div>

<pre><span id="VALsytrf"><span class="keyword">val</span> sytrf</span> : <code class="type">?up:bool -><br>       ?ipiv:('n, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_common.html#TYPEint32_vec">Slap_common.int32_vec</a> -><br>       ?work:('lwork, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_S.html#TYPEvec">vec</a> -><br>       ('n, 'n, 'cd) <a href="Slap_S.html#TYPEmat">mat</a> -> ('n, 'cnt) <a href="Slap_common.html#TYPEint32_vec">Slap_common.int32_vec</a></code></pre><div class="info ">
<code class="code">sytrf ?up ?ipiv ?work a</code> factorizes symmetric matrix <code class="code">a</code> using the
    Bunch-Kaufman diagonal pivoting method:
<p>
<ul>
<li><code class="code">a = P * U * D * U^T * P^T</code> if <code class="code">up</code> = <code class="code">true</code>;</li>
<li><code class="code">a = P * L * D * L^T * P^T</code> if <code class="code">up</code> = <code class="code">false</code></li>
</ul>

    where <code class="code">P</code> is a permutation matrix, <code class="code">U</code> and <code class="code">L</code> are upper and lower
    triangular matrices with unit diagonal, and <code class="code">D</code> is a symmetric
    block-diagonal matrix. The permutation matrix is returned in <code class="code">ipiv</code>.<br>
<b>Raises</b> <code>Failure</code> if <code class="code">a</code> is singular.<br>
<b>Returns</b> vector <code class="code">ipiv</code>, which is overwritten.<br>
</div>
<div class="param_info"><code class="code">up</code> : default = <code class="code">true</code></div>
<div class="param_info"><code class="code">work</code> : default = an optimum-length vector.</div>

<pre><span id="VALsytrs"><span class="keyword">val</span> sytrs</span> : <code class="type">?up:bool -><br>       ?ipiv:('n, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_common.html#TYPEint32_vec">Slap_common.int32_vec</a> -><br>       ('n, 'n, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> ('n, 'nrhs, 'b_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> unit</code></pre><div class="info ">
<code class="code">sytrs ?up ?ipiv a b</code> solves systems of linear equations <code class="code">a * x = b</code> where
    <code class="code">a</code> is a symmetric matrix, each column of matrix <code class="code">b</code> is the r.h.s. vector,
    and each column of matrix <code class="code">x</code> is the corresponding solution.
    The solution <code class="code">x</code> is returned in <code class="code">b</code>.
<p>

    This routine uses the Bunch-Kaufman diagonal pivoting method:
<p>
<ul>
<li><code class="code">a = P * U * D * U^T * P^T</code> if <code class="code">up</code> = <code class="code">true</code>;</li>
<li><code class="code">a = P * L * D * L^T * P^T</code> if <code class="code">up</code> = <code class="code">false</code></li>
</ul>

    where <code class="code">P</code> is a permutation matrix, <code class="code">U</code> and <code class="code">L</code> are upper and lower
    triangular matrices with unit diagonal, and <code class="code">D</code> is a symmetric
    block-diagonal matrix.<br>
<b>Raises</b> <code>Failure</code> if <code class="code">a</code> is singular.<br>
</div>
<div class="param_info"><code class="code">up</code> : default = <code class="code">true</code></div>
<div class="param_info"><code class="code">ipiv</code> : a result of <code class="code">sytrf</code>. It is internally computed by <code class="code">sytrf</code> if
                omitted.</div>

<pre><span id="TYPEsytri_min_lwork"><span class="keyword">type</span> <code class="type">'n</code> sytri_min_lwork</span> </pre>


<pre><span id="VALsytri_min_lwork"><span class="keyword">val</span> sytri_min_lwork</span> : <code class="type">'n <a href="Slap_size.html#TYPEt">Slap_size.t</a> -> 'n <a href="Slap_S.html#TYPEsytri_min_lwork">sytri_min_lwork</a> <a href="Slap_size.html#TYPEt">Slap_size.t</a></code></pre><div class="info ">
<code class="code">sytri_min_lwork ()</code> computes the minimum length of workspace for <code class="code">sytri</code>
    routine.<br>
</div>

<pre><span id="VALsytri"><span class="keyword">val</span> sytri</span> : <code class="type">?up:bool -><br>       ?ipiv:('n, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_common.html#TYPEint32_vec">Slap_common.int32_vec</a> -><br>       ?work:('lwork, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_S.html#TYPEvec">vec</a> -> ('n, 'n, 'cd) <a href="Slap_S.html#TYPEmat">mat</a> -> unit</code></pre><div class="info ">
<code class="code">sytri ?up ?ipiv ?work a</code> computes the inverse of symmetric matrix <code class="code">a</code> using
    the Bunch-Kaufman diagonal pivoting method:
<p>
<ul>
<li><code class="code">a = P * U * D * U^T * P^T</code> if <code class="code">up</code> = <code class="code">true</code>;</li>
<li><code class="code">a = P * L * D * L^T * P^T</code> if <code class="code">up</code> = <code class="code">false</code></li>
</ul>

    where <code class="code">P</code> is a permutation matrix, <code class="code">U</code> and <code class="code">L</code> are upper and lower
    triangular matrices with unit diagonal, and <code class="code">D</code> is a symmetric
    block-diagonal matrix.<br>
<b>Raises</b> <code>Failure</code> if <code class="code">a</code> is singular.<br>
</div>
<div class="param_info"><code class="code">up</code> : default = <code class="code">true</code></div>
<div class="param_info"><code class="code">ipiv</code> : a result of <code class="code">sytrf</code>. It is internally computed by <code class="code">sytrf</code> if
                omitted.</div>
<div class="param_info"><code class="code">work</code> : default = an optimum-length vector.</div>

<pre><span id="VALpotrf"><span class="keyword">val</span> potrf</span> : <code class="type">?up:bool -> ?jitter:<a href="Slap_S.html#TYPEnum_type">num_type</a> -> ('n, 'n, 'cd) <a href="Slap_S.html#TYPEmat">mat</a> -> unit</code></pre><div class="info ">
<code class="code">potrf ?up ?jitter a</code> computes the Cholesky factorization of symmetrix
    (Hermitian) positive-definite matrix <code class="code">a</code>:
<p>
<ul>
<li><code class="code">a = U^T * U</code> (real) or <code class="code">a = U^H * U</code> (complex) if <code class="code">up</code> = <code class="code">true</code>;</li>
<li><code class="code">a = L * L^T</code> (real) or <code class="code">a = L * L^H</code> (complex) if <code class="code">up</code> = <code class="code">false</code></li>
</ul>

    where <code class="code">U</code> and <code class="code">L</code> are upper and lower triangular matrices, respectively.
    Either of them is returned in the upper or lower triangular part of <code class="code">a</code>,
    as specified by <code class="code">up</code>.<br>
<b>Raises</b> <code>Failure</code> if <code class="code">a</code> is singular.<br>
</div>
<div class="param_info"><code class="code">up</code> : default = <code class="code">true</code></div>
<div class="param_info"><code class="code">jitter</code> : default = nothing</div>

<pre><span id="VALpotrs"><span class="keyword">val</span> potrs</span> : <code class="type">?up:bool -><br>       ('n, 'n, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a> -><br>       ?factorize:bool -><br>       ?jitter:<a href="Slap_S.html#TYPEnum_type">num_type</a> -> ('n, 'nrhs, 'b_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> unit</code></pre><div class="info ">
<code class="code">potrf ?up a ?jitter b</code> solves systems of linear equations <code class="code">a * x = b</code> using
    the Cholesky factorization of symmetrix (Hermitian) positive-definite matrix
    <code class="code">a</code>:
<p>
<ul>
<li><code class="code">a = U^T * U</code> (real) or <code class="code">a = U^H * U</code> (complex) if <code class="code">up</code> = <code class="code">true</code>;</li>
<li><code class="code">a = L * L^T</code> (real) or <code class="code">a = L * L^H</code> (complex) if <code class="code">up</code> = <code class="code">false</code></li>
</ul>

    where <code class="code">U</code> and <code class="code">L</code> are upper and lower triangular matrices, respectively.<br>
<b>Raises</b> <code>Failure</code> if <code class="code">a</code> is singular.<br>
</div>
<div class="param_info"><code class="code">up</code> : default = <code class="code">true</code></div>
<div class="param_info"><code class="code">factorize</code> : default = <code class="code">true</code> (<code class="code">potrf</code> is called implicitly)</div>
<div class="param_info"><code class="code">jitter</code> : default = nothing</div>

<pre><span id="VALpotri"><span class="keyword">val</span> potri</span> : <code class="type">?up:bool -><br>       ?factorize:bool -><br>       ?jitter:<a href="Slap_S.html#TYPEnum_type">num_type</a> -> ('n, 'n, 'cd) <a href="Slap_S.html#TYPEmat">mat</a> -> unit</code></pre><div class="info ">
<code class="code">potrf ?up ?jitter a</code> computes the inverse of symmetrix (Hermitian)
    positive-definite matrix <code class="code">a</code> using the Cholesky factorization:
<p>
<ul>
<li><code class="code">a = U^T * U</code> (real) or <code class="code">a = U^H * U</code> (complex) if <code class="code">up</code> = <code class="code">true</code>;</li>
<li><code class="code">a = L * L^T</code> (real) or <code class="code">a = L * L^H</code> (complex) if <code class="code">up</code> = <code class="code">false</code></li>
</ul>

    where <code class="code">U</code> and <code class="code">L</code> are upper and lower triangular matrices, respectively.<br>
<b>Raises</b> <code>Failure</code> if <code class="code">a</code> is singular.<br>
</div>
<div class="param_info"><code class="code">up</code> : default = <code class="code">true</code></div>
<div class="param_info"><code class="code">factorize</code> : default = <code class="code">true</code> (<code class="code">potrf</code> is called implicitly)</div>
<div class="param_info"><code class="code">jitter</code> : default = nothing</div>

<pre><span id="VALtrtrs"><span class="keyword">val</span> trtrs</span> : <code class="type">?up:bool -><br>       trans:(('n, 'n, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> ('n, 'n, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a>)<br>             <a href="Slap_S.html#TYPEtrans3">trans3</a> -><br>       ?diag:<a href="Slap_common.html#TYPEdiag">Slap_common.diag</a> -><br>       ('n, 'n, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> ('n, 'nrhs, 'b_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> unit</code></pre><div class="info ">
<code class="code">trtrs ?up trans ?diag a b</code> solves systems of linear equations
    <code class="code">OP(a) * x = b</code> where <code class="code">a</code> is a triangular matrix of order <code class="code">'n</code>, each column
    of matrix <code class="code">b</code> is the r.h.s vector, and each column of matrix <code class="code">x</code> is the
    corresponding solution. The solution <code class="code">x</code> is returned in <code class="code">b</code>.<br>
<b>Raises</b> <code>Failure</code> if <code class="code">a</code> is singular.<br>
</div>
<div class="param_info"><code class="code">up</code> : default = <code class="code">true</code><ul>
<li>If <code class="code">up</code> = <code class="code">true</code>, then the upper triangular part of <code class="code">a</code> is used;</li>
<li>If <code class="code">up</code> = <code class="code">false</code>, then the lower triangular part of <code class="code">a</code> is used.</li>
</ul>
</div>
<div class="param_info"><code class="code">trans</code> : the transpose flag for <code class="code">a</code>:<ul>
<li>If <code class="code">trans</code> = <a href="Slap_common.html#VALnormal"><code class="code">Slap_common.normal</code></a>, then <code class="code">OP(a)</code> = <code class="code">a</code>;</li>
<li>If <code class="code">trans</code> = <a href="Slap_common.html#VALtrans"><code class="code">Slap_common.trans</code></a>, then <code class="code">OP(a)</code> = <code class="code">a^T</code>;</li>
<li>If <code class="code">trans</code> = <a href="Slap_common.html#VALconjtr"><code class="code">Slap_common.conjtr</code></a>, then <code class="code">OP(a)</code> = <code class="code">a^H</code>
        (the conjugate transpose of <code class="code">a</code>).</li>
</ul>
</div>
<div class="param_info"><code class="code">diag</code> : default = <code class="code">`N</code><ul>
<li>If <code class="code">diag</code> = <code class="code">`U</code>, then <code class="code">a</code> is unit triangular;</li>
<li>If <code class="code">diag</code> = <code class="code">`N</code>, then <code class="code">a</code> is not unit triangular.</li>
</ul>
</div>

<pre><span id="VALtbtrs"><span class="keyword">val</span> tbtrs</span> : <code class="type">kd:'kd <a href="Slap_size.html#TYPEt">Slap_size.t</a> -><br>       ?up:bool -><br>       trans:(('n, 'n, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> ('n, 'n, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a>)<br>             <a href="Slap_S.html#TYPEtrans3">trans3</a> -><br>       ?diag:<a href="Slap_common.html#TYPEdiag">Slap_common.diag</a> -><br>       (('n, 'kd) <a href="Slap_size.html#TYPEsyband">Slap_size.syband</a>, 'n, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a> -><br>       ('n, 'nrhs, 'b_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> unit</code></pre><div class="info ">
<code class="code">tbtrs ~kd ?up ~trans ?diag ab b</code> solves systems of linear equations
    <code class="code">OP(A) * x = b</code> where <code class="code">A</code> is a triangular band matrix with <code class="code">kd</code> subdiagonals,
    each column of matrix <code class="code">b</code> is the r.h.s vector, and each column of matrix <code class="code">x</code>
    is the corresponding solution. Matrix <code class="code">A</code> is stored into <code class="code">ab</code> in band
    storage format. The solution <code class="code">x</code> is returned in <code class="code">b</code>.<br>
<b>Since</b> 0.2.0<br>
<b>Raises</b> <code>Failure</code> if the matrix <code class="code">A</code> is singular.<br>
</div>
<div class="param_info"><code class="code">kd</code> : the number of subdiagonals or superdiagonals in <code class="code">A</code>.</div>
<div class="param_info"><code class="code">up</code> : default = <code class="code">true</code><ul>
<li>If <code class="code">up</code> = <code class="code">true</code>, then the upper triangular part of <code class="code">A</code> is used;</li>
<li>If <code class="code">up</code> = <code class="code">false</code>, then the lower triangular part of <code class="code">A</code> is used.</li>
</ul>
</div>
<div class="param_info"><code class="code">trans</code> : the transpose flag for <code class="code">A</code>:<ul>
<li>If <code class="code">trans</code> = <a href="Slap_common.html#VALnormal"><code class="code">Slap_common.normal</code></a>, then <code class="code">OP(A)</code> = <code class="code">A</code>;</li>
<li>If <code class="code">trans</code> = <a href="Slap_common.html#VALtrans"><code class="code">Slap_common.trans</code></a>, then <code class="code">OP(A)</code> = <code class="code">A^T</code>;</li>
<li>If <code class="code">trans</code> = <a href="Slap_common.html#VALconjtr"><code class="code">Slap_common.conjtr</code></a>, then <code class="code">OP(A)</code> = <code class="code">A^H</code>
        (the conjugate transpose of <code class="code">A</code>).</li>
</ul>
</div>
<div class="param_info"><code class="code">diag</code> : default = <code class="code">`N</code><ul>
<li>If <code class="code">diag</code> = <code class="code">`U</code>, then <code class="code">A</code> is unit triangular;</li>
<li>If <code class="code">diag</code> = <code class="code">`N</code>, then <code class="code">A</code> is not unit triangular.</li>
</ul>
</div>

<pre><span id="VALtrtri"><span class="keyword">val</span> trtri</span> : <code class="type">?up:bool -> ?diag:<a href="Slap_common.html#TYPEdiag">Slap_common.diag</a> -> ('n, 'n, 'cd) <a href="Slap_S.html#TYPEmat">mat</a> -> unit</code></pre><div class="info ">
<code class="code">trtri ?up ?diag a</code> computes the inverse of triangular matrix <code class="code">a</code>. The
    inverse matrix is returned in <code class="code">a</code>.<br>
<b>Since</b> 0.2.0<br>
<b>Raises</b> <code>Failure</code> if the matrix <code class="code">a</code> is singular.<br>
</div>
<div class="param_info"><code class="code">up</code> : default = <code class="code">true</code><ul>
<li>If <code class="code">up</code> = <code class="code">true</code>, then the upper triangular part of <code class="code">a</code> is used;</li>
<li>If <code class="code">up</code> = <code class="code">false</code>, then the lower triangular part of <code class="code">a</code> is used.</li>
</ul>
</div>
<div class="param_info"><code class="code">diag</code> : default = <code class="code">`N</code><ul>
<li>If <code class="code">diag</code> = <code class="code">`U</code>, then <code class="code">a</code> is unit triangular;</li>
<li>If <code class="code">diag</code> = <code class="code">`N</code>, then <code class="code">a</code> is not unit triangular.</li>
</ul>
</div>

<pre><span id="TYPEgeqrf_min_lwork"><span class="keyword">type</span> <code class="type">'n</code> geqrf_min_lwork</span> </pre>


<pre><span id="VALgeqrf_min_lwork"><span class="keyword">val</span> geqrf_min_lwork</span> : <code class="type">n:'n <a href="Slap_size.html#TYPEt">Slap_size.t</a> -> 'n <a href="Slap_S.html#TYPEgeqrf_min_lwork">geqrf_min_lwork</a> <a href="Slap_size.html#TYPEt">Slap_size.t</a></code></pre><div class="info ">
<code class="code">geqrf_min_lwork ~n</code> computes the minimum length of workspace for <code class="code">geqrf</code>
    routine. <code class="code">n</code> is the number of columns in a matrix.<br>
</div>

<pre><span id="VALgeqrf_opt_lwork"><span class="keyword">val</span> geqrf_opt_lwork</span> : <code class="type">('m, 'n, 'cd) <a href="Slap_S.html#TYPEmat">mat</a> -> (module Slap_size.SIZE)</code></pre><div class="info ">
<code class="code">geqrf_opt_lwork a</code> computes the optimum length of workspace for <code class="code">geqrf</code>
    routine.<br>
</div>

<pre><span id="VALgeqrf"><span class="keyword">val</span> geqrf</span> : <code class="type">?work:('lwork, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_S.html#TYPEvec">vec</a> -><br>       ?tau:(('m, 'n) <a href="Slap_size.html#TYPEmin">Slap_size.min</a>, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_S.html#TYPEvec">vec</a> -><br>       ('m, 'n, 'cd) <a href="Slap_S.html#TYPEmat">mat</a> -> (('m, 'n) <a href="Slap_size.html#TYPEmin">Slap_size.min</a>, 'cnt) <a href="Slap_S.html#TYPEvec">vec</a></code></pre><div class="info ">
<code class="code">geqrf ?work ?tau a</code> computes the QR factorization of general matrix <code class="code">a</code>:
    <code class="code">a = Q * R</code> where <code class="code">Q</code> is an orthogonal (unitary) matrix and <code class="code">R</code> is an
    upper triangular matrix. <code class="code">R</code> is returned in <code class="code">a</code>. This routine does not
    generate <code class="code">Q</code> explicitly. It is generated by <code class="code">orgqr</code>.<br>
<b>Returns</b> vector <code class="code">tau</code>, which is overwritten.<br>
</div>
<div class="param_info"><code class="code">work</code> : default = an optimum-length vector.</div>
<br>
<h3 id="3_Linearequationssimpledrivers">Linear equations (simple drivers)</h3><br>

<pre><span id="VALgesv"><span class="keyword">val</span> gesv</span> : <code class="type">?ipiv:('n, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_common.html#TYPEint32_vec">Slap_common.int32_vec</a> -><br>       ('n, 'n, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> ('n, 'nrhs, 'b_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> unit</code></pre><div class="info ">
<code class="code">gesv ?ipiv a b</code> solves a system of linear equations <code class="code">a * x = b</code> where <code class="code">a</code>
    is a <code class="code">'n</code>-by-<code class="code">'n</code> general matrix, each column of matrix <code class="code">b</code> is the r.h.s.
    vector, and each column of matrix <code class="code">x</code> is the corresponding solution.
<p>

    This routine uses LU factorization: <code class="code">a = P * L * U</code> with  permutation matrix
    <code class="code">P</code>, a lower triangular matrix <code class="code">L</code> and an upper triangular matrix <code class="code">U</code>.
    By this function, the upper triangular part of <code class="code">a</code> is replaced by <code class="code">U</code>, the
    lower triangular part by <code class="code">L</code>, and the solution <code class="code">x</code> is returned in <code class="code">b</code>.<br>
<b>Since</b> 0.2.0<br>
<b>Raises</b> <code>Failure</code> if the matrix is singular.<br>
</div>

<pre><span id="VALgbsv"><span class="keyword">val</span> gbsv</span> : <code class="type">?ipiv:('n, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_common.html#TYPEint32_vec">Slap_common.int32_vec</a> -><br>       (('n, 'n, 'kl, 'ku) <a href="Slap_size.html#TYPEluband">Slap_size.luband</a>, 'n, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a> -><br>       'kl <a href="Slap_size.html#TYPEt">Slap_size.t</a> -> 'ku <a href="Slap_size.html#TYPEt">Slap_size.t</a> -> ('n, 'nrhs, 'b_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> unit</code></pre><div class="info ">
<code class="code">gbsv ?ipiv ab kl ku b</code> solves a system of linear equations <code class="code">A * X = B</code>
    where <code class="code">A</code> is a <code class="code">'n</code>-by-<code class="code">'n</code> band matrix, each column of matrix <code class="code">B</code> is the
    r.h.s. vector, and each column of matrix <code class="code">X</code> is the corresponding solution.
    The matrix <code class="code">A</code> with <code class="code">kl</code> subdiagonals and <code class="code">ku</code> superdiagonals is stored into
    <code class="code">ab</code> in band storage format for LU factorizaion.
<p>

    This routine uses LU factorization: <code class="code">A = P * L * U</code> with  permutation matrix
    <code class="code">P</code>, a lower triangular matrix <code class="code">L</code> and an upper triangular matrix <code class="code">U</code>.
    By this function, the upper triangular part of <code class="code">A</code> is replaced by <code class="code">U</code>, the
    lower triangular part by <code class="code">L</code>, and the solution <code class="code">X</code> is returned in <code class="code">B</code>.<br>
<b>Since</b> 0.2.0<br>
<b>Raises</b> <code>Failure</code> if the matrix is singular.<br>
</div>

<pre><span id="VALposv"><span class="keyword">val</span> posv</span> : <code class="type">?up:bool -><br>       ('n, 'n, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> ('n, 'nrhs, 'b_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> unit</code></pre><div class="info ">
<code class="code">posv ?up a b</code> solves systems of linear equations <code class="code">a * x = b</code> where <code class="code">a</code> is
    a <code class="code">'n</code>-by-<code class="code">'n</code> symmetric positive-definite matrix, each column of matrix <code class="code">b</code>
    is the r.h.s vector, and each column of matrix <code class="code">x</code> is the corresponding
    solution. The solution <code class="code">x</code> is returned in <code class="code">b</code>.
<p>

    The Cholesky decomposition is used:
<p>
<ul>
<li>If <code class="code">up</code> = <code class="code">true</code>, then <code class="code">a = U^T * U</code> (real) or <code class="code">a = U^H * U</code> (complex)</li>
<li>If <code class="code">up</code> = <code class="code">false</code>, then <code class="code">a = L^T * L</code> (real) or <code class="code">a = L^H * L</code> (complex)</li>
</ul>

    where <code class="code">U</code> and <code class="code">L</code> are the upper and lower triangular matrices, respectively.<br>
<b>Since</b> 0.2.0<br>
<b>Raises</b> <code>Failure</code> if the matrix is singular.<br>
</div>
<div class="param_info"><code class="code">up</code> : default = <code class="code">true</code><ul>
<li>If <code class="code">up</code> = <code class="code">true</code>, then the upper triangular part of <code class="code">a</code> is used;</li>
<li>If <code class="code">up</code> = <code class="code">false</code>, then the lower triangular part of <code class="code">a</code> is used.</li>
</ul>
</div>

<pre><span id="VALppsv"><span class="keyword">val</span> ppsv</span> : <code class="type">?up:bool -><br>       ('n <a href="Slap_size.html#TYPEpacked">Slap_size.packed</a>, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_S.html#TYPEvec">vec</a> -><br>       ('n, 'nrhs, 'b_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> unit</code></pre><div class="info ">
<code class="code">ppsv ?up a b</code> solves systems of linear equations <code class="code">a * x = b</code> where <code class="code">a</code> is
    a <code class="code">'n</code>-by-<code class="code">'n</code> symmetric positive-definite matrix stored in packed format,
    each column of matrix <code class="code">b</code> is the r.h.s vector, and each column of matrix <code class="code">x</code>
    is the corresponding solution. The solution <code class="code">x</code> is returned in <code class="code">b</code>.
<p>

    The Cholesky decomposition is used:
<p>
<ul>
<li>If <code class="code">up</code> = <code class="code">true</code>, then <code class="code">a = U^T * U</code> (real) or <code class="code">a = U^H * U</code> (complex)</li>
<li>If <code class="code">up</code> = <code class="code">false</code>, then <code class="code">a = L^T * L</code> (real) or <code class="code">a = L^H * L</code> (complex)</li>
</ul>

    where <code class="code">U</code> and <code class="code">L</code> are the upper and lower triangular matrices, respectively.<br>
<b>Since</b> 0.2.0<br>
<b>Raises</b> <code>Failure</code> if the matrix is singular.<br>
</div>
<div class="param_info"><code class="code">up</code> : default = <code class="code">true</code><ul>
<li>If <code class="code">up</code> = <code class="code">true</code>, then the upper triangular part of <code class="code">a</code> is used;</li>
<li>If <code class="code">up</code> = <code class="code">false</code>, then the lower triangular part of <code class="code">a</code> is used.</li>
</ul>
</div>

<pre><span id="VALpbsv"><span class="keyword">val</span> pbsv</span> : <code class="type">?up:bool -><br>       kd:'kd <a href="Slap_size.html#TYPEt">Slap_size.t</a> -><br>       (('n, 'kd) <a href="Slap_size.html#TYPEsyband">Slap_size.syband</a>, 'n, 'ab_cd) <a href="Slap_S.html#TYPEmat">mat</a> -><br>       ('n, 'nrhs, 'b_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> unit</code></pre><div class="info ">
<code class="code">pbsv ?up ~kd ab b</code> solves systems of linear equations <code class="code">ab * x = b</code> where
    <code class="code">ab</code> is a <code class="code">'n</code>-by-<code class="code">'n</code> symmetric positive-definite band matrix with <code class="code">kd</code>
    subdiangonals, stored in band storage format, each column of matrix <code class="code">b</code> is
    the r.h.s vector, and each column of matrix <code class="code">x</code> is the corresponding
    solution. The solution <code class="code">x</code> is returned in <code class="code">b</code>.
<p>

    This routine uses the Cholesky decomposition:
<p>
<ul>
<li>If <code class="code">up</code> = <code class="code">true</code>, then <code class="code">ab = U^T * U</code> (real) or <code class="code">ab = U^H * U</code> (complex)</li>
<li>If <code class="code">up</code> = <code class="code">false</code>, then <code class="code">ab = L^T * L</code> (real) or <code class="code">ab = L^H * L</code> (complex)</li>
</ul>

    where <code class="code">U</code> and <code class="code">L</code> are the upper and lower triangular matrices, respectively.<br>
<b>Since</b> 0.2.0<br>
<b>Raises</b> <code>Failure</code> if the matrix is singular.<br>
</div>
<div class="param_info"><code class="code">up</code> : default = <code class="code">true</code><ul>
<li>If <code class="code">up</code> = <code class="code">true</code>, then the upper triangular part of <code class="code">ab</code> is used;</li>
<li>If <code class="code">up</code> = <code class="code">false</code>, then the lower triangular part of <code class="code">ab</code> is used.</li>
</ul>
</div>
<div class="param_info"><code class="code">kd</code> : the number of subdiagonals or superdiagonals in <code class="code">ab</code>.</div>

<pre><span id="VALptsv"><span class="keyword">val</span> ptsv</span> : <code class="type">('n, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_S.html#TYPEvec">vec</a> -><br>       ('n <a href="Slap_size.html#TYPEp">Slap_size.p</a>, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_S.html#TYPEvec">vec</a> -><br>       ('n, 'nrhs, 'b_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> unit</code></pre><div class="info ">
<code class="code">ptsv d e b</code> solves systems of linear equations <code class="code">A * x = b</code> where <code class="code">A</code> is a
    <code class="code">'n</code>-by-<code class="code">'n</code> symmetric positive-definite tridiagonal matrix with diagonal
    elements <code class="code">d</code> and subdiagonal elements <code class="code">e</code>, each column of matrix <code class="code">b</code> is the
    r.h.s vector, and each column of matrix <code class="code">x</code> is the corresponding solution.
    The solution <code class="code">x</code> is returned in <code class="code">b</code>.
<p>

    This routine uses the Cholesky decomposition: <code class="code">A = L^T * L</code> (real) or
    <code class="code">A = L^H * L</code> (complex) where <code class="code">L</code> is a lower triangular matrix.<br>
<b>Since</b> 0.2.0<br>
<b>Raises</b> <code>Failure</code> if the matrix is singular.<br>
</div>

<pre><span id="VALsysv_opt_lwork"><span class="keyword">val</span> sysv_opt_lwork</span> : <code class="type">?up:bool -><br>       ('n, 'n, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a> -><br>       ('n, 'nrhs, 'b_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> (module Slap_size.SIZE)</code></pre><div class="info ">
<code class="code">sysv_opt_lwork ?up a b</code> computes the optimal length of workspace for <code class="code">sysv</code>
    routine.<br>
</div>

<pre><span id="VALsysv"><span class="keyword">val</span> sysv</span> : <code class="type">?up:bool -><br>       ?ipiv:('n, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_common.html#TYPEint32_vec">Slap_common.int32_vec</a> -><br>       ?work:('lwork, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_S.html#TYPEvec">vec</a> -><br>       ('n, 'n, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> ('n, 'nrhs, 'b_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> unit</code></pre><div class="info ">
<code class="code">sysv ?up ?ipiv ?work a b</code> solves systems of linear equations <code class="code">a * x = b</code>
    where <code class="code">a</code> is a <code class="code">'n</code>-by-<code class="code">'n</code> symmetric matrix, each column of matrix <code class="code">b</code> is
    the r.h.s. vector, and each column of matrix <code class="code">x</code> is the corresponding
    solution. The solution <code class="code">x</code> is returned in <code class="code">b</code>.
<p>

    The diagonal pivoting method is used:<ul>
<li>If <code class="code">up</code> = <code class="code">true</code>, then <code class="code">a = U * D * U^T</code></li>
<li>If <code class="code">up</code> = <code class="code">false</code>, then <code class="code">a = L * D * L^T</code>
    where <code class="code">U</code> and <code class="code">L</code> are the upper and lower triangular matrices, respectively.</li>
</ul>
<br>
<b>Since</b> 0.2.0<br>
<b>Raises</b> <code>Failure</code> if the matrix is singular.<br>
</div>
<div class="param_info"><code class="code">up</code> : default = <code class="code">true</code><ul>
<li>If <code class="code">up</code> = <code class="code">true</code>, then the upper triangular part of <code class="code">a</code> is used;</li>
<li>If <code class="code">up</code> = <code class="code">false</code>, then the lower triangular part of <code class="code">a</code> is used.</li>
</ul>
</div>
<div class="param_info"><code class="code">ipiv</code> : a result of <code class="code">sytrf</code>. It is internally computed by <code class="code">sytrf</code> if
                omitted.</div>
<div class="param_info"><code class="code">work</code> : default = an optimum-length vector.</div>

<pre><span id="VALspsv"><span class="keyword">val</span> spsv</span> : <code class="type">?up:bool -><br>       ?ipiv:('n, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_common.html#TYPEint32_vec">Slap_common.int32_vec</a> -><br>       ('n <a href="Slap_size.html#TYPEpacked">Slap_size.packed</a>, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_S.html#TYPEvec">vec</a> -><br>       ('n, 'nrhs, 'b_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> unit</code></pre><div class="info ">
<code class="code">spsv ?up a b</code> solves systems of linear equations <code class="code">a * x = b</code> where <code class="code">a</code> is
    a <code class="code">'n</code>-by-<code class="code">'n</code> symmetric matrix stored in packed format, each column of
    matrix <code class="code">b</code> is the r.h.s. vector, and each column of matrix <code class="code">x</code> is the
    corresponding solution. The solution <code class="code">x</code> is returned in <code class="code">b</code>.
<p>

    The diagonal pivoting method is used:<ul>
<li>If <code class="code">up</code> = <code class="code">true</code>, then <code class="code">a = U * D * U^T</code></li>
<li>If <code class="code">up</code> = <code class="code">false</code>, then <code class="code">a = L * D * L^T</code>
    where <code class="code">U</code> and <code class="code">L</code> are the upper and lower triangular matrices, respectively.</li>
</ul>
<br>
<b>Since</b> 0.2.0<br>
<b>Raises</b> <code>Failure</code> if the matrix is singular.<br>
</div>
<div class="param_info"><code class="code">up</code> : default = <code class="code">true</code><ul>
<li>If <code class="code">up</code> = <code class="code">true</code>, then the upper triangular part of <code class="code">a</code> is used;</li>
<li>If <code class="code">up</code> = <code class="code">false</code>, then the lower triangular part of <code class="code">a</code> is used.</li>
</ul>
</div>
<div class="param_info"><code class="code">ipiv</code> : a result of <code class="code">sytrf</code>. It is internally computed by <code class="code">sytrf</code> if
                omitted.</div>
<br>
<h3 id="3_Leastsquaressimpledrivers">Least squares (simple drivers)</h3><br>

<pre><span id="TYPEgels_min_lwork"><span class="keyword">type</span> <code class="type">('m, 'n, 'nrhs)</code> gels_min_lwork</span> </pre>


<pre><span id="VALgels_min_lwork"><span class="keyword">val</span> gels_min_lwork</span> : <code class="type">m:'m <a href="Slap_size.html#TYPEt">Slap_size.t</a> -><br>       n:'n <a href="Slap_size.html#TYPEt">Slap_size.t</a> -><br>       nrhs:'nrhs <a href="Slap_size.html#TYPEt">Slap_size.t</a> -> ('m, 'n, 'nrhs) <a href="Slap_S.html#TYPEgels_min_lwork">gels_min_lwork</a> <a href="Slap_size.html#TYPEt">Slap_size.t</a></code></pre><div class="info ">
<code class="code">gels_min_lwork ~n</code> computes the minimum length of workspace for <code class="code">gels</code>
    routine.<br>
</div>
<div class="param_info"><code class="code">m</code> : the number of rows in a matrix.</div>
<div class="param_info"><code class="code">n</code> : the number of columns in a matrix.</div>
<div class="param_info"><code class="code">nrhs</code> : the number of right hand sides.</div>

<pre><span id="VALgels_opt_lwork"><span class="keyword">val</span> gels_opt_lwork</span> : <code class="type">trans:(('am, 'an, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> ('m, 'n, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a>)<br>             <a href="Slap_common.html#TYPEtrans2">Slap_common.trans2</a> -><br>       ('am, 'an, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a> -><br>       ('m, 'nrhs, 'b_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> (module Slap_size.SIZE)</code></pre><div class="info ">
<code class="code">gels_opt_lwork ~trans a b</code> computes the optimum length of workspace for
    <code class="code">gels</code> routine.<br>
</div>

<pre><span id="VALgels"><span class="keyword">val</span> gels</span> : <code class="type">?work:('work, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_S.html#TYPEvec">vec</a> -><br>       trans:(('am, 'an, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> ('m, 'n, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a>)<br>             <a href="Slap_common.html#TYPEtrans2">Slap_common.trans2</a> -><br>       ('am, 'an, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> ('m, 'nrhs, 'b_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> unit</code></pre><div class="info ">
<code class="code">gels ?work ~trans a b</code> solves an overdetermined or underdetermined system
    of linear equations using QR or LU factorization.
<p>
<ul>
<li>If <code class="code">trans</code> = <a href="Slap_common.html#VALnormal"><code class="code">Slap_common.normal</code></a> and <code class="code">'m &gt;= 'n</code>: find the least square
      solution to an overdetermined system by minimizing <code class="code">||b - A * x||^2</code>.</li>
<li>If <code class="code">trans</code> = <a href="Slap_common.html#VALnormal"><code class="code">Slap_common.normal</code></a> and <code class="code">'m &lt; 'n</code>: find the minimum norm
      solution to an underdetermined system <code class="code">a * x = b</code>.</li>
<li>If <code class="code">trans</code> = <a href="Slap_common.html#VALtrans"><code class="code">Slap_common.trans</code></a>, and <code class="code">'m &gt;= 'n</code>: find the minimum norm
      solution to an underdetermined system <code class="code">a^H * x = b</code>.</li>
<li>If <code class="code">trans</code> = <a href="Slap_common.html#VALtrans"><code class="code">Slap_common.trans</code></a> and <code class="code">'m &lt; 'n</code>: find the least square
      solution to an overdetermined system by minimizing <code class="code">||b - A^H * x||^2</code>.</li>
</ul>
<br>
</div>
<div class="param_info"><code class="code">work</code> : default = an optimum-length vector.</div>
<div class="param_info"><code class="code">trans</code> : the transpose flag for <code class="code">a</code>.</div>
<br>
<h2 id="2_BLASinterface">BLAS interface</h2><br>
<br>
<h2 id="2_BLASinterface">BLAS interface</h2><br>
<br>
<h3 id="3_Level1">Level 1</h3><br>

<pre><span id="VALdot"><span class="keyword">val</span> dot</span> : <code class="type">('n, 'x_cd) <a href="Slap_S.html#TYPEvec">vec</a> -> ('n, 'y_cd) <a href="Slap_S.html#TYPEvec">vec</a> -> float</code></pre><div class="info ">
<code class="code">dot x y</code><br>
<b>Returns</b> the inner product of the vectors <code class="code">x</code> and <code class="code">y</code>.<br>
</div>

<pre><span id="VALasum"><span class="keyword">val</span> asum</span> : <code class="type">('n, 'x_cd) <a href="Slap_S.html#TYPEvec">vec</a> -> float</code></pre><div class="info ">
<code class="code">asum x</code><br>
<b>Returns</b> the sum of absolute values of elements in the vector <code class="code">x</code>.<br>
</div>
<br>
<h3 id="3_Level2">Level 2</h3><br>

<pre><span id="VALsbmv"><span class="keyword">val</span> sbmv</span> : <code class="type">k:'k <a href="Slap_size.html#TYPEt">Slap_size.t</a> -><br>       ?y:('n, 'y_cd) <a href="Slap_S.html#TYPEvec">vec</a> -><br>       (('n, 'k) <a href="Slap_size.html#TYPEsyband">Slap_size.syband</a>, 'n, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a> -><br>       ?up:bool -><br>       ?alpha:float -><br>       ?beta:float -> ('n, 'x_cd) <a href="Slap_S.html#TYPEvec">vec</a> -> ('n, 'y_cd) <a href="Slap_S.html#TYPEvec">vec</a></code></pre><div class="info ">
<code class="code">sbmv ~k ?y a ?up ?alpha ?beta x</code> computes <code class="code">y := alpha * a * x + beta * y</code>
    where <code class="code">a</code> is a <code class="code">'n</code>-by-<code class="code">'n</code> symmetric band matrix with <code class="code">k</code>
    super-(or sub-)diagonals, and <code class="code">x</code> and <code class="code">y</code> are <code class="code">'n</code>-dimensional vectors.<br>
<b>Since</b> 0.2.0<br>
<b>Returns</b> vector <code class="code">y</code>, which is overwritten.<br>
</div>
<div class="param_info"><code class="code">k</code> : the number of superdiangonals or subdiangonals</div>
<div class="param_info"><code class="code">up</code> : default = <code class="code">true</code><ul>
<li>If <code class="code">up</code> = <code class="code">true</code>, then the upper triangular part of <code class="code">a</code> is used;</li>
<li>If <code class="code">up</code> = <code class="code">false</code>, then the lower triangular part of <code class="code">a</code> is used.</li>
</ul>
</div>
<div class="param_info"><code class="code">alpha</code> : default = <code class="code">1.0</code></div>
<div class="param_info"><code class="code">beta</code> : default = <code class="code">0.0</code></div>

<pre><span id="VALger"><span class="keyword">val</span> ger</span> : <code class="type">?alpha:float -><br>       ('m, 'x_cd) <a href="Slap_S.html#TYPEvec">vec</a> -><br>       ('n, 'y_cd) <a href="Slap_S.html#TYPEvec">vec</a> -><br>       ('m, 'n, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> ('m, 'n, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a></code></pre><div class="info ">
<code class="code">ger ?alpha x y a</code> computes <code class="code">a := alpha * x * y^T + a</code> with
    the general matrix <code class="code">a</code>, the vector <code class="code">x</code> and
    the transposed vector <code class="code">y^T</code> of <code class="code">y</code>.<br>
<b>Returns</b> matrix <code class="code">a</code>, which is overwritten.<br>
</div>
<div class="param_info"><code class="code">alpha</code> : default = <code class="code">1.0</code></div>

<pre><span id="VALsyr"><span class="keyword">val</span> syr</span> : <code class="type">?alpha:float -><br>       ?up:bool -><br>       ('n, 'x_cd) <a href="Slap_S.html#TYPEvec">vec</a> -><br>       ('n, 'n, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> ('n, 'n, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a></code></pre><div class="info ">
<code class="code">syr ?alpha x a</code> computes <code class="code">a := alpha * x * x^T + a</code> with
    the symmetric matrix <code class="code">a</code>, the vector <code class="code">x</code> and
    the transposed vector <code class="code">x^T</code> of <code class="code">x</code>.<br>
<b>Returns</b> matrix <code class="code">a</code>, which is overwritten.<br>
</div>
<div class="param_info"><code class="code">alpha</code> : default = <code class="code">1.0</code></div>
<div class="param_info"><code class="code">up</code> : default = <code class="code">true</code>, i.e., the upper triangular part of <code class="code">a</code> is
                 supplied.</div>
<br>
<h2 id="2_LAPACKinterface">LAPACK interface</h2><br>
<br>
<h2 id="2_LAPACKinterface">LAPACK interface</h2><br>
<br>
<h3 id="3_Auxiliaryroutines">Auxiliary routines</h3><br>
<br>
<h2 id="2_LAPACKinterface">LAPACK interface</h2><br>
<br>
<h3 id="3_Auxiliaryroutines">Auxiliary routines</h3><br>
<br>
<h4 id="4_lansy">lansy</h4><br>

<pre><span id="TYPElansy_min_lwork"><span class="keyword">type</span> <code class="type">('m, 'a)</code> lansy_min_lwork</span> </pre>


<pre><span id="VALlansy_min_lwork"><span class="keyword">val</span> lansy_min_lwork</span> : <code class="type">'n <a href="Slap_size.html#TYPEt">Slap_size.t</a> -><br>       'a <a href="Slap_common.html#TYPEnorm4">Slap_common.norm4</a> -> ('n, 'a) <a href="Slap_S.html#TYPElansy_min_lwork">lansy_min_lwork</a> <a href="Slap_size.html#TYPEt">Slap_size.t</a></code></pre><div class="info ">
<code class="code">lansy_min_lwork n norm</code> computes the minimum length of workspace for
    <code class="code">lansy</code> routine. <code class="code">n</code> is the number of rows or columns in a matrix.
    <code class="code">norm</code> is a matrix norm.<br>
</div>

<pre><span id="VALlansy"><span class="keyword">val</span> lansy</span> : <code class="type">?up:bool -><br>       ?norm:'norm <a href="Slap_common.html#TYPEnorm4">Slap_common.norm4</a> -><br>       ?work:('lwork, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_S.html#TYPEvec">vec</a> -> ('n, 'n, 'cd) <a href="Slap_S.html#TYPEmat">mat</a> -> float</code></pre><div class="info ">
<code class="code">lansy ?up ?norm ?work a</code><br>
<b>Returns</b> the norm of matrix <code class="code">a</code>.<br>
</div>
<div class="param_info"><code class="code">up</code> : default = <code class="code">true</code></div>
<div class="param_info"><code class="code">norm</code> : default = <a href="Slap_common.html#VALnorm_1"><code class="code">Slap_common.norm_1</code></a><ul>
<li>If <code class="code">norm</code> = <a href="Slap_common.html#VALnorm_1"><code class="code">Slap_common.norm_1</code></a>, the one norm is returned;</li>
<li>If <code class="code">norm</code> = <a href="Slap_common.html#VALnorm_inf"><code class="code">Slap_common.norm_inf</code></a>, the infinity norm is returned;</li>
<li>If <code class="code">norm</code> = <a href="Slap_common.html#VALnorm_amax"><code class="code">Slap_common.norm_amax</code></a>, the largest absolute value of
        elements in matrix <code class="code">a</code> (not a matrix norm) is returned;</li>
<li>If <code class="code">norm</code> = <a href="Slap_common.html#VALnorm_frob"><code class="code">Slap_common.norm_frob</code></a>, the Frobenius norm is returned.</li>
</ul>
</div>
<div class="param_info"><code class="code">work</code> : default = an optimum-length vector.</div>
<br>
<h4 id="4_lamch">lamch</h4><br>

<pre><span id="VALlamch"><span class="keyword">val</span> lamch</span> : <code class="type">[ `B | `E | `L | `M | `N | `O | `P | `R | `S | `U ] -> float</code></pre><div class="info ">
<code class="code">lamch cmach</code> see LAPACK documentation.<br>
</div>
<br>
<h3 id="3_Linearequationscomputationalroutines">Linear equations (computational routines)</h3><br>
<br>
<h3 id="3_Linearequationscomputationalroutines">Linear equations (computational routines)</h3><br>
<br>
<h4 id="4_orgqr">orgqr</h4><br>

<pre><span id="TYPEorgqr_min_lwork"><span class="keyword">type</span> <code class="type">'n</code> orgqr_min_lwork</span> </pre>


<pre><span id="VALorgqr_min_lwork"><span class="keyword">val</span> orgqr_min_lwork</span> : <code class="type">n:'n <a href="Slap_size.html#TYPEt">Slap_size.t</a> -> 'n <a href="Slap_S.html#TYPEorgqr_min_lwork">orgqr_min_lwork</a> <a href="Slap_size.html#TYPEt">Slap_size.t</a></code></pre><div class="info ">
<code class="code">orgqr_min_lwork ~n</code> computes the minimum length of workspace for
    <code class="code">orgqr</code> routine. <code class="code">n</code> is the number of columns in a matrix.<br>
</div>

<pre><span id="VALorgqr_opt_lwork"><span class="keyword">val</span> orgqr_opt_lwork</span> : <code class="type">tau:('k, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_S.html#TYPEvec">vec</a> -><br>       ('m, 'n, 'cd) <a href="Slap_S.html#TYPEmat">mat</a> -> (module Slap_size.SIZE)</code></pre><div class="info ">
<code class="code">orgqr_min_lwork ~tau a</code> computes the optimum length of workspace for
    <code class="code">orgqr</code> routine.<br>
</div>

<pre><span id="VALorgqr_dyn"><span class="keyword">val</span> orgqr_dyn</span> : <code class="type">?work:('lwork, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_S.html#TYPEvec">vec</a> -><br>       tau:('k, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_S.html#TYPEvec">vec</a> -> ('m, 'n, 'cd) <a href="Slap_S.html#TYPEmat">mat</a> -> unit</code></pre><div class="info ">
<code class="code">orgqr_dyn ?work ~tau a</code> generates the orthogonal matrix <code class="code">Q</code> of the QR
    factorization formed by <code class="code">geqrf</code>/<code class="code">geqpf</code>.<br>
<b>Raises</b> <code>Invalid_argument</code> if the following inequality is not satisfied:
                            <code class="code">(Mat.dim1 a) &gt;= (Mat.dim2 a) &gt;= (Vec.dim tau)</code>,
                            i.e., <code class="code">'m &gt;= 'n &gt;= 'k</code>.<br>
</div>
<div class="param_info"><code class="code">work</code> : default = an optimum-length vector</div>
<div class="param_info"><code class="code">tau</code> : a result of <code class="code">geqrf</code></div>
<br>
<h4 id="4_ormqr">ormqr</h4><br>

<pre><span id="TYPEormqr_min_lwork"><span class="keyword">type</span> <code class="type">('r, 'm, 'n)</code> ormqr_min_lwork</span> </pre>


<pre><span id="VALormqr_min_lwork"><span class="keyword">val</span> ormqr_min_lwork</span> : <code class="type">side:('r, 'm, 'n) <a href="Slap_common.html#TYPEside">Slap_common.side</a> -><br>       m:'m <a href="Slap_size.html#TYPEt">Slap_size.t</a> -><br>       n:'n <a href="Slap_size.html#TYPEt">Slap_size.t</a> -> ('r, 'm, 'n) <a href="Slap_S.html#TYPEormqr_min_lwork">ormqr_min_lwork</a> <a href="Slap_size.html#TYPEt">Slap_size.t</a></code></pre><div class="info ">
<code class="code">ormqr_min_lwork ~side ~m ~n</code> computes the minimum length of workspace for
    <code class="code">ormqr</code> routine.<br>
</div>
<div class="param_info"><code class="code">side</code> : the side flag to specify direction of matrix multiplication.</div>
<div class="param_info"><code class="code">m</code> : the number of rows in a matrix.</div>
<div class="param_info"><code class="code">n</code> : the number of columns in a matrix.</div>

<pre><span id="VALormqr_opt_lwork"><span class="keyword">val</span> ormqr_opt_lwork</span> : <code class="type">side:('r, 'm, 'n) <a href="Slap_common.html#TYPEside">Slap_common.side</a> -><br>       trans:(('r, 'r, 'a) <a href="Slap_S.html#TYPEmat">mat</a> -> ('r, 'r, 'b) <a href="Slap_S.html#TYPEmat">mat</a>) <a href="Slap_common.html#TYPEtrans2">Slap_common.trans2</a> -><br>       tau:('k, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_S.html#TYPEvec">vec</a> -><br>       ('r, 'k, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a> -><br>       ('m, 'n, 'c_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> (module Slap_size.SIZE)</code></pre><div class="info ">
<code class="code">ormqr_opt_lwork ~side ~trans ~tau a c</code> computes the optimum length of
    workspace for <code class="code">ormqr</code> routine.<br>
</div>
<div class="param_info"><code class="code">side</code> : the side flag to specify direction of matrix multiplication.</div>
<div class="param_info"><code class="code">trans</code> : the transpose flag for orthogonal matrix <code class="code">Q</code>.</div>
<div class="param_info"><code class="code">tau</code> : a result of <code class="code">geqrf</code>.</div>

<pre><span id="VALormqr_dyn"><span class="keyword">val</span> ormqr_dyn</span> : <code class="type">side:('r, 'm, 'n) <a href="Slap_common.html#TYPEside">Slap_common.side</a> -><br>       trans:(('r, 'r, 'a) <a href="Slap_S.html#TYPEmat">mat</a> -> ('r, 'r, 'b) <a href="Slap_S.html#TYPEmat">mat</a>) <a href="Slap_common.html#TYPEtrans2">Slap_common.trans2</a> -><br>       ?work:('lwork, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_S.html#TYPEvec">vec</a> -><br>       tau:('k, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_S.html#TYPEvec">vec</a> -><br>       ('r, 'k, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> ('m, 'n, 'c_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> unit</code></pre><div class="info ">
<code class="code">ormqr_dyn ~side ~trans ?work ~tau a c</code> multiplies a matrix <code class="code">c</code> by the
    orthogonal matrix <code class="code">Q</code> of the QR factorization formed by <code class="code">geqrf</code>/<code class="code">geqpf</code>:
<p>
<ul>
<li><code class="code">Q * c</code> if <code class="code">side</code> = <a href="Slap_common.html#VALleft"><code class="code">Slap_common.left</code></a> and
                 <code class="code">trans</code> = <a href="Slap_common.html#VALnormal"><code class="code">Slap_common.normal</code></a>;</li>
<li><code class="code">Q^T * c</code> if <code class="code">side</code> = <a href="Slap_common.html#VALleft"><code class="code">Slap_common.left</code></a> and
                   <code class="code">trans</code> = <a href="Slap_common.html#VALtrans"><code class="code">Slap_common.trans</code></a>;</li>
<li><code class="code">c * Q</code> if <code class="code">side</code> = <a href="Slap_common.html#VALright"><code class="code">Slap_common.right</code></a> and
                 <code class="code">trans</code> = <a href="Slap_common.html#VALnormal"><code class="code">Slap_common.normal</code></a>;</li>
<li><code class="code">c * Q^T</code> if <code class="code">side</code> = <a href="Slap_common.html#VALright"><code class="code">Slap_common.right</code></a> and
                   <code class="code">trans</code> = <a href="Slap_common.html#VALtrans"><code class="code">Slap_common.trans</code></a>.</li>
</ul>
<br>
<b>Raises</b> <code>Invalid_argument</code> if the following inequality is not satisfied:<ul>
<li><code class="code">'m &gt;= 'k</code> if <code class="code">side</code> = <a href="Slap_common.html#VALleft"><code class="code">Slap_common.left</code></a>;</li>
<li><code class="code">'n &gt;= 'k</code> if <code class="code">side</code> = <a href="Slap_common.html#VALright"><code class="code">Slap_common.right</code></a>.</li>
</ul>
<br>
</div>
<div class="param_info"><code class="code">side</code> : the side flag to specify direction of matrix multiplication of
                 <code class="code">Q</code> and <code class="code">c</code>.</div>
<div class="param_info"><code class="code">trans</code> : the transpose flag for orthogonal matrix <code class="code">Q</code>.</div>
<div class="param_info"><code class="code">work</code> : default = an optimum-length vector.</div>
<div class="param_info"><code class="code">tau</code> : a result of <code class="code">geqrf</code>.</div>
<br>
<h4 id="4_gecon">gecon</h4><br>

<pre><span id="TYPEgecon_min_lwork"><span class="keyword">type</span> <code class="type">'n</code> gecon_min_lwork</span> </pre>


<pre><span id="VALgecon_min_lwork"><span class="keyword">val</span> gecon_min_lwork</span> : <code class="type">'n <a href="Slap_size.html#TYPEt">Slap_size.t</a> -> 'n <a href="Slap_S.html#TYPEgecon_min_lwork">gecon_min_lwork</a> <a href="Slap_size.html#TYPEt">Slap_size.t</a></code></pre><div class="info ">
<code class="code">gecon_min_lwork n</code> computes the minimum length of workspace <code class="code">work</code> for
    <code class="code">gecon</code> routine. <code class="code">n</code> is the number of rows or columns in a matrix.<br>
</div>

<pre><span id="TYPEgecon_min_liwork"><span class="keyword">type</span> <code class="type">'n</code> gecon_min_liwork</span> </pre>


<pre><span id="VALgecon_min_liwork"><span class="keyword">val</span> gecon_min_liwork</span> : <code class="type">'n <a href="Slap_size.html#TYPEt">Slap_size.t</a> -> 'n <a href="Slap_S.html#TYPEgecon_min_liwork">gecon_min_liwork</a> <a href="Slap_size.html#TYPEt">Slap_size.t</a></code></pre><div class="info ">
<code class="code">gecon_min_liwork n</code> computes the minimum length of workspace <code class="code">iwork</code> for
    <code class="code">gecon</code> routine. <code class="code">n</code> is the number of rows or columns in a matrix.<br>
</div>

<pre><span id="VALgecon"><span class="keyword">val</span> gecon</span> : <code class="type">?norm:'a <a href="Slap_common.html#TYPEnorm2">Slap_common.norm2</a> -><br>       ?anorm:float -><br>       ?work:('lwork, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_S.html#TYPEvec">vec</a> -><br>       ?iwork:('liwork, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_common.html#TYPEint32_vec">Slap_common.int32_vec</a> -><br>       ('n, 'n, 'cd) <a href="Slap_S.html#TYPEmat">mat</a> -> float</code></pre><div class="info ">
<code class="code">gecon ?norm ?anorm ?work ?iwork a</code> estimates the reciprocal of the
    condition number of general matrix <code class="code">a</code>.<br>
</div>
<div class="param_info"><code class="code">norm</code> : default = <a href="Slap_common.html#VALnorm_1"><code class="code">Slap_common.norm_1</code></a>.<ul>
<li>If <code class="code">norm</code> = <a href="Slap_common.html#VALnorm_1"><code class="code">Slap_common.norm_1</code></a>, the one norm is returned;</li>
<li>If <code class="code">norm</code> = <a href="Slap_common.html#VALnorm_inf"><code class="code">Slap_common.norm_inf</code></a>, the infinity norm is returned.</li>
</ul>
</div>
<div class="param_info"><code class="code">anorm</code> : default = the norm of matrix <code class="code">a</code> as returned by <code class="code">lange</code>.</div>
<div class="param_info"><code class="code">work</code> : default = an optimum-length vector.</div>
<div class="param_info"><code class="code">iwork</code> : default = an optimum-length vector.</div>
<br>
<h4 id="4_sycon">sycon</h4><br>

<pre><span id="TYPEsycon_min_lwork"><span class="keyword">type</span> <code class="type">'n</code> sycon_min_lwork</span> </pre>


<pre><span id="VALsycon_min_lwork"><span class="keyword">val</span> sycon_min_lwork</span> : <code class="type">'n <a href="Slap_size.html#TYPEt">Slap_size.t</a> -> 'n <a href="Slap_S.html#TYPEsycon_min_lwork">sycon_min_lwork</a> <a href="Slap_size.html#TYPEt">Slap_size.t</a></code></pre><div class="info ">
<code class="code">sycon_min_lwork n</code> computes the minimum length of workspace <code class="code">work</code> for
    <code class="code">sycon</code> routine. <code class="code">n</code> is the number of rows or columns in a matrix.<br>
</div>

<pre><span id="TYPEsycon_min_liwork"><span class="keyword">type</span> <code class="type">'n</code> sycon_min_liwork</span> </pre>


<pre><span id="VALsycon_min_liwork"><span class="keyword">val</span> sycon_min_liwork</span> : <code class="type">'n <a href="Slap_size.html#TYPEt">Slap_size.t</a> -> 'n <a href="Slap_S.html#TYPEsycon_min_liwork">sycon_min_liwork</a> <a href="Slap_size.html#TYPEt">Slap_size.t</a></code></pre><div class="info ">
<code class="code">sycon_min_liwork n</code> computes the minimum length of workspace <code class="code">iwork</code> for
    <code class="code">sycon</code> routine. <code class="code">n</code> is the number of rows or columns in a matrix.<br>
</div>

<pre><span id="VALsycon"><span class="keyword">val</span> sycon</span> : <code class="type">?up:bool -><br>       ?ipiv:('n, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_common.html#TYPEint32_vec">Slap_common.int32_vec</a> -><br>       ?anorm:float -><br>       ?work:('lwork, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_S.html#TYPEvec">vec</a> -><br>       ?iwork:('liwork, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_common.html#TYPEint32_vec">Slap_common.int32_vec</a> -><br>       ('n, 'n, 'cd) <a href="Slap_S.html#TYPEmat">mat</a> -> float</code></pre><div class="info ">
<code class="code">sycon ?up ?ipiv ?anorm ?work ?iwork a</code> estimates the reciprocal of the
    condition number of symmetric matrix <code class="code">a</code>. Since <code class="code">a</code> is symmetric, the
    1-norm is equal to the infinity norm.<br>
</div>
<div class="param_info"><code class="code">up</code> : default = <code class="code">true</code><ul>
<li>If <code class="code">up</code> = <code class="code">true</code>, then the upper triangular part of <code class="code">a</code> is used;</li>
<li>If <code class="code">up</code> = <code class="code">false</code>, then the lower triangular part of <code class="code">a</code> is used.</li>
</ul>
</div>
<div class="param_info"><code class="code">ipiv</code> : a result of <code class="code">sytrf</code>. It is internally computed by <code class="code">sytrf</code> if
                omitted.</div>
<div class="param_info"><code class="code">anorm</code> : default = the norm of matrix <code class="code">a</code> as returned by <code class="code">lange</code>.</div>
<div class="param_info"><code class="code">work</code> : default = an optimum-length vector.</div>
<div class="param_info"><code class="code">iwork</code> : default = an optimum-length vector.</div>
<br>
<h4 id="4_pocon">pocon</h4><br>

<pre><span id="TYPEpocon_min_lwork"><span class="keyword">type</span> <code class="type">'n</code> pocon_min_lwork</span> </pre>


<pre><span id="VALpocon_min_lwork"><span class="keyword">val</span> pocon_min_lwork</span> : <code class="type">'n <a href="Slap_size.html#TYPEt">Slap_size.t</a> -> 'n <a href="Slap_S.html#TYPEpocon_min_lwork">pocon_min_lwork</a> <a href="Slap_size.html#TYPEt">Slap_size.t</a></code></pre><div class="info ">
<code class="code">pocon_min_lwork n</code> computes the minimum length of workspace <code class="code">work</code> for
    <code class="code">pocon</code> routine. <code class="code">n</code> is the number of rows or columns in a matrix.<br>
</div>

<pre><span id="TYPEpocon_min_liwork"><span class="keyword">type</span> <code class="type">'n</code> pocon_min_liwork</span> </pre>


<pre><span id="VALpocon_min_liwork"><span class="keyword">val</span> pocon_min_liwork</span> : <code class="type">'n <a href="Slap_size.html#TYPEt">Slap_size.t</a> -> 'n <a href="Slap_S.html#TYPEpocon_min_liwork">pocon_min_liwork</a> <a href="Slap_size.html#TYPEt">Slap_size.t</a></code></pre><div class="info ">
<code class="code">pocon_min_liwork n</code> computes the minimum length of workspace <code class="code">iwork</code> for
    <code class="code">pocon</code> routine. <code class="code">n</code> is the number of rows or columns in a matrix.<br>
</div>

<pre><span id="VALpocon"><span class="keyword">val</span> pocon</span> : <code class="type">?up:bool -><br>       ?anorm:float -><br>       ?work:('lwork, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_S.html#TYPEvec">vec</a> -><br>       ?iwork:('liwork, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_common.html#TYPEint32_vec">Slap_common.int32_vec</a> -><br>       ('n, 'n, 'cd) <a href="Slap_S.html#TYPEmat">mat</a> -> float</code></pre><div class="info ">
<code class="code">pocon ?up ?anorm ?work ?iwork a</code> estimates the reciprocal of the
    condition number of symmetric positive-definite matrix <code class="code">a</code>.
    Since <code class="code">a</code> is symmetric, the 1-norm is equal to the infinity norm.<br>
</div>
<div class="param_info"><code class="code">up</code> : default = <code class="code">true</code><ul>
<li>If <code class="code">up</code> = <code class="code">true</code>, then the upper triangular part of <code class="code">a</code> is used;</li>
<li>If <code class="code">up</code> = <code class="code">false</code>, then the lower triangular part of <code class="code">a</code> is used.</li>
</ul>
</div>
<div class="param_info"><code class="code">anorm</code> : default = the norm of matrix <code class="code">a</code> as returned by <code class="code">lange</code>.</div>
<div class="param_info"><code class="code">work</code> : default = an optimum-length vector.</div>
<div class="param_info"><code class="code">iwork</code> : default = an optimum-length vector.</div>
<br>
<h3 id="3_Leastsquaresexpertdrivers">Least squares (expert drivers)</h3><br>
<br>
<h3 id="3_Leastsquaresexpertdrivers">Least squares (expert drivers)</h3><br>
<br>
<h4 id="4_gelsy">gelsy</h4><br>

<pre><span id="TYPEgelsy_min_lwork"><span class="keyword">type</span> <code class="type">('m, 'n, 'nrhs)</code> gelsy_min_lwork</span> </pre>


<pre><span id="VALgelsy_min_lwork"><span class="keyword">val</span> gelsy_min_lwork</span> : <code class="type">m:'m <a href="Slap_size.html#TYPEt">Slap_size.t</a> -><br>       n:'n <a href="Slap_size.html#TYPEt">Slap_size.t</a> -><br>       nrhs:'nrhs <a href="Slap_size.html#TYPEt">Slap_size.t</a> -> ('m, 'n, 'nrhs) <a href="Slap_S.html#TYPEgelsy_min_lwork">gelsy_min_lwork</a> <a href="Slap_size.html#TYPEt">Slap_size.t</a></code></pre><div class="info ">
<code class="code">gelsy_min_lwork ~m ~n ~nrhs</code> computes the minimum length of workspace for
    <code class="code">gelsy</code> routine.<br>
</div>
<div class="param_info"><code class="code">m</code> : the number of rows in a matrix.</div>
<div class="param_info"><code class="code">n</code> : the number of columns in a matrix.</div>
<div class="param_info"><code class="code">nrhs</code> : the number of right hand sides.</div>

<pre><span id="VALgelsy_opt_lwork"><span class="keyword">val</span> gelsy_opt_lwork</span> : <code class="type">('m, 'n, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a> -><br>       ('n, 'nrhs, 'b_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> (module Slap_size.SIZE)</code></pre><div class="info ">
<code class="code">gelsy_opt_lwork a b</code> computes the optimum length of workspace for
    <code class="code">gelsy</code> routine.<br>
</div>

<pre><span id="VALgelsy"><span class="keyword">val</span> gelsy</span> : <code class="type">('m, 'n, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a> -><br>       ?rcond:float -><br>       ?jpvt:('n, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_common.html#TYPEint32_vec">Slap_common.int32_vec</a> -><br>       ?work:('lwork, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_S.html#TYPEvec">vec</a> -><br>       ('n, 'nrhs, 'b_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> int</code></pre><div class="info ">
<code class="code">gelsy a ?rcond ?jpvt ?work b</code> computes the minimum-norm solution to a
    linear least square problem (minimize <code class="code">||b - a * x||</code>) using a complete
    orthogonal factorization of <code class="code">a</code>.<br>
<b>Returns</b> the effective rank of <code class="code">a</code>.<br>
</div>
<div class="param_info"><code class="code">rcond</code> : default = <code class="code">-1.0</code> (machine precision)</div>
<div class="param_info"><code class="code">jpvt</code> : default = a <code class="code">'n</code>-dimensional vector.</div>
<div class="param_info"><code class="code">work</code> : default = an optimum-length vector.</div>
<br>
<h4 id="4_gelsd">gelsd</h4><br>

<pre><span id="TYPEgelsd_min_lwork"><span class="keyword">type</span> <code class="type">('m, 'n, 'nrhs)</code> gelsd_min_lwork</span> </pre>


<pre><span id="VALgelsd_min_lwork"><span class="keyword">val</span> gelsd_min_lwork</span> : <code class="type">m:'m <a href="Slap_size.html#TYPEt">Slap_size.t</a> -><br>       n:'n <a href="Slap_size.html#TYPEt">Slap_size.t</a> -><br>       nrhs:'nrhs <a href="Slap_size.html#TYPEt">Slap_size.t</a> -> ('m, 'n, 'nrhs) <a href="Slap_S.html#TYPEgelsd_min_lwork">gelsd_min_lwork</a> <a href="Slap_size.html#TYPEt">Slap_size.t</a></code></pre><div class="info ">
<code class="code">gelsd_min_lwork ~m ~n ~nrhs</code> computes the minimum length of workspace for
    <code class="code">gelsd</code> routine.<br>
</div>
<div class="param_info"><code class="code">m</code> : the number of rows in a matrix.</div>
<div class="param_info"><code class="code">n</code> : the number of columns in a matrix.</div>
<div class="param_info"><code class="code">nrhs</code> : the number of right hand sides.</div>

<pre><span id="VALgelsd_opt_lwork"><span class="keyword">val</span> gelsd_opt_lwork</span> : <code class="type">('m, 'n, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a> -><br>       ('n, 'nrhs, 'b_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> (module Slap_size.SIZE)</code></pre><div class="info ">
<code class="code">gelsd_opt_lwork a b</code> computes the optimum length of workspace for
    <code class="code">gelsd</code> routine.<br>
</div>

<pre><span id="TYPEgelsd_min_iwork"><span class="keyword">type</span> <code class="type">('m, 'n, 'nrhs)</code> gelsd_min_iwork</span> </pre>


<pre><span id="VALgelsd_min_iwork"><span class="keyword">val</span> gelsd_min_iwork</span> : <code class="type">'m <a href="Slap_size.html#TYPEt">Slap_size.t</a> -><br>       'n <a href="Slap_size.html#TYPEt">Slap_size.t</a> -> ('m, 'n, 'nrhs) <a href="Slap_S.html#TYPEgelsd_min_iwork">gelsd_min_iwork</a> <a href="Slap_size.html#TYPEt">Slap_size.t</a></code></pre><div class="info ">
<code class="code">gelsd_min_iwork ~m ~n ~nrhs</code> computes the minimum length of workspace
    <code class="code">iwork</code> for <code class="code">gelsd</code> routine.<br>
</div>

<pre><span id="VALgelsd"><span class="keyword">val</span> gelsd</span> : <code class="type">('m, 'n, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a> -><br>       ?rcond:float -><br>       ?s:(('m, 'n) <a href="Slap_size.html#TYPEmin">Slap_size.min</a>, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_S.html#TYPEvec">vec</a> -><br>       ?work:('lwork, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_S.html#TYPEvec">vec</a> -><br>       ?iwork:('liwork, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_S.html#TYPEvec">vec</a> -><br>       ('n, 'nrhs, 'b_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> int</code></pre><div class="info ">
<code class="code">gelsd a ?rcond ?jpvt ?work b</code> computes the minimum-norm solution to a
    linear least square problem (minimize <code class="code">||b - a * x||</code>) using the singular
    value decomposition (SVD) of <code class="code">a</code> and a divide and conquer method.<br>
<b>Raises</b> <code>Failure</code> if the function fails to converge.<br>
<b>Returns</b> the effective rank of <code class="code">a</code>.<br>
</div>
<div class="param_info"><code class="code">rcond</code> : default = <code class="code">-1.0</code> (machine precision)</div>
<div class="param_info"><code class="code">s</code> : the singular values of <code class="code">a</code> in decreasing order.
                 They are implicitly computed if omitted.</div>
<div class="param_info"><code class="code">work</code> : default = an optimum-length vector.</div>
<div class="param_info"><code class="code">iwork</code> : default = an optimum-length vector.</div>
<br>
<h4 id="4_gelss">gelss</h4><br>

<pre><span id="TYPEgelss_min_lwork"><span class="keyword">type</span> <code class="type">('m, 'n, 'nrhs)</code> gelss_min_lwork</span> </pre>


<pre><span id="VALgelss_min_lwork"><span class="keyword">val</span> gelss_min_lwork</span> : <code class="type">m:'m <a href="Slap_size.html#TYPEt">Slap_size.t</a> -><br>       n:'n <a href="Slap_size.html#TYPEt">Slap_size.t</a> -><br>       nrhs:'nrhs <a href="Slap_size.html#TYPEt">Slap_size.t</a> -> ('m, 'n, 'nrhs) <a href="Slap_S.html#TYPEgelss_min_lwork">gelss_min_lwork</a> <a href="Slap_size.html#TYPEt">Slap_size.t</a></code></pre><div class="info ">
<code class="code">gelss_min_lwork ~m ~n ~nrhs</code> computes the minimum length of workspace for
    <code class="code">gelss</code> routine.<br>
</div>
<div class="param_info"><code class="code">m</code> : the number of rows in a matrix.</div>
<div class="param_info"><code class="code">n</code> : the number of columns in a matrix.</div>
<div class="param_info"><code class="code">nrhs</code> : the number of right hand sides.</div>

<pre><span id="VALgelss_opt_lwork"><span class="keyword">val</span> gelss_opt_lwork</span> : <code class="type">('m, 'n, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a> -><br>       ('n, 'nrhs, 'b_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> (module Slap_size.SIZE)</code></pre><div class="info ">
<code class="code">gelss_min_lwork a b</code> computes the optimum length of workspace for
    <code class="code">gelss</code> routine.<br>
</div>

<pre><span id="VALgelss"><span class="keyword">val</span> gelss</span> : <code class="type">('m, 'n, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a> -><br>       ?rcond:float -><br>       ?s:(('m, 'n) <a href="Slap_size.html#TYPEmin">Slap_size.min</a>, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_S.html#TYPEvec">vec</a> -><br>       ?work:('lwork, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_S.html#TYPEvec">vec</a> -><br>       ('n, 'nrhs, 'b_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> int</code></pre><div class="info ">
<code class="code">gelss a ?rcond ?work b</code> computes the minimum-norm solution to a
    linear least square problem (minimize <code class="code">||b - a * x||</code>) using the singular
    value decomposition (SVD) of <code class="code">a</code>.<br>
<b>Raises</b> <code>Failure</code> if the function fails to converge.<br>
<b>Returns</b> the effective rank of <code class="code">a</code>.<br>
</div>
<div class="param_info"><code class="code">rcond</code> : default = <code class="code">-1.0</code> (machine precision)</div>
<div class="param_info"><code class="code">s</code> : the singular values of <code class="code">a</code> in decreasing order.
                 They are implicitly computed if omitted.</div>
<div class="param_info"><code class="code">work</code> : default = an optimum-length vector.</div>
<br>
<h3 id="3_GeneralSVDroutines">General SVD routines</h3><br>
<br>
<h3 id="3_GeneralSVDroutines">General SVD routines</h3><br>
<br>
<h4 id="4_gesvd">gesvd</h4><br>

<pre><span id="TYPEgesvd_min_lwork"><span class="keyword">type</span> <code class="type">('m, 'n)</code> gesvd_min_lwork</span> </pre>


<pre><span id="VALgesvd_min_lwork"><span class="keyword">val</span> gesvd_min_lwork</span> : <code class="type">m:'m <a href="Slap_size.html#TYPEt">Slap_size.t</a> -><br>       n:'n <a href="Slap_size.html#TYPEt">Slap_size.t</a> -> ('m, 'n) <a href="Slap_S.html#TYPEgesvd_min_lwork">gesvd_min_lwork</a> <a href="Slap_size.html#TYPEt">Slap_size.t</a></code></pre><div class="info ">
<code class="code">gesvd_min_lwork ~m ~n</code> computes the minimum length of workspace for
    <code class="code">gesvd</code> routine.<br>
</div>
<div class="param_info"><code class="code">m</code> : the number of rows in a matrix.</div>
<div class="param_info"><code class="code">n</code> : the number of columns in a matrix.</div>

<pre><span id="VALgesvd_opt_lwork"><span class="keyword">val</span> gesvd_opt_lwork</span> : <code class="type">jobu:('u_cols, 'm, ('m, 'n) <a href="Slap_size.html#TYPEmin">Slap_size.min</a>, <a href="Slap_size.html#TYPEz">Slap_size.z</a>, <a href="Slap_size.html#TYPEz">Slap_size.z</a>)<br>            <a href="Slap_common.html#TYPEsvd_job">Slap_common.svd_job</a> -><br>       jobvt:('vt_rows, 'n, ('m, 'n) <a href="Slap_size.html#TYPEmin">Slap_size.min</a>, <a href="Slap_size.html#TYPEz">Slap_size.z</a>, <a href="Slap_size.html#TYPEz">Slap_size.z</a>)<br>             <a href="Slap_common.html#TYPEsvd_job">Slap_common.svd_job</a> -><br>       ?s:(('m, 'n) <a href="Slap_size.html#TYPEmin">Slap_size.min</a>, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_S.html#TYPEvec">vec</a> -><br>       ?u:('m, 'u_cols, 'u_cd) <a href="Slap_S.html#TYPEmat">mat</a> -><br>       ?vt:('vt_rows, 'n, 'vt_cd) <a href="Slap_S.html#TYPEmat">mat</a> -><br>       ('m, 'n, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> (module Slap_size.SIZE)</code></pre><div class="info ">
<code class="code">gesvd_opt_lwork ~jobu ~jobvt ?s ?u ?vt</code> computes the optimum length of
    workspace for <code class="code">gesvd</code> routine.<br>
</div>
<div class="param_info"><code class="code">jobu</code> : the SVD job flag for <code class="code">u</code>.</div>
<div class="param_info"><code class="code">jobvt</code> : the SVD job flag for <code class="code">vt</code>.</div>
<div class="param_info"><code class="code">s</code> : a return location for singular values.</div>
<div class="param_info"><code class="code">u</code> : a return location for left singular vectors.</div>
<div class="param_info"><code class="code">vt</code> : a return location for (transposed) right singular vectors.</div>

<pre><span id="VALgesvd"><span class="keyword">val</span> gesvd</span> : <code class="type">jobu:('u_cols, 'm, ('m, 'n) <a href="Slap_size.html#TYPEmin">Slap_size.min</a>, <a href="Slap_size.html#TYPEz">Slap_size.z</a>, <a href="Slap_size.html#TYPEz">Slap_size.z</a>)<br>            <a href="Slap_common.html#TYPEsvd_job">Slap_common.svd_job</a> -><br>       jobvt:('vt_rows, 'n, ('m, 'n) <a href="Slap_size.html#TYPEmin">Slap_size.min</a>, <a href="Slap_size.html#TYPEz">Slap_size.z</a>, <a href="Slap_size.html#TYPEz">Slap_size.z</a>)<br>             <a href="Slap_common.html#TYPEsvd_job">Slap_common.svd_job</a> -><br>       ?s:(('m, 'n) <a href="Slap_size.html#TYPEmin">Slap_size.min</a>, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_S.html#TYPEvec">vec</a> -><br>       ?u:('m, 'u_cols, 'u_cd) <a href="Slap_S.html#TYPEmat">mat</a> -><br>       ?vt:('vt_rows, 'n, 'vt_cd) <a href="Slap_S.html#TYPEmat">mat</a> -><br>       ?work:('lwork, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_S.html#TYPEvec">vec</a> -><br>       ('m, 'n, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a> -><br>       (('m, 'n) <a href="Slap_size.html#TYPEmin">Slap_size.min</a>, 'cnt) <a href="Slap_S.html#TYPEvec">vec</a> * ('m, 'u_cols, 'cnt) <a href="Slap_S.html#TYPEmat">mat</a> *<br>       ('vt_rows, 'n, 'cnt) <a href="Slap_S.html#TYPEmat">mat</a></code></pre><div class="info ">
<code class="code">gesvd ?jobu ?jobvt ?s ?u ?vt ?work a</code> computes the singular value
    decomposition (SVD) of <code class="code">'m</code>-by-<code class="code">'n</code> general rectangular matrix <code class="code">a</code>:
    <code class="code">a = U * D * V^T</code> where
<p>
<ul>
<li><code class="code">D</code> is an <code class="code">'m</code>-by-<code class="code">'n</code> matrix (the diagonal elements in <code class="code">D</code> are singular
      values in descreasing order, and other elements are zeros),</li>
<li><code class="code">U</code> is an <code class="code">'m</code>-by-<code class="code">'m</code> orthogonal matrix (the columns in <code class="code">U</code> are left
      singular vectors), and</li>
<li><code class="code">V</code> is an <code class="code">'n</code>-by-<code class="code">'n</code> orthogonal matrix (the columns in <code class="code">V</code> are right
      singular vectors).</li>
</ul>
<br>
<b>Returns</b> <code class="code">(s, u, vt)</code> with singular values <code class="code">s</code> in descreasing order,
            left singular vectors <code class="code">u</code> and right singular vectors <code class="code">vt</code>.<br>
</div>
<div class="param_info"><code class="code">jobu</code> : the SVD job flag for <code class="code">u</code>:<ul>
<li>If <code class="code">jobu</code> = <a href="Slap_common.html#VALsvd_all"><code class="code">Slap_common.svd_all</code></a>, then all <code class="code">'m</code> columns of <code class="code">U</code> are
        returned in <code class="code">u</code>. (<code class="code">'u_cols</code> = <code class="code">'m</code>.)</li>
<li>If <code class="code">jobu</code> = <a href="Slap_common.html#VALsvd_top"><code class="code">Slap_common.svd_top</code></a>, then the first <code class="code">('m, 'n) min</code>
        columns of <code class="code">U</code> are returned in <code class="code">u</code>. (<code class="code">'u_cols</code> = <code class="code">('m, 'n) min</code>.)</li>
<li>If <code class="code">jobu</code> = <a href="Slap_common.html#VALsvd_overwrite"><code class="code">Slap_common.svd_overwrite</code></a>, then the first <code class="code">('m, 'n) min</code>
        columns of <code class="code">U</code> are overwritten on <code class="code">a</code>. (<code class="code">'u_cols</code> = <code class="code">z</code> since <code class="code">u</code>
        is unused.)</li>
<li>If <code class="code">jobu</code> = <a href="Slap_common.html#VALsvd_no"><code class="code">Slap_common.svd_no</code></a>, then no columns of <code class="code">U</code> are computed.
        (<code class="code">'u_cols</code> = <code class="code">z</code>.)</li>
</ul>
</div>
<div class="param_info"><code class="code">jobvt</code> : the SVD job flag for <code class="code">vt</code>:<ul>
<li>If <code class="code">jobvt</code> = <a href="Slap_common.html#VALsvd_all"><code class="code">Slap_common.svd_all</code></a>, then all <code class="code">'n</code> rows of <code class="code">V^T</code> are
        returned in <code class="code">vt</code>. (<code class="code">'vt_rows</code> = <code class="code">'n</code>.)</li>
<li>If <code class="code">jobvt</code> = <a href="Slap_common.html#VALsvd_top"><code class="code">Slap_common.svd_top</code></a>, then the first <code class="code">('m, 'n) min</code>
        rows of <code class="code">V^T</code> are returned in <code class="code">vt</code>. (<code class="code">'vt_rows</code> = <code class="code">('m, 'n) min</code>.)</li>
<li>If <code class="code">jobvt</code> = <a href="Slap_common.html#VALsvd_overwrite"><code class="code">Slap_common.svd_overwrite</code></a>, then the first <code class="code">('m, 'n) min</code>
        rows of <code class="code">V^T</code> are overwritten on <code class="code">a</code>. (<code class="code">'vt_cols</code> = <code class="code">z</code> since <code class="code">vt</code>
        is unused.)</li>
<li>If <code class="code">jobvt</code> = <a href="Slap_common.html#VALsvd_no"><code class="code">Slap_common.svd_no</code></a>, then no columns of <code class="code">V^T</code> are
        computed. (<code class="code">'vt_cols</code> = <code class="code">z</code>.)</li>
</ul>
</div>
<div class="param_info"><code class="code">s</code> : a return location for singular values.
                (default = an implicitly allocated vector.)</div>
<div class="param_info"><code class="code">u</code> : a return location for left singular vectors.
                (default = an implicitly allocated matrix.)</div>
<div class="param_info"><code class="code">vt</code> : a return location for (transposed) right singular vectors.
                (default = an implicitly allocated matrix.)</div>
<div class="param_info"><code class="code">work</code> : default = an optimum-length vector.
<p>

    (<b>Note</b>: <code class="code">jobu</code> and <code class="code">jobvt</code> cannot both be <a href="Slap_common.html#VALsvd_overwrite"><code class="code">Slap_common.svd_overwrite</code></a>.)</div>
<br>
<h4 id="4_gesdd">gesdd</h4><br>

<pre><span id="TYPEgesdd_liwork"><span class="keyword">type</span> <code class="type">('m, 'n)</code> gesdd_liwork</span> </pre>


<pre><span id="VALgesdd_liwork"><span class="keyword">val</span> gesdd_liwork</span> : <code class="type">m:'m <a href="Slap_size.html#TYPEt">Slap_size.t</a> -><br>       n:'n <a href="Slap_size.html#TYPEt">Slap_size.t</a> -> ('m, 'n) <a href="Slap_S.html#TYPEgesdd_liwork">gesdd_liwork</a> <a href="Slap_size.html#TYPEt">Slap_size.t</a></code></pre><div class="info ">
<code class="code">gesdd_liwork ~m ~n</code> computes the length of workspace <code class="code">iwork</code> for
    <code class="code">gesdd</code> routine.<br>
</div>
<div class="param_info"><code class="code">m</code> : the number of rows in a matrix.</div>
<div class="param_info"><code class="code">n</code> : the number of columns in a matrix.</div>

<pre><span id="TYPEgesdd_min_lwork"><span class="keyword">type</span> <code class="type">('m, 'n, 'jobz)</code> gesdd_min_lwork</span> </pre>


<pre><span id="VALgesdd_min_lwork"><span class="keyword">val</span> gesdd_min_lwork</span> : <code class="type">jobz:('u_cols * 'vt_rows, 'm * 'n,<br>             ('m, 'n) <a href="Slap_size.html#TYPEmin">Slap_size.min</a> * ('m, 'n) <a href="Slap_size.html#TYPEmin">Slap_size.min</a>, 'm * 'n,<br>             <a href="Slap_size.html#TYPEz">Slap_size.z</a> * <a href="Slap_size.html#TYPEz">Slap_size.z</a>)<br>            <a href="Slap_common.html#TYPEsvd_job">Slap_common.svd_job</a> -><br>       m:'m <a href="Slap_size.html#TYPEt">Slap_size.t</a> -><br>       n:'n <a href="Slap_size.html#TYPEt">Slap_size.t</a> -><br>       unit -> ('m, 'n, 'u_cols * 'vt_rows) <a href="Slap_S.html#TYPEgesdd_min_lwork">gesdd_min_lwork</a> <a href="Slap_size.html#TYPEt">Slap_size.t</a></code></pre><div class="info ">
<code class="code">gesdd_min_lwork ~m ~n</code> computes the minimum length of workspace <code class="code">work</code> for
    <code class="code">gesdd</code> routine.<br>
</div>
<div class="param_info"><code class="code">jobz</code> : the SVD job flag.</div>
<div class="param_info"><code class="code">m</code> : the number of rows in a matrix.</div>
<div class="param_info"><code class="code">n</code> : the number of columns in a matrix.</div>

<pre><span id="VALgesdd_opt_lwork"><span class="keyword">val</span> gesdd_opt_lwork</span> : <code class="type">jobz:('u_cols * 'vt_rows, 'm * 'n,<br>             ('m, 'n) <a href="Slap_size.html#TYPEmin">Slap_size.min</a> * ('m, 'n) <a href="Slap_size.html#TYPEmin">Slap_size.min</a>, 'm * 'n,<br>             <a href="Slap_size.html#TYPEz">Slap_size.z</a> * <a href="Slap_size.html#TYPEz">Slap_size.z</a>)<br>            <a href="Slap_common.html#TYPEsvd_job">Slap_common.svd_job</a> -><br>       ?s:(('m, 'n) <a href="Slap_size.html#TYPEmin">Slap_size.min</a>, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_S.html#TYPEvec">vec</a> -><br>       ?u:('m, 'u_cols, 'u_cd) <a href="Slap_S.html#TYPEmat">mat</a> -><br>       ?vt:('vt_rows, 'n, 'vt_cd) <a href="Slap_S.html#TYPEmat">mat</a> -><br>       ?iwork:('liwork, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_common.html#TYPEint32_vec">Slap_common.int32_vec</a> -><br>       ('m, 'n, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> (module Slap_size.SIZE)</code></pre><div class="info ">
<code class="code">gesdd_opt_lwork ~jobz ?s ?u ?vt ?iwork a</code> computes the optimum length of
    workspace <code class="code">work</code> for <code class="code">gesdd</code> routine.<br>
</div>
<div class="param_info"><code class="code">jobz</code> : the SVD job flag.</div>
<div class="param_info"><code class="code">s</code> : a return location for singular values.
                 (default = an implicitly allocated vector.)</div>
<div class="param_info"><code class="code">u</code> : a return location for left singular vectors.
                 (default = an implicitly allocated matrix.)</div>
<div class="param_info"><code class="code">vt</code> : a return location for (transposed) right singular vectors.
                 (default = an implicitly allocated matrix.)</div>
<div class="param_info"><code class="code">iwork</code> : default = an optimum-length vector.</div>

<pre><span id="VALgesdd"><span class="keyword">val</span> gesdd</span> : <code class="type">jobz:('u_cols * 'vt_rows, 'm * 'n,<br>             ('m, 'n) <a href="Slap_size.html#TYPEmin">Slap_size.min</a> * ('m, 'n) <a href="Slap_size.html#TYPEmin">Slap_size.min</a>, 'm * 'n,<br>             <a href="Slap_size.html#TYPEz">Slap_size.z</a> * <a href="Slap_size.html#TYPEz">Slap_size.z</a>)<br>            <a href="Slap_common.html#TYPEsvd_job">Slap_common.svd_job</a> -><br>       ?s:(('m, 'n) <a href="Slap_size.html#TYPEmin">Slap_size.min</a>, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_S.html#TYPEvec">vec</a> -><br>       ?u:('m, 'u_cols, 'u_cd) <a href="Slap_S.html#TYPEmat">mat</a> -><br>       ?vt:('vt_rows, 'n, 'vt_cd) <a href="Slap_S.html#TYPEmat">mat</a> -><br>       ?work:('lwork, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_S.html#TYPEvec">vec</a> -><br>       ?iwork:('liwork, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_common.html#TYPEint32_vec">Slap_common.int32_vec</a> -><br>       ('m, 'n, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a> -><br>       (('m, 'n) <a href="Slap_size.html#TYPEmin">Slap_size.min</a>, 'cnt) <a href="Slap_S.html#TYPEvec">vec</a> *<br>       ('m, 'u_cols, 'u_cd) <a href="Slap_S.html#TYPEmat">mat</a> option *<br>       ('vt_rows, 'n, 'vt_cd) <a href="Slap_S.html#TYPEmat">mat</a> option</code></pre><div class="info ">
<code class="code">gesdd ~jobz ?s ?u ?vt ?work ?iwork a</code> computes the singular value
    decomposition (SVD) of general rectangular matrix <code class="code">a</code> using a divide and
    conquer method: <code class="code">a = U * D * V^T</code> where
<p>
<ul>
<li><code class="code">D</code> is an <code class="code">'m</code>-by-<code class="code">'n</code> matrix (the diagonal elements in <code class="code">D</code> are singular
      values in descreasing order, and other elements are zeros),</li>
<li><code class="code">U</code> is an <code class="code">'m</code>-by-<code class="code">'m</code> orthogonal matrix (the columns in <code class="code">U</code> are left
      singular vectors), and</li>
<li><code class="code">V</code> is an <code class="code">'n</code>-by-<code class="code">'n</code> orthogonal matrix (the columns in <code class="code">V</code> are right
      singular vectors).</li>
</ul>
<br>
<b>Returns</b> <code class="code">(s, u, vt)</code> with singular values <code class="code">s</code> in descreasing order,
            left singular vectors <code class="code">u</code> and right singular vectors <code class="code">vt</code>.
            If <code class="code">u</code> (<code class="code">vt</code>) is not needed, <code class="code">None</code> is returned.<br>
</div>
<div class="param_info"><code class="code">jobz</code> : the SVD job flag:<ul>
<li>If <code class="code">jobz</code> is <a href="Slap_common.html#VALsvd_all"><code class="code">Slap_common.svd_all</code></a>, all <code class="code">'m</code> columns of <code class="code">U</code> and all <code class="code">'n</code>
      rows of <code class="code">V^T</code> are returned in <code class="code">u</code> and <code class="code">vt</code>.
      (<code class="code">'u_cols</code> = <code class="code">'m</code> and <code class="code">'vt_rows</code> = <code class="code">'n</code>.)</li>
<li>If <code class="code">jobz</code> is <a href="Slap_common.html#VALsvd_top"><code class="code">Slap_common.svd_top</code></a>, the first <code class="code">('m, 'n) min</code> columns of
      <code class="code">U</code> and the first <code class="code">('m, 'n) min</code> rows of <code class="code">V^T</code> are returned in <code class="code">u</code> and
      <code class="code">vt</code>. (<code class="code">'u_cols</code> = <code class="code">('m, 'n) min</code> and <code class="code">'vt_rows</code> = <code class="code">('m, 'n) min</code>.)</li>
<li>If <code class="code">jobz</code> is <a href="Slap_common.html#VALsvd_overwrite"><code class="code">Slap_common.svd_overwrite</code></a>, then
    <ul>
<li>if <code class="code">'m &gt;= 'n</code>, <code class="code">a</code> is overwritten with the first <code class="code">('m, 'n) min</code> columns
         of <code class="code">U</code>, and all <code class="code">'n</code> rows of <code class="code">V^T</code> is returned in <code class="code">vt</code>, thus <code class="code">vt</code> is
         <code class="code">'n</code>-by-<code class="code">'n</code> and <code class="code">u</code> is not used;</li>
<li>if <code class="code">'m &lt; 'n</code>, <code class="code">a</code> is overwritten with the first <code class="code">('m, 'n) min</code> rows of
         <code class="code">V^T</code>, and all <code class="code">'m</code> columns of <code class="code">U</code> is returned in <code class="code">u</code>; thereby <code class="code">u</code> is
         <code class="code">'m</code>-by-<code class="code">'m</code> and <code class="code">vt</code> is not used.</li>
</ul>

      (In either case, <code class="code">'u_cols</code> = <code class="code">'m</code> and <code class="code">'vt_rows</code> = <code class="code">'n</code>, but either <code class="code">u</code> or
      <code class="code">vt</code> should be omitted.)</li>
<li>If <code class="code">jobz</code> is <a href="Slap_common.html#VALsvd_no"><code class="code">Slap_common.svd_no</code></a>, no singular vectors are computed.
      (<code class="code">'u_cols</code> = <code class="code">z</code> and <code class="code">'vt_rows</code> = <code class="code">z</code>.)</li>
</ul>
</div>
<div class="param_info"><code class="code">s</code> : a return location for singular values.
                 (default = an implicitly allocated vector.)</div>
<div class="param_info"><code class="code">u</code> : a return location for left singular vectors.
                 (default = an implicitly allocated matrix.)</div>
<div class="param_info"><code class="code">vt</code> : a return location for (transposed) right singular vectors.
                 (default = an implicitly allocated matrix.)</div>
<div class="param_info"><code class="code">work</code> : default = an optimum-length vector.</div>
<div class="param_info"><code class="code">iwork</code> : default = an optimum-length vector.</div>
<br>
<h3 id="3_Generaleigenvalueproblemsimpledrivers">General eigenvalue problem (simple drivers)</h3><br>
<br>
<h3 id="3_Generaleigenvalueproblemsimpledrivers">General eigenvalue problem (simple drivers)</h3><br>
<br>
<h4 id="4_geev">geev</h4><br>

<pre><span id="VALgeev_min_lwork"><span class="keyword">val</span> geev_min_lwork</span> : <code class="type">?vectors:bool -> 'n <a href="Slap_size.html#TYPEt">Slap_size.t</a> -> (module Slap_size.SIZE)</code></pre><div class="info ">
<code class="code">geev_min_lwork ?vectors n</code> computes the minimum length of workspace for
    <code class="code">geev</code> routine. <code class="code">n</code> is the number of rows or columns of a matrix.<br>
</div>
<div class="param_info"><code class="code">vectors</code> : whether eigenvectors are computed, or not.
                   (default = <code class="code">true</code>, i.e., they are computed.)</div>

<pre><span id="VALgeev_opt_lwork"><span class="keyword">val</span> geev_opt_lwork</span> : <code class="type">?vl:('n, 'n, 'vl_cd) <a href="Slap_S.html#TYPEmat">mat</a> option -><br>       ?vr:('n, 'n, 'vr_cd) <a href="Slap_S.html#TYPEmat">mat</a> option -><br>       ?wr:('n, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_S.html#TYPEvec">vec</a> -><br>       ?wi:('n, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_S.html#TYPEvec">vec</a> -><br>       ('n, 'n, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> (module Slap_size.SIZE)</code></pre><div class="info ">
<code class="code">geev_opt_lwork ?vl ?vr ?wr ?vi a</code> computes the optimum length of workspace
    for <code class="code">geev</code> routine.<br>
</div>
<div class="param_info"><code class="code">vl</code> : a return location for left eigenvectors. See LAPACK GEEV
                documentation for details about storage of complex eigenvectors.
                (default = an implicitly allocated matrix.)<ul>
<li>If <code class="code">vl</code> = <code class="code">None</code>, left eigenvectors are not computed;</li>
<li>If <code class="code">vl</code> = <code class="code">Some vl</code>, left eigenvectors are computed.</li>
</ul>
</div>
<div class="param_info"><code class="code">vr</code> : a return location for right eigenvectors. See LAPACK GEEV
                documentation for details about storage of complex eigenvectors.
                (default = an implicitly allocated matrix.)<ul>
<li>If <code class="code">vr</code> = <code class="code">None</code>, right eigenvectors are not computed;</li>
<li>If <code class="code">vr</code> = <code class="code">Some vr</code>, right eigenvectors are computed.</li>
</ul>
</div>
<div class="param_info"><code class="code">wr</code> : a return location for real parts of eigenvalues.
                (default = an implicitly allocated vector.)</div>
<div class="param_info"><code class="code">wi</code> : a return location for imaginary parts of eigenvalues.
                (default = an implicitly allocated vector.)</div>

<pre><span id="VALgeev"><span class="keyword">val</span> geev</span> : <code class="type">?work:('lwork, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_S.html#TYPEvec">vec</a> -><br>       ?vl:('n, 'n, 'vl_cd) <a href="Slap_S.html#TYPEmat">mat</a> option -><br>       ?vr:('n, 'n, 'vr_cd) <a href="Slap_S.html#TYPEmat">mat</a> option -><br>       ?wr:('n, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_S.html#TYPEvec">vec</a> -><br>       ?wi:('n, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_S.html#TYPEvec">vec</a> -><br>       ('n, 'n, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a> -><br>       ('n, 'n, 'vl_cd) <a href="Slap_S.html#TYPEmat">mat</a> option * ('n, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_S.html#TYPEvec">vec</a> *<br>       ('n, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_S.html#TYPEvec">vec</a> * ('n, 'n, 'vr_cd) <a href="Slap_S.html#TYPEmat">mat</a> option</code></pre><div class="info ">
<code class="code">geev ?work ?vl ?vr ?wr ?wi a</code> computes the eigenvalues and the left and
    right eigenvectors of <code class="code">'n</code>-by-<code class="code">'n</code> nonsymmetric matrix <code class="code">a</code>:
<p>

    Let <code class="code">w(j)</code> is the <code class="code">j</code>-th eigenvalue of <code class="code">a</code>. The <code class="code">j</code>-th right eigenvector
    <code class="code">vr(j)</code> satisfies <code class="code">a * vr(j) = w(j) * vr(j)</code>, and the <code class="code">j</code>-th left
    eigenvector <code class="code">vl(j)</code> satisfies <code class="code">vl(j)^H * a = vl(j)^H * w(j)</code> where <code class="code">vl(j)^H</code>
    denotes the conjugate transpose of <code class="code">vl(j)</code>. The computed eigenvalues are
    normalized by Euclidian norm.<br>
<b>Raises</b> <code>Failure</code> if the function fails to converge.<br>
<b>Returns</b> <code class="code">(vl, wr, wi, vr)</code> where <code class="code">vl</code> and <code class="code">vr</code> are left and right
            eigenvectors, and <code class="code">wr</code> and <code class="code">wi</code> are the real and imaginary parts
            of eigenvalues. If <code class="code">vl</code> (<code class="code">vr</code>) is an empty matrix, <code class="code">None</code> is set.<br>
</div>
<div class="param_info"><code class="code">work</code> : default = an optimum-length vector.</div>
<div class="param_info"><code class="code">vl</code> : a return location for left eigenvectors. See LAPACK GEEV
                documentation for details about storage of complex eigenvectors.
                (default = an implicitly allocated matrix.)<ul>
<li>If <code class="code">vl</code> = <code class="code">None</code>, left eigenvectors are not computed;</li>
<li>If <code class="code">vl</code> = <code class="code">Some vl</code>, left eigenvectors are computed.</li>
</ul>
</div>
<div class="param_info"><code class="code">vr</code> : a return location for right eigenvectors. See LAPACK GEEV
                documentation for details about storage of complex eigenvectors.
                (default = an implicitly allocated matrix.)<ul>
<li>If <code class="code">vr</code> = <code class="code">None</code>, right eigenvectors are not computed;</li>
<li>If <code class="code">vr</code> = <code class="code">Some vr</code>, right eigenvectors are computed.</li>
</ul>
</div>
<div class="param_info"><code class="code">wr</code> : a return location for real parts of eigenvalues.
                (default = an implicitly allocated vector.)</div>
<div class="param_info"><code class="code">wi</code> : a return location for imaginary parts of eigenvalues.
                (default = an implicitly allocated vector.)</div>
<br>
<h3 id="3_Symmetricmatrixeigenvalueandsingularvalueproblemssimpledrivers">Symmetric-matrix eigenvalue and singular value problems
         (simple drivers)</h3><br>
<br>
<h3 id="3_Symmetricmatrixeigenvalueandsingularvalueproblemssimpledrivers">Symmetric-matrix eigenvalue and singular value problems
         (simple drivers)</h3><br>
<br>
<h4 id="4_syev">syev</h4><br>

<pre><span id="TYPEsyev_min_lwork"><span class="keyword">type</span> <code class="type">'n</code> syev_min_lwork</span> </pre>


<pre><span id="VALsyev_min_lwork"><span class="keyword">val</span> syev_min_lwork</span> : <code class="type">'n <a href="Slap_size.html#TYPEt">Slap_size.t</a> -> 'n <a href="Slap_S.html#TYPEsyev_min_lwork">syev_min_lwork</a> <a href="Slap_size.html#TYPEt">Slap_size.t</a></code></pre><div class="info ">
<code class="code">syev_min_lwork n</code> computes the minimum length of workspace for
    <code class="code">syev</code> routine. <code class="code">n</code> is the number of rows or columns of a matrix.<br>
</div>

<pre><span id="VALsyev_opt_lwork"><span class="keyword">val</span> syev_opt_lwork</span> : <code class="type">?vectors:bool -><br>       ?up:bool -> ('n, 'n, 'cd) <a href="Slap_S.html#TYPEmat">mat</a> -> (module Slap_size.SIZE)</code></pre><div class="info ">
<code class="code">syev_opt_lwork ?vectors ?up a</code> computes the optimum length of workspace for
    <code class="code">syev</code> routine.<br>
</div>
<div class="param_info"><code class="code">vectors</code> : whether eigenvectors are computed, or not.
                   (default = <code class="code">false</code>.)<ul>
<li>If <code class="code">vectors</code> = <code class="code">true</code>, eigenvectors are computed and returned in <code class="code">a</code>.</li>
<li>If <code class="code">vectors</code> = <code class="code">false</code>, eigenvectors are not computed.</li>
</ul>
</div>
<div class="param_info"><code class="code">up</code> : default = <code class="code">true</code><ul>
<li>If <code class="code">up</code> = <code class="code">true</code>, then the upper triangular part of <code class="code">a</code> is used;</li>
<li>If <code class="code">up</code> = <code class="code">false</code>, then the lower triangular part of <code class="code">a</code> is used.</li>
</ul>
</div>

<pre><span id="VALsyev"><span class="keyword">val</span> syev</span> : <code class="type">?vectors:bool -><br>       ?up:bool -><br>       ?work:('lwork, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_S.html#TYPEvec">vec</a> -><br>       ?w:('n, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_S.html#TYPEvec">vec</a> -><br>       ('n, 'n, 'cd) <a href="Slap_S.html#TYPEmat">mat</a> -> ('n, 'cnt) <a href="Slap_S.html#TYPEvec">vec</a></code></pre><div class="info ">
<code class="code">syev ?vectors ?up ?work ?w a</code> computes the eigenvalues and the eigenvectors
    of <code class="code">'n</code>-by-<code class="code">'n</code> symmetric matrix <code class="code">a</code>.<br>
<b>Raises</b> <code>Failure</code> if the function fails to converge.<br>
<b>Returns</b> the vector <code class="code">w</code> of eigenvalues in ascending order.<br>
</div>
<div class="param_info"><code class="code">vectors</code> : whether eigenvectors are computed, or not.
                   (default = <code class="code">false</code>.)<ul>
<li>If <code class="code">vectors</code> = <code class="code">true</code>, eigenvectors are computed and returned in <code class="code">a</code>.</li>
<li>If <code class="code">vectors</code> = <code class="code">false</code>, eigenvectors are not computed.</li>
</ul>
</div>
<div class="param_info"><code class="code">up</code> : default = <code class="code">true</code><ul>
<li>If <code class="code">up</code> = <code class="code">true</code>, then the upper triangular part of <code class="code">a</code> is used;</li>
<li>If <code class="code">up</code> = <code class="code">false</code>, then the lower triangular part of <code class="code">a</code> is used.</li>
</ul>
</div>
<div class="param_info"><code class="code">work</code> : default = an optimum-length vector.</div>
<div class="param_info"><code class="code">w</code> : a return location for eigenvalues.
             (default = an implicitly allocated vector.)</div>
<br>
<h4 id="4_syevd">syevd</h4><br>

<pre><span id="VALsyevd_min_lwork"><span class="keyword">val</span> syevd_min_lwork</span> : <code class="type">vectors:bool -> 'n <a href="Slap_size.html#TYPEt">Slap_size.t</a> -> (module Slap_size.SIZE)</code></pre><div class="info ">
<code class="code">syevd_min_lwork ?vectors n</code> computes the minimum length of workspace <code class="code">work</code>
    for <code class="code">syevd</code> routine. <code class="code">n</code> is the number of rows or columns of a matrix.<br>
</div>
<div class="param_info"><code class="code">vectors</code> : whether eigenvectors are computed, or not.
                   (default = <code class="code">false</code>, i.e., they are not computed.)</div>

<pre><span id="VALsyevd_min_liwork"><span class="keyword">val</span> syevd_min_liwork</span> : <code class="type">vectors:bool -> 'n <a href="Slap_size.html#TYPEt">Slap_size.t</a> -> (module Slap_size.SIZE)</code></pre><div class="info ">
<code class="code">syevd_min_liwork ?vectors n</code> computes the minimum length of workspace
    <code class="code">iwork</code> for <code class="code">syevd</code> routine. <code class="code">n</code> is the number of rows or columns of a
    matrix.<br>
</div>
<div class="param_info"><code class="code">vectors</code> : whether eigenvectors are computed, or not.
                   (default = <code class="code">false</code>, i.e., they are not computed.)</div>

<pre><span id="VALsyevd_opt_lwork"><span class="keyword">val</span> syevd_opt_lwork</span> : <code class="type">?vectors:bool -><br>       ?up:bool -> ('n, 'n, 'cd) <a href="Slap_S.html#TYPEmat">mat</a> -> (module Slap_size.SIZE)</code></pre><div class="info ">
<code class="code">syevd_opt_lwork ?vectors ?up a</code> computes the optimum length of workspace
    <code class="code">work</code> for <code class="code">syevd</code> routine.<br>
</div>
<div class="param_info"><code class="code">vectors</code> : whether eigenvectors are computed, or not.
                   (default = <code class="code">false</code>, i.e., they are not computed.)</div>
<div class="param_info"><code class="code">up</code> : default = <code class="code">true</code><ul>
<li>If <code class="code">up</code> = <code class="code">true</code>, then the upper triangular part of <code class="code">a</code> is used;</li>
<li>If <code class="code">up</code> = <code class="code">false</code>, then the lower triangular part of <code class="code">a</code> is used.</li>
</ul>
</div>

<pre><span id="VALsyevd_opt_liwork"><span class="keyword">val</span> syevd_opt_liwork</span> : <code class="type">?vectors:bool -><br>       ?up:bool -> ('n, 'n, 'cd) <a href="Slap_S.html#TYPEmat">mat</a> -> (module Slap_size.SIZE)</code></pre><div class="info ">
<code class="code">syevd_opt_liwork ?vectors ?up a</code> computes the optimum length of workspace
    <code class="code">iwork</code> for <code class="code">syevd</code> routine.<br>
</div>
<div class="param_info"><code class="code">vectors</code> : whether eigenvectors are computed, or not.
                   (default = <code class="code">false</code>, i.e., they are not computed.)</div>
<div class="param_info"><code class="code">up</code> : default = <code class="code">true</code><ul>
<li>If <code class="code">up</code> = <code class="code">true</code>, then the upper triangular part of <code class="code">a</code> is used;</li>
<li>If <code class="code">up</code> = <code class="code">false</code>, then the lower triangular part of <code class="code">a</code> is used.</li>
</ul>
</div>

<pre><span id="VALsyevd"><span class="keyword">val</span> syevd</span> : <code class="type">?vectors:bool -><br>       ?up:bool -><br>       ?work:('lwork, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_S.html#TYPEvec">vec</a> -><br>       ?iwork:('liwork, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_common.html#TYPEint32_vec">Slap_common.int32_vec</a> -><br>       ?w:('n, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_S.html#TYPEvec">vec</a> -><br>       ('n, 'n, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> ('n, 'w_cd) <a href="Slap_S.html#TYPEvec">vec</a></code></pre><div class="info ">
<code class="code">syev ?vectors ?up ?w a</code> computes the eigenvalues and the eigenvectors of
    <code class="code">'n</code>-by-<code class="code">'n</code> symmetric matrix <code class="code">a</code> using divide and conquer method.<br>
<b>Raises</b> <code>Failure</code> if the function fails to converge.<br>
<b>Returns</b> the vector <code class="code">w</code> of eigenvalues in ascending order.<br>
</div>
<div class="param_info"><code class="code">vectors</code> : whether eigenvectors are computed, or not.
                   (default = <code class="code">false</code>.)<ul>
<li>If <code class="code">vectors</code> = <code class="code">true</code>, eigenvectors are computed and returned in <code class="code">a</code>.</li>
<li>If <code class="code">vectors</code> = <code class="code">false</code>, eigenvectors are not computed.</li>
</ul>
</div>
<div class="param_info"><code class="code">up</code> : default = <code class="code">true</code><ul>
<li>If <code class="code">up</code> = <code class="code">true</code>, then the upper triangular part of <code class="code">a</code> is used;</li>
<li>If <code class="code">up</code> = <code class="code">false</code>, then the lower triangular part of <code class="code">a</code> is used.</li>
</ul>
</div>
<div class="param_info"><code class="code">work</code> : default = an optimum-length vector.</div>
<div class="param_info"><code class="code">iwork</code> : default = an optimum-length vector.</div>
<div class="param_info"><code class="code">w</code> : a return location for eigenvalues.
             (default = an implicitly allocated vector.)</div>
<br>
<h4 id="4_sbev">sbev</h4><br>

<pre><span id="TYPEsbev_min_lwork"><span class="keyword">type</span> <code class="type">'n</code> sbev_min_lwork</span> </pre>


<pre><span id="VALsbev_min_lwork"><span class="keyword">val</span> sbev_min_lwork</span> : <code class="type">'n <a href="Slap_size.html#TYPEt">Slap_size.t</a> -> 'n <a href="Slap_S.html#TYPEsbev_min_lwork">sbev_min_lwork</a> <a href="Slap_size.html#TYPEt">Slap_size.t</a></code></pre><div class="info ">
<code class="code">sbev_min_lwork n</code> computes the minimum length of workspace <code class="code">work</code>
    for <code class="code">sbev</code> routine. <code class="code">n</code> is the number of rows or columns of a matrix.<br>
</div>

<pre><span id="VALsbev"><span class="keyword">val</span> sbev</span> : <code class="type">kd:'kd <a href="Slap_size.html#TYPEt">Slap_size.t</a> -><br>       ?z:('n, 'n, 'z_cd) <a href="Slap_S.html#TYPEmat">mat</a> -><br>       ?up:bool -><br>       ?work:('lwork, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_S.html#TYPEvec">vec</a> -><br>       ?w:('n, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_S.html#TYPEvec">vec</a> -><br>       (('n, 'kd) <a href="Slap_size.html#TYPEsyband">Slap_size.syband</a>, 'n, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> ('n, 'cnt) <a href="Slap_S.html#TYPEvec">vec</a></code></pre><div class="info ">
<code class="code">sbev ~kd ?z ?up ?work ?w ab</code> computes all eigenvalues and, optionally,
    eigenvectors of real symmetric band matrix <code class="code">ab</code> store in band storage
    format.<br>
<b>Since</b> 0.2.0<br>
<b>Raises</b> <code>Failure</code> if the function fails to converge.<br>
<b>Returns</b> vector <code class="code">w</code>, which is overwritten.<br>
</div>
<div class="param_info"><code class="code">kd</code> : the number of subdiagonals or superdiagonals.</div>
<div class="param_info"><code class="code">z</code> : The eigenvectors are returned in <code class="code">z</code> if it is given.
                They are not computed if omitted.</div>
<div class="param_info"><code class="code">up</code> : default = <code class="code">true</code><ul>
<li>If <code class="code">up</code> = <code class="code">true</code>, then the upper triangular part of <code class="code">ab</code> is used;</li>
<li>If <code class="code">up</code> = <code class="code">false</code>, then the lower triangular part of <code class="code">ab</code> is used.</li>
</ul>
</div>
<div class="param_info"><code class="code">work</code> : workspace for <code class="code">sbev</code></div>
<div class="param_info"><code class="code">w</code> : <code class="code">w</code> is replaced by eigenvalues if it is given, or newly
                allocated if omitted.</div>
<br>
<h3 id="3_SymmetricmatrixeigenvalueandsingularvalueproblemsexpertRRRdrivers">Symmetric-matrix eigenvalue and singular value problems
       (expert &amp; RRR drivers)</h3><br>
<br>
<h3 id="3_SymmetricmatrixeigenvalueandsingularvalueproblemsexpertRRRdrivers">Symmetric-matrix eigenvalue and singular value problems
       (expert &amp; RRR drivers)</h3><br>
<br>
<h4 id="4_syevr">syevr</h4><br>

<pre><span id="TYPEsyevr_min_lwork"><span class="keyword">type</span> <code class="type">'n</code> syevr_min_lwork</span> </pre>


<pre><span id="VALsyevr_min_lwork"><span class="keyword">val</span> syevr_min_lwork</span> : <code class="type">'n <a href="Slap_size.html#TYPEt">Slap_size.t</a> -> 'n <a href="Slap_S.html#TYPEsyevr_min_lwork">syevr_min_lwork</a> <a href="Slap_size.html#TYPEt">Slap_size.t</a></code></pre><div class="info ">
<code class="code">sbevr_min_lwork n</code> computes the minimum length of workspace <code class="code">work</code>
    for <code class="code">syevr</code> routine. <code class="code">n</code> is the number of rows or columns of a matrix.<br>
</div>

<pre><span id="TYPEsyevr_min_liwork"><span class="keyword">type</span> <code class="type">'n</code> syevr_min_liwork</span> </pre>


<pre><span id="VALsyevr_min_liwork"><span class="keyword">val</span> syevr_min_liwork</span> : <code class="type">'n <a href="Slap_size.html#TYPEt">Slap_size.t</a> -> 'n <a href="Slap_S.html#TYPEsyevr_min_liwork">syevr_min_liwork</a> <a href="Slap_size.html#TYPEt">Slap_size.t</a></code></pre><div class="info ">
<code class="code">sbevr_min_liwork n</code> computes the minimum length of workspace <code class="code">iwork</code>
    for <code class="code">syevr</code> routine. <code class="code">n</code> is the number of rows or columns of a matrix.<br>
</div>

<pre><span id="VALsyevr_opt_lwork"><span class="keyword">val</span> syevr_opt_lwork</span> : <code class="type">?vectors:bool -><br>       ?range:[ `A | `I of int * int | `V of float * float ] -><br>       ?up:bool -><br>       ?abstol:float -> ('n, 'n, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> (module Slap_size.SIZE)</code></pre><div class="info ">
<code class="code">sbevr_opt_lwork ?vectors ?range ?up ?abstol a</code> computes the optimum length
    of workspace <code class="code">work</code> for <code class="code">syevr</code> routine.<br>
</div>
<div class="param_info"><code class="code">vectors</code> : whether eigenvectors are computed, or not.
                   (default = <code class="code">false</code>, i.e., they are not computed.)</div>
<div class="param_info"><code class="code">range</code> : default = <code class="code">`A</code>.</div>
<div class="param_info"><code class="code">up</code> : default = <code class="code">true</code>.</div>
<div class="param_info"><code class="code">abstol</code> : The absolute error tolerance to which each eigenvalue or
                  eigenvector is required. (default = <code class="code">lamch `S</code>.)</div>

<pre><span id="VALsyevr_opt_liwork"><span class="keyword">val</span> syevr_opt_liwork</span> : <code class="type">?vectors:bool -><br>       ?range:[ `A | `I of int * int | `V of float * float ] -><br>       ?up:bool -><br>       ?abstol:float -> ('n, 'n, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> (module Slap_size.SIZE)</code></pre><div class="info ">
<code class="code">sbevr_opt_liwork ?vectors ?range ?up ?abstol a</code> computes the optimum length
    of workspace <code class="code">iwork</code> for <code class="code">sbevr</code> routine.<br>
</div>
<div class="param_info"><code class="code">vectors</code> : whether eigenvectors are computed, or not.
                   (default = <code class="code">false</code>, i.e., they are not computed.)</div>
<div class="param_info"><code class="code">range</code> : default = <code class="code">`A</code>.</div>
<div class="param_info"><code class="code">up</code> : default = <code class="code">true</code>.</div>
<div class="param_info"><code class="code">abstol</code> : The absolute error tolerance to which each eigenvalue or
                  eigenvector is required. (default = <code class="code">lamch `S</code>.)</div>

<pre><span class="keyword">module type</span> <a href="Slap_S.SYEVR_RESULT.html">SYEVR_RESULT</a> = <code class="code">sig</code> <a href="Slap_S.SYEVR_RESULT.html">..</a> <code class="code">end</code></pre><div class="info">
The signature of returned modules of <code class="code">syevr_dyn</code>.
</div>

<pre><span id="VALsyevr_dyn"><span class="keyword">val</span> syevr_dyn</span> : <code class="type">?vectors:bool -><br>       ?range:[ `A | `I of int * int | `V of float * float ] -><br>       ?up:bool -><br>       ?abstol:float -><br>       ?work:('lwork, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_S.html#TYPEvec">vec</a> -><br>       ?iwork:('liwork, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_common.html#TYPEint32_vec">Slap_common.int32_vec</a> -><br>       ?w:('n, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_S.html#TYPEvec">vec</a> -><br>       ?z:('n, 'k, 'z_cd) <a href="Slap_S.html#TYPEmat">mat</a> -><br>       ?isuppz:(('k, 'k) <a href="Slap_size.html#TYPEadd">Slap_size.add</a>, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_common.html#TYPEint32_vec">Slap_common.int32_vec</a> -><br>       ('n, 'n, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> (module Slap_S.SYEVR_RESULT with type n = 'n)</code></pre><div class="info ">
<code class="code">syevr_dyn ?vectors ?range ?up ?abstol ?work ?iwork ?w ?z ?isuppz a</code>
    computes selected eigenvalues <code class="code">w</code> and, optionally, eigenvectors <code class="code">z</code> of a
    real symmetric matrix <code class="code">a</code> using the Relatively Robust Representations.
<p>

    Usage:
<pre class="codepre"><code class="code">let f (type nn) ... =
  ...
  let (a : (nn, nn, _) mat) = ... in
  let module X = (val syevr_dyn ?vectors ?range ?up ?abstol
                      ?work ?iwork ?w ?z ?isuppz a
                   : SYEVR_RESULT with type n = nn) in
  let (m, w, z, isuppz) = X.value in
  ...
</code></pre>
    where type <code class="code">nn</code> is the size of symmetric matrix <code class="code">a</code>.
    The returned module <code class="code">X</code> contains tuple <code class="code">X.value = (m, w, z, isuppz)</code> and
    type <code class="code">X.m</code> for representation of the number of computed eigenvalues:
<p>
<ul>
<li>Size <code class="code">m : X.m Slap_size.t</code> is the number of eigenvalues.</li>
<li>Vector <code class="code">w : (X.n, _) vec</code> contains the <code class="code">m</code> eigenvalues in ascending order.</li>
<li>Matrix <code class="code">z : (X.n, X.m, _) mat</code> contains the <code class="code">m</code> eigenvectors of dimension
      <code class="code">n</code> in the same order.</li>
<li><code class="code">2*m</code>-dimensional vector
      <code class="code">isuppz : ((m, m) Slap.Slap_size.add, _) Slap_common.int32_vec</code> indicates the
      nonzero elements in <code class="code">z</code>.</li>
</ul>
<br>
<b>Raises</b> <code>Invalid_argument</code> if not <code class="code">X.m &lt;= 'k</code><br>
<b>Returns</b> the above-mentioned module <code class="code">X</code>.<br>
</div>
<div class="param_info"><code class="code">vectors</code> : whether eigenvectors are computed, or not.
                   (default = <code class="code">false</code>.)<ul>
<li>If <code class="code">vectors</code> = <code class="code">true</code>, eigenvectors are computed and returned in <code class="code">a</code>.</li>
<li>If <code class="code">vectors</code> = <code class="code">false</code>, eigenvectors are not computed.</li>
</ul>
</div>
<div class="param_info"><code class="code">range</code> : default = <code class="code">`A</code><ul>
<li>If <code class="code">range</code> = <code class="code">`A</code>, all eigenvalues are computed.</li>
<li>If <code class="code">range</code> = <code class="code">`I (il, iu)</code>, eigenvalues with indices <code class="code">il</code> to <code class="code">iu</code> are
        computed.</li>
<li>If <code class="code">range</code> = <code class="code">`V (vl, vu)</code>, the routine computes eigenvalues <code class="code">w(i)</code> in
        the half-open interval: <code class="code">vl &lt; w(i) &lt;= vu</code> where <code class="code">vl &lt;= vu</code>.</li>
</ul>
</div>
<div class="param_info"><code class="code">up</code> : default = <code class="code">true</code><ul>
<li>If <code class="code">up</code> = <code class="code">true</code>, then the upper triangular part of <code class="code">a</code> is used;</li>
<li>If <code class="code">up</code> = <code class="code">false</code>, then the lower triangular part of <code class="code">a</code> is used.</li>
</ul>
</div>
<div class="param_info"><code class="code">abstol</code> : The absolute error tolerance to which each eigenvalue or
                  eigenvector is required. (default = <code class="code">lamch `S</code>.)</div>
<div class="param_info"><code class="code">work</code> : default = an optimum-length vector.</div>
<div class="param_info"><code class="code">iwork</code> : default = an optimum-length vector.</div>
<div class="param_info"><code class="code">w</code> : a return location for eigenvalues.
                  (default = an implicitly allocated vector of the minimum
                  required dimension.)</div>
<div class="param_info"><code class="code">z</code> : a return location for eigenvectors.
                  (default = an implicitly allocated matrix of the minimum
                  required dimension.)</div>
<div class="param_info"><code class="code">isuppz</code> : a return location for a vector to indicate the nonzero
                  elements in <code class="code">z</code>.
                  (default = an implicitly allocated matrix of the minimum
                  required dimension.)</div>
<br>
<h4 id="4_sygv">sygv</h4><br>

<pre><span id="VALsygv_opt_lwork"><span class="keyword">val</span> sygv_opt_lwork</span> : <code class="type">?vectors:bool -><br>       ?up:bool -><br>       ?itype:[ `AB | `A_B | `BA ] -><br>       ('n, 'n, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a> -><br>       ('n, 'n, 'b_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> (module Slap_size.SIZE)</code></pre><div class="info ">
<code class="code">sygv_opt_lwork ?vectors ?up ?itype a b</code> computes the optimum length of
    workspace <code class="code">work</code> for <code class="code">sbevr</code> routine.<br>
</div>
<div class="param_info"><code class="code">vectors</code> : whether eigenvectors are computed, or not.
                   (default = <code class="code">false</code>, i.e., they are not computed.)</div>
<div class="param_info"><code class="code">up</code> : default = <code class="code">true</code>.</div>
<div class="param_info"><code class="code">itype</code> : the behavior of this routine.</div>

<pre><span id="VALsygv"><span class="keyword">val</span> sygv</span> : <code class="type">?vectors:bool -><br>       ?up:bool -><br>       ?work:('lwork, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_S.html#TYPEvec">vec</a> -><br>       ?w:('n, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_S.html#TYPEvec">vec</a> -><br>       ?itype:[ `AB | `A_B | `BA ] -><br>       ('n, 'n, 'a_cd) <a href="Slap_S.html#TYPEmat">mat</a> -><br>       ('n, 'n, 'b_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> ('n, 'cnt) <a href="Slap_S.html#TYPEvec">vec</a></code></pre><div class="info ">
<code class="code">sygv ?vectors ?up ?work ?w ?itype a b</code> solves a real generalized symmetric
    definite eigenproblem:
<p>
<ul>
<li><code class="code">a * x = lambda * b * x</code> if <code class="code">itype</code> is <code class="code">`A_B</code>;</li>
<li><code class="code">a * b * x = lambda * x</code> if <code class="code">itype</code> is <code class="code">`AB</code>;</li>
<li><code class="code">b * a * x = lambda * x</code> if <code class="code">itype</code> is <code class="code">`BA</code></li>
</ul>

    where <code class="code">a</code> is a <code class="code">'n</code>-by-<code class="code">'n</code> symmetric matrix, and <code class="code">b</code> is a <code class="code">'n</code>-by-<code class="code">'n</code>
    symmetric positive definite matrix.<br>
<b>Raises</b><ul><li><code>Failure</code> if the function fails to converge.</li>
<li><code>Failure</code> if the function fails to converge.</li>
</ul>
<b>Returns</b> vector <code class="code">w</code> of eigenvalues in ascending order.<br>
</div>
<div class="param_info"><code class="code">vectors</code> : whether eigenvectors are computed, or not.
                   (default = <code class="code">false</code>.)<ul>
<li>If <code class="code">vectors</code> = <code class="code">true</code>, eigenvectors are computed and returned in <code class="code">a</code>.</li>
<li>If <code class="code">vectors</code> = <code class="code">false</code>, eigenvectors are not computed.</li>
</ul>
</div>
<div class="param_info"><code class="code">up</code> : default = <code class="code">true</code>.<ul>
<li>If <code class="code">up</code> = <code class="code">true</code>, then the upper triangular part of <code class="code">a</code> is used;</li>
<li>If <code class="code">up</code> = <code class="code">false</code>, then the lower triangular part of <code class="code">a</code> is used.</li>
</ul>
</div>
<div class="param_info"><code class="code">work</code> : default = an optimum-length workspace.</div>
<div class="param_info"><code class="code">w</code> : a return location for eigenvalues.
                 (default = an implicitly allocated vector.)</div>
<div class="param_info"><code class="code">itype</code> : the behavior of this routine.</div>
<br>
<h4 id="4_sbgv">sbgv</h4><br>

<pre><span id="VALsbgv"><span class="keyword">val</span> sbgv</span> : <code class="type">ka:'ka <a href="Slap_size.html#TYPEt">Slap_size.t</a> -><br>       kb:'kb <a href="Slap_size.html#TYPEt">Slap_size.t</a> -><br>       ?z:('n, 'n, 'z_cd) <a href="Slap_S.html#TYPEmat">mat</a> -><br>       ?up:bool -><br>       ?work:('lwork, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_S.html#TYPEvec">vec</a> -><br>       ?w:('n, <a href="Slap_misc.html#TYPEcnt">Slap_misc.cnt</a>) <a href="Slap_S.html#TYPEvec">vec</a> -><br>       (('n, 'ka) <a href="Slap_size.html#TYPEsyband">Slap_size.syband</a>, 'n, 'ab_cd) <a href="Slap_S.html#TYPEmat">mat</a> -><br>       (('n, 'kb) <a href="Slap_size.html#TYPEsyband">Slap_size.syband</a>, 'n, 'bb_cd) <a href="Slap_S.html#TYPEmat">mat</a> -> ('n, 'cnt) <a href="Slap_S.html#TYPEvec">vec</a></code></pre><div class="info ">
<code class="code">sbgv ~ka ~kb ?z ?up ?work ?w ab bb</code> solves a general eigenvalue problem
    <code class="code">ab * z = (lambda) * bb * z</code> where <code class="code">ab</code> is a <code class="code">'n</code>-by-<code class="code">'n</code> symmetric band
    matrix with <code class="code">ka</code> subdiagonals, and <code class="code">bb</code> is a <code class="code">'n</code>-by-<code class="code">'n</code> symmetric
    positive-definite band matrix with <code class="code">kb</code> subdiagonals. Both <code class="code">ab</code> and <code class="code">bb</code>
    are stored in band storage format.<br>
<b>Since</b> 0.2.0<br>
<b>Raises</b> <code>Failure</code> if the function fails to converge.<br>
<b>Returns</b> vector <code class="code">w</code>, which is overwritten.<br>
</div>
<div class="param_info"><code class="code">ka</code> : the number of subdiagonals or superdiagonals of <code class="code">ab</code>.</div>
<div class="param_info"><code class="code">kb</code> : the number of subdiagonals or superdiagonals of <code class="code">bb</code>.</div>
<div class="param_info"><code class="code">z</code> : The eigenvectors are returned in <code class="code">z</code> if it is given.
                They are not computed if omitted.</div>
<div class="param_info"><code class="code">up</code> : default = <code class="code">true</code><ul>
<li>If <code class="code">up</code> = <code class="code">true</code>, then the upper triangular part of <code class="code">ab</code> is used;</li>
<li>If <code class="code">up</code> = <code class="code">false</code>, then the lower triangular part of <code class="code">ab</code> is used.</li>
</ul>
</div>
<div class="param_info"><code class="code">work</code> : workspace for <code class="code">sbgv</code></div>
<div class="param_info"><code class="code">w</code> : <code class="code">w</code> is replaced by eigenvalues if it is given, or newly
                allocated if omitted.</div>
</body></html>