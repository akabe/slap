<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Slap : BLAS and LAPACK binding in OCaml with type-based static size checking for matrix operations">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Slap</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/akabe/slap">View on GitHub</a>

          <h1 id="project_title">Slap</h1>
          <h2 id="project_tagline">BLAS and LAPACK binding in OCaml with type-based static size checking for matrix operations</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/akabe/slap/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/akabe/slap/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1>
<a name="sized-linear-algebra-package-slap" class="anchor" href="#sized-linear-algebra-package-slap"><span class="octicon octicon-link"></span></a>Sized Linear Algebra Package (SLAP)</h1>

<p>SLAP is a linear algebra library with type-based static size checking for
matrix operations.</p>

<p>This <a href="http://ocaml.org/">OCaml</a>-library is a wrapper of
<a href="https://bitbucket.org/mmottl/lacaml">Lacaml</a>, a binding of two widely used
linear algebra libraries <a href="http://www.netlib.org/blas/">BLAS</a> (Basic Linear
Algebra Subprograms) and <a href="http://www.netlib.org/lapack/">LAPACK</a> (Linear Algebra
PACKage) for FORTRAN.
SLAP guarantees <strong>statically</strong> (i.e., at compile time) consistency (with respect
to dimensions) of most high-level matrix (and vector) operations by using
<em>generative phantom types</em>. For example, addition of two- and three-dimensional
vectors causes type error at <strong>compile time</strong>, and dynamic errors like
exceptions do <strong>not</strong> happen.
(Certain low-level operations, like accesses to elements by indices, need
dynamic checks.)</p>

<p>This provides many useful and high-performance linear algebraic operations in
Lacaml, e.g., least squares problems, linear equations, Cholesky,
QR-factorization, eigenvalue problems and singular value decomposition (SVD).
Most of their interfaces are compatible with Lacaml functions.
(Several functions have not been implemented yet, but they will be supported
soon.)</p>

<h2>
<a name="install" class="anchor" href="#install"><span class="octicon octicon-link"></span></a>Install</h2>

<p>OPAM installation:</p>

<pre><code>opam install slap
</code></pre>

<p>Manual build (requiring <a href="https://github.com/mmottl/lacaml">Lacaml</a> and
<a href="http://mjambon.com/cppo.html">cppo</a>):</p>

<pre><code>./configure
make
make install
</code></pre>

<h2>
<a name="documentation" class="anchor" href="#documentation"><span class="octicon octicon-link"></span></a>Documentation</h2>

<ul>
<li>Online API documentation is available at <a href="http://akabe.github.io/slap/">http://akabe.github.io/slap/</a>
(generated by <code>make doc</code>).</li>
<li>This library interface was announced at
<a href="http://okmij.org/ftp/ML/ML14.html">ML Family Workshop 2014</a> in Gothenburg,
Sweden: A Simple and Practical Linear Algebra Library Interface with Static
Size Checking, by Akinori Abe and Eijiro Sumii (Tohoku University).
<a href="https://ocaml.org/meetings/ocaml/2014/ocaml2014_19.pdf">PDF Abstract</a>,
<a href="https://ocaml.org/meetings/ocaml/2014/abe-sumii-slides.pdf">PDF Slides</a>,
<a href="https://akabe.github.io/sgpr/changes.pdf">PDF Supplement</a>.
(The talk was accepted by
<a href="https://ocaml.org/meetings/ocaml/2014/">OCaml Workshop 2014</a>, but it was
presented at ML Workshop.)</li>
</ul>

<h2>
<a name="demo" class="anchor" href="#demo"><span class="octicon octicon-link"></span></a>Demo</h2>

<p>The following code (<a href="examples/linsys/jacobi.ml">examples/linsys/jacobi.ml</a>)
is an implementation of
<a href="http://en.wikipedia.org/wiki/Jacobi_method">Jacobi method</a> (to solve
system of linear equations).</p>

<div class="highlight highlight-ocaml"><pre><span class="k">open</span> <span class="nn">Slap</span><span class="p">.</span><span class="nc">Io</span>
<span class="k">open</span> <span class="nn">Slap</span><span class="p">.</span><span class="nc">D</span>
<span class="k">open</span> <span class="nn">Slap</span><span class="p">.</span><span class="nc">Size</span>
<span class="k">open</span> <span class="nn">Slap</span><span class="p">.</span><span class="nc">Common</span>

<span class="k">let</span> <span class="n">jacobi</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">d_inv</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">.</span><span class="n">reci</span> <span class="o">(</span><span class="nn">Mat</span><span class="p">.</span><span class="n">diag</span> <span class="n">a</span><span class="o">)</span> <span class="k">in</span> <span class="c">(* reciprocal diagonal elements *)</span>
  <span class="k">let</span> <span class="n">r</span> <span class="o">=</span> <span class="nn">Mat</span><span class="p">.</span><span class="n">mapi</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="n">j</span> <span class="n">aij</span> <span class="o">-&gt;</span> <span class="k">if</span> <span class="n">i</span> <span class="o">=</span> <span class="n">j</span> <span class="k">then</span> <span class="mi">0</span><span class="o">.</span><span class="mi">0</span> <span class="k">else</span> <span class="n">aij</span><span class="o">)</span> <span class="n">a</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">.</span><span class="n">create</span> <span class="o">(</span><span class="nn">Vec</span><span class="p">.</span><span class="n">dim</span> <span class="n">b</span><span class="o">)</span> <span class="k">in</span> <span class="c">(* temporary memory *)</span>
  <span class="k">let</span> <span class="k">rec</span> <span class="n">loop</span> <span class="n">z</span> <span class="n">x</span> <span class="o">=</span>
    <span class="n">ignore</span> <span class="o">(</span><span class="n">copy</span> <span class="o">~</span><span class="n">y</span> <span class="n">b</span><span class="o">);</span> <span class="c">(* y := b *)</span>
    <span class="n">ignore</span> <span class="o">(</span><span class="n">gemv</span> <span class="o">~</span><span class="n">y</span> <span class="o">~</span><span class="n">trans</span><span class="o">:</span><span class="n">normal</span> <span class="o">~</span><span class="n">alpha</span><span class="o">:(-</span><span class="mi">1</span><span class="o">.</span><span class="mi">0</span><span class="o">)</span> <span class="o">~</span><span class="n">beta</span><span class="o">:</span><span class="mi">1</span><span class="o">.</span><span class="mi">0</span> <span class="n">r</span> <span class="n">x</span><span class="o">);</span> <span class="c">(* y := y-r*x *)</span>
    <span class="n">ignore</span> <span class="o">(</span><span class="nn">Vec</span><span class="p">.</span><span class="n">mul</span> <span class="o">~</span><span class="n">z</span> <span class="n">d_inv</span> <span class="n">y</span><span class="o">);</span> <span class="c">(* z := element-wise mult. of d_inv and y *)</span>
    <span class="k">if</span> <span class="nn">Vec</span><span class="p">.</span><span class="n">ssqr_diff</span> <span class="n">x</span> <span class="n">z</span> <span class="o">&lt;</span> <span class="mf">1e-10</span> <span class="k">then</span> <span class="n">z</span> <span class="k">else</span> <span class="n">loop</span> <span class="n">x</span> <span class="n">z</span> <span class="c">(* Check convergence *)</span>
  <span class="k">in</span>
  <span class="k">let</span> <span class="n">x0</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">.</span><span class="n">make</span> <span class="o">(</span><span class="nn">Vec</span><span class="p">.</span><span class="n">dim</span> <span class="n">b</span><span class="o">)</span> <span class="mi">1</span><span class="o">.</span><span class="mi">0</span> <span class="k">in</span> <span class="c">(* the initial values of `x' *)</span>
  <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">.</span><span class="n">create</span> <span class="o">(</span><span class="nn">Vec</span><span class="p">.</span><span class="n">dim</span> <span class="n">b</span><span class="o">)</span> <span class="k">in</span> <span class="c">(* temporary memory *)</span>
  <span class="n">loop</span> <span class="n">z</span> <span class="n">x0</span>

<span class="k">let</span> <span class="o">_</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="nn">Mat</span><span class="p">.</span><span class="n">init</span> <span class="n">four</span> <span class="n">four</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="n">j</span> <span class="o">-&gt;</span> <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="n">float_of_int</span> <span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="o">)</span> <span class="k">in</span>
                                         <span class="n">exp</span> <span class="o">(~-.</span> <span class="n">p</span> <span class="o">*.</span> <span class="n">p</span><span class="o">))</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">b</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">.</span><span class="n">init</span> <span class="n">four</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="n">float_of_int</span> <span class="n">i</span><span class="o">)</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">jacobi</span> <span class="n">a</span> <span class="n">b</span> <span class="k">in</span>
  <span class="nn">Format</span><span class="p">.</span><span class="n">printf</span> <span class="s2">"a = @[%a@]@.b = @[%a@]@."</span> <span class="n">pp_fmat</span> <span class="n">a</span> <span class="n">pp_rfvec</span> <span class="n">b</span><span class="o">;</span>
  <span class="nn">Format</span><span class="p">.</span><span class="n">printf</span> <span class="s2">"x = @[%a@]@."</span> <span class="n">pp_rfvec</span> <span class="n">x</span><span class="o">;</span>
  <span class="nn">Format</span><span class="p">.</span><span class="n">printf</span> <span class="s2">"a*x = @[%a@]@."</span> <span class="n">pp_rfvec</span> <span class="o">(</span><span class="n">gemv</span> <span class="o">~</span><span class="n">trans</span><span class="o">:</span><span class="n">normal</span> <span class="n">a</span> <span class="n">x</span><span class="o">)</span>
</pre></div>

<p><code>jacobi a b</code> solves a system of linear equations <code>a * x = b</code> where <code>a</code> is
a n-by-n matrix, and <code>x</code> and <code>b</code> is a n-dimensional vectors. This code can
be compiled by <code>ocamlfind ocamlc -linkpkg -package slap jacobi.ml</code>, and
<code>a.out</code> outputs:</p>

<div class="highlight highlight-ocaml"><pre><span class="n">a</span> <span class="o">=</span>          <span class="mi">1</span>  <span class="mi">0</span><span class="o">.</span><span class="mi">367879</span> <span class="mi">0</span><span class="o">.</span><span class="mi">0183156</span> <span class="mi">0</span><span class="o">.</span><span class="mi">00012341</span>
      <span class="mi">0</span><span class="o">.</span><span class="mi">367879</span>         <span class="mi">1</span>  <span class="mi">0</span><span class="o">.</span><span class="mi">367879</span>  <span class="mi">0</span><span class="o">.</span><span class="mi">0183156</span>
     <span class="mi">0</span><span class="o">.</span><span class="mi">0183156</span>  <span class="mi">0</span><span class="o">.</span><span class="mi">367879</span>         <span class="mi">1</span>   <span class="mi">0</span><span class="o">.</span><span class="mi">367879</span>
    <span class="mi">0</span><span class="o">.</span><span class="mi">00012341</span> <span class="mi">0</span><span class="o">.</span><span class="mi">0183156</span>  <span class="mi">0</span><span class="o">.</span><span class="mi">367879</span>          <span class="mi">1</span>
<span class="n">b</span> <span class="o">=</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span>
<span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span><span class="mi">496539</span> <span class="mi">1</span><span class="o">.</span><span class="mi">30705</span> <span class="mi">1</span><span class="o">.</span><span class="mi">21131</span> <span class="mi">3</span><span class="o">.</span><span class="mi">53038</span>
<span class="n">a</span><span class="o">*</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span><span class="mi">999998</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span>
</pre></div>

<p>OK. Vector <code>x</code> is computed. Try to modify any one of
the dimensions of <code>a</code>, <code>b</code> and <code>x</code> in the above code, e.g.,</p>

<div class="highlight highlight-ocaml"><pre><span class="o">...</span>

<span class="k">let</span> <span class="o">_</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="nn">Mat</span><span class="p">.</span><span class="n">init</span> <span class="n">four</span> <span class="n">five</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="n">j</span> <span class="o">-&gt;</span> <span class="o">...</span>
  <span class="o">...</span>
</pre></div>

<p>and compile the changed code. Then OCaml reports a type error (not a runtime
error like an exception):</p>

<div class="highlight highlight-ocaml"><pre><span class="nc">Error</span><span class="o">:</span> <span class="nc">This</span> <span class="n">expression</span> <span class="n">has</span> <span class="k">type</span>
  <span class="o">(</span><span class="n">z</span> <span class="n">s</span> <span class="n">s</span> <span class="n">s</span> <span class="n">s</span><span class="o">,</span> <span class="n">z</span> <span class="n">s</span> <span class="n">s</span> <span class="n">s</span> <span class="n">s</span> <span class="n">s</span><span class="o">,</span> <span class="k">'</span><span class="n">a</span><span class="o">)</span> <span class="n">mat</span> <span class="o">=</span> <span class="o">(</span><span class="n">z</span> <span class="n">s</span> <span class="n">s</span> <span class="n">s</span> <span class="n">s</span><span class="o">,</span> <span class="n">z</span> <span class="n">s</span> <span class="n">s</span> <span class="n">s</span> <span class="n">s</span> <span class="n">s</span><span class="o">,</span> <span class="kt">float</span><span class="o">,</span> <span class="n">rprec</span><span class="o">,</span> <span class="k">'</span><span class="n">a</span><span class="o">)</span> <span class="nn">Slap</span><span class="p">.</span><span class="nn">Mat</span><span class="p">.</span><span class="n">t</span>
<span class="n">but</span> <span class="n">an</span> <span class="n">expression</span> <span class="n">was</span> <span class="n">expected</span> <span class="k">of</span> <span class="k">type</span>
  <span class="o">(</span><span class="n">z</span> <span class="n">s</span> <span class="n">s</span> <span class="n">s</span> <span class="n">s</span><span class="o">,</span> <span class="n">z</span> <span class="n">s</span> <span class="n">s</span> <span class="n">s</span> <span class="n">s</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">mat</span> <span class="o">=</span> <span class="o">(</span><span class="n">z</span> <span class="n">s</span> <span class="n">s</span> <span class="n">s</span> <span class="n">s</span><span class="o">,</span> <span class="n">z</span> <span class="n">s</span> <span class="n">s</span> <span class="n">s</span> <span class="n">s</span><span class="o">,</span> <span class="kt">float</span><span class="o">,</span> <span class="n">rprec</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="nn">Slap</span><span class="p">.</span><span class="nn">Mat</span><span class="p">.</span><span class="n">t</span>
<span class="nc">Type</span> <span class="n">z</span> <span class="n">s</span> <span class="n">is</span> <span class="n">not</span> <span class="n">compatible</span> <span class="k">with</span> <span class="k">type</span> <span class="n">z</span>
</pre></div>

<p>By using SLAP, your mistake (i.e., a bug) is captured at <strong>compile time</strong>!</p>

<h2>
<a name="usage" class="anchor" href="#usage"><span class="octicon octicon-link"></span></a>Usage</h2>

<p>The following modules provide useful linear algebraic operations including
BLAS and LAPACK functions.</p>

<ul>
<li>
<code>Slap.S</code>: Single-precision (32-bit) real numbers</li>
<li>
<code>Slap.D</code>: Double-precision (64-bit) real numbers</li>
<li>
<code>Slap.C</code>: Single-precision (32-bit) complex numbers</li>
<li>
<code>Slap.Z</code>: Double-precision (64-bit) complex numbers</li>
</ul>

<h3>
<a name="simple-computation" class="anchor" href="#simple-computation"><span class="octicon octicon-link"></span></a>Simple computation</h3>

<h4>
<a name="dimensions-sizes" class="anchor" href="#dimensions-sizes"><span class="octicon octicon-link"></span></a>Dimensions (sizes)</h4>

<p><code>Slap.Size</code> provides operations on <em>sizes</em> (i.e., natural numbers as dimensions
of vectors and matrices) of curious types. Look at the type of <code>Slap.Size.four</code>:</p>

<div class="highlight highlight-ocaml"><pre><span class="o">#</span> <span class="k">open</span> <span class="nn">Slap</span><span class="p">.</span><span class="nc">Size</span><span class="o">;;</span>
<span class="o">#</span> <span class="n">four</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="n">z</span> <span class="n">s</span> <span class="n">s</span> <span class="n">s</span> <span class="n">s</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">4</span>
</pre></div>

<p>Types <code>z</code> and <code>'n s</code> correspond to zero and <code>'n + 1</code>, respectively. Thus,
<code>z s s s s</code> represents 0+1+1+1+1 = 4. <code>'n t</code> (= <code>'n Slap.Size.t</code>) is a
<em>singleton type</em> on natural numbers; i.e., evaluation of a term (i.e.,
expression) of type <code>'n t</code> <strong>always</strong> results in the natural number
corresponding to  <code>'n</code>. Therefore <code>z s s s s t</code> is the type of terms always
evaluated to four.</p>

<h4>
<a name="vectors" class="anchor" href="#vectors"><span class="octicon octicon-link"></span></a>Vectors</h4>

<p>Creation of a four-dimensional vector:</p>

<div class="highlight highlight-ocaml"><pre><span class="o">#</span> <span class="k">open</span> <span class="nn">Slap</span><span class="p">.</span><span class="nc">D</span><span class="o">;;</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">.</span><span class="n">init</span> <span class="n">four</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="n">float_of_int</span> <span class="n">i</span><span class="o">);;</span>
<span class="k">val</span> <span class="n">x</span> <span class="o">:</span> <span class="o">(</span><span class="n">z</span> <span class="n">s</span> <span class="n">s</span> <span class="n">s</span> <span class="n">s</span><span class="o">,</span> <span class="k">'</span><span class="n">a</span><span class="o">)</span> <span class="n">vec</span> <span class="o">=</span> <span class="nc">R1</span> <span class="nc">R2</span> <span class="nc">R3</span> <span class="nc">R4</span>
                               <span class="mi">1</span>  <span class="mi">2</span>  <span class="mi">3</span>  <span class="mi">4</span>
</pre></div>

<p><code>Vec.init</code> creates a vector initialized by the given function. <code>('n, 'a) vec</code> is
the type of <code>'n</code>-dimensional vectors. So <code>(z s s s s, 'a) vec</code> is the type of
four-dimensional vectors. (Description of the second type parameter is omitted.)</p>

<p>Vectors of different dimensions <strong>always</strong> have different types:</p>

<div class="highlight highlight-ocaml"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">.</span><span class="n">init</span> <span class="n">five</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="n">float_of_int</span> <span class="n">i</span><span class="o">);;</span>
<span class="k">val</span> <span class="n">y</span> <span class="o">:</span> <span class="o">(</span><span class="n">z</span> <span class="n">s</span> <span class="n">s</span> <span class="n">s</span> <span class="n">s</span> <span class="n">s</span><span class="o">,</span> <span class="k">'</span><span class="n">a</span><span class="o">)</span> <span class="n">vec</span> <span class="o">=</span> <span class="nc">R1</span> <span class="nc">R2</span> <span class="nc">R3</span> <span class="nc">R4</span> <span class="nc">R5</span>
                                 <span class="mi">1</span>  <span class="mi">2</span>  <span class="mi">3</span>  <span class="mi">4</span>  <span class="mi">5</span>
</pre></div>

<p>The addition of four-dimensional vector <code>x</code> and five-dimensional vector <code>y</code>
causes a type error (at compile time):</p>

<div class="highlight highlight-ocaml"><pre><span class="o">#</span> <span class="nn">Vec</span><span class="p">.</span><span class="n">add</span> <span class="n">x</span> <span class="n">y</span><span class="o">;;</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">This</span> <span class="n">expression</span> <span class="n">has</span> <span class="k">type</span>
  <span class="o">(</span><span class="n">z</span> <span class="n">s</span> <span class="n">s</span> <span class="n">s</span> <span class="n">s</span> <span class="n">s</span><span class="o">,</span> <span class="k">'</span><span class="n">a</span><span class="o">)</span> <span class="n">vec</span> <span class="o">=</span> <span class="o">(</span><span class="n">z</span> <span class="n">s</span> <span class="n">s</span> <span class="n">s</span> <span class="n">s</span> <span class="n">s</span><span class="o">,</span> <span class="kt">float</span><span class="o">,</span> <span class="n">rprec</span><span class="o">,</span> <span class="k">'</span><span class="n">a</span><span class="o">)</span> <span class="nn">Slap</span><span class="p">.</span><span class="nn">Vec</span><span class="p">.</span><span class="n">t</span>
<span class="n">but</span> <span class="n">an</span> <span class="n">expression</span> <span class="n">was</span> <span class="n">expected</span> <span class="k">of</span> <span class="k">type</span>
  <span class="o">(</span><span class="n">z</span> <span class="n">s</span> <span class="n">s</span> <span class="n">s</span> <span class="n">s</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">vec</span> <span class="o">=</span> <span class="o">(</span><span class="n">z</span> <span class="n">s</span> <span class="n">s</span> <span class="n">s</span> <span class="n">s</span><span class="o">,</span> <span class="kt">float</span><span class="o">,</span> <span class="n">rprec</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="nn">Slap</span><span class="p">.</span><span class="nn">Vec</span><span class="p">.</span><span class="n">t</span>
<span class="nc">Type</span> <span class="n">z</span> <span class="n">s</span> <span class="n">is</span> <span class="n">not</span> <span class="n">compatible</span> <span class="k">with</span> <span class="k">type</span> <span class="n">z</span>
</pre></div>

<p>Of course, addition of vectors of the same dimension succeeds:</p>

<div class="highlight highlight-ocaml"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">.</span><span class="n">map</span> <span class="o">(</span><span class="k">fun</span> <span class="n">c</span> <span class="o">-&gt;</span> <span class="n">c</span> <span class="o">*.</span> <span class="mi">2</span><span class="o">.</span><span class="mi">0</span><span class="o">)</span> <span class="n">x</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">z</span> <span class="o">:</span> <span class="o">(</span><span class="n">z</span> <span class="n">s</span> <span class="n">s</span> <span class="n">s</span> <span class="n">s</span><span class="o">,</span> <span class="k">'</span><span class="n">a</span><span class="o">)</span> <span class="n">vec</span> <span class="o">=</span> <span class="nc">R1</span> <span class="nc">R2</span> <span class="nc">R3</span> <span class="nc">R4</span>
                               <span class="mi">2</span>  <span class="mi">4</span>  <span class="mi">6</span>  <span class="mi">8</span>
<span class="o">#</span> <span class="nn">Vec</span><span class="p">.</span><span class="n">add</span> <span class="n">x</span> <span class="n">z</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="o">(</span><span class="n">z</span> <span class="n">s</span> <span class="n">s</span> <span class="n">s</span> <span class="n">s</span><span class="o">,</span> <span class="k">'</span><span class="n">a</span><span class="o">)</span> <span class="n">vec</span> <span class="o">=</span> <span class="nc">R1</span> <span class="nc">R2</span> <span class="nc">R3</span> <span class="nc">R4</span>
                           <span class="mi">3</span>  <span class="mi">6</span>  <span class="mi">9</span> <span class="mi">12</span>
</pre></div>

<h4>
<a name="matrices" class="anchor" href="#matrices"><span class="octicon octicon-link"></span></a>Matrices</h4>

<p>Creation of a 3-by-5 matrix:</p>

<div class="highlight highlight-ocaml"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="nn">Mat</span><span class="p">.</span><span class="n">init</span> <span class="n">three</span> <span class="n">five</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="n">j</span> <span class="o">-&gt;</span> <span class="n">float_of_int</span> <span class="o">(</span><span class="mi">10</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="o">));;</span>
<span class="k">val</span> <span class="n">a</span> <span class="o">:</span> <span class="o">(</span><span class="n">z</span> <span class="n">s</span> <span class="n">s</span> <span class="n">s</span><span class="o">,</span> <span class="n">z</span> <span class="n">s</span> <span class="n">s</span> <span class="n">s</span> <span class="n">s</span> <span class="n">s</span><span class="o">,</span> <span class="k">'</span><span class="n">a</span><span class="o">)</span> <span class="n">mat</span> <span class="o">=</span>
     <span class="nc">C1</span> <span class="nc">C2</span> <span class="nc">C3</span> <span class="nc">C4</span> <span class="nc">C5</span>
  <span class="nc">R1</span> <span class="mi">11</span> <span class="mi">12</span> <span class="mi">13</span> <span class="mi">14</span> <span class="mi">15</span>
  <span class="nc">R2</span> <span class="mi">21</span> <span class="mi">22</span> <span class="mi">23</span> <span class="mi">24</span> <span class="mi">25</span>
  <span class="nc">R3</span> <span class="mi">31</span> <span class="mi">32</span> <span class="mi">33</span> <span class="mi">34</span> <span class="mi">35</span>
</pre></div>

<p><code>('m, 'n, 'a) mat</code> is the type of <code>'m</code>-by-<code>'n</code> matrices. Thus
<code>(z s s s, z s s s s s, 'a) mat</code> is the type of 3-by-5 matrices. (Description of
the third type parameter is omitted.)</p>

<p>BLAS function <code>gemm</code> multiplies two general matrices:</p>

<div class="highlight highlight-ocaml"><pre><span class="n">gemm</span> <span class="o">?</span><span class="n">beta</span> <span class="o">?</span><span class="n">c</span> <span class="o">~</span><span class="n">transa</span> <span class="o">?</span><span class="n">alpha</span> <span class="n">a</span> <span class="o">~</span><span class="n">transb</span> <span class="n">b</span>
</pre></div>

<p>executes <code>c := alpha * a * b + beta * c</code> with matrices <code>a</code>, <code>b</code> and <code>c</code>, and
scalar values <code>alpha</code> and <code>beta</code>. The parameters <code>transa</code> and <code>transb</code> specify
no transpose (<code>Slap.Common.normal</code>), transpose (<code>Slap.Common.trans</code>) or
conjugate transpose (<code>Slap.Common.conjtr</code>) of matrices <code>a</code> and <code>b</code>,
respectively. (<code>conjtr</code> can be used only for complex operations in <code>Slap.C</code>
and <code>Slap.Z</code>.) For example, if <code>transa</code>=<code>normal</code> and <code>transb</code>=<code>trans</code>, then
<code>gemm</code> executes <code>c := alpha * a * b^T + beta * c</code> (where <code>b^T</code> is the transpose
of <code>b</code>). When you compute <code>a * a^T</code> by <code>gemm</code>, a 3-by-3 matrix is returned since
<code>a</code> is a 3-by-5 matrix:</p>

<div class="highlight highlight-ocaml"><pre><span class="o">#</span> <span class="k">open</span> <span class="nn">Slap</span><span class="p">.</span><span class="nc">Common</span><span class="o">;;</span>
<span class="o">#</span> <span class="n">gemm</span> <span class="o">~</span><span class="n">transa</span><span class="o">:</span><span class="n">normal</span> <span class="o">~</span><span class="n">transb</span><span class="o">:</span><span class="n">trans</span> <span class="n">a</span> <span class="n">a</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="o">(</span><span class="n">z</span> <span class="n">s</span> <span class="n">s</span> <span class="n">s</span><span class="o">,</span> <span class="n">z</span> <span class="n">s</span> <span class="n">s</span> <span class="n">s</span><span class="o">,</span> <span class="k">'</span><span class="n">a</span><span class="o">)</span> <span class="n">mat</span> <span class="o">=</span>
     <span class="nc">C1</span>   <span class="nc">C2</span>   <span class="nc">C3</span>
<span class="nc">R1</span>  <span class="mi">855</span> <span class="mi">1505</span> <span class="mi">2155</span>
<span class="nc">R2</span> <span class="mi">1505</span> <span class="mi">2655</span> <span class="mi">3805</span>
<span class="nc">R3</span> <span class="mi">2155</span> <span class="mi">3805</span> <span class="mi">5455</span>
</pre></div>

<p><code>a * a</code> causes a type error since the number of columns of the first matrix is
not equal to the number of rows of the second matrix:</p>

<div class="highlight highlight-ocaml"><pre><span class="o">#</span> <span class="n">gemm</span> <span class="o">~</span><span class="n">transa</span><span class="o">:</span><span class="n">normal</span> <span class="o">~</span><span class="n">transb</span><span class="o">:</span><span class="n">normal</span> <span class="n">a</span> <span class="n">a</span><span class="o">;;</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">This</span> <span class="n">expression</span> <span class="n">has</span> <span class="k">type</span>
  <span class="o">(</span><span class="n">z</span> <span class="n">s</span> <span class="n">s</span> <span class="n">s</span><span class="o">,</span> <span class="n">z</span> <span class="n">s</span> <span class="n">s</span> <span class="n">s</span> <span class="n">s</span> <span class="n">s</span><span class="o">,</span> <span class="k">'</span><span class="n">a</span><span class="o">)</span> <span class="n">mat</span> <span class="o">=</span>
  <span class="o">(</span><span class="n">z</span> <span class="n">s</span> <span class="n">s</span> <span class="n">s</span><span class="o">,</span> <span class="n">z</span> <span class="n">s</span> <span class="n">s</span> <span class="n">s</span> <span class="n">s</span> <span class="n">s</span><span class="o">,</span> <span class="kt">float</span><span class="o">,</span> <span class="n">rprec</span><span class="o">,</span> <span class="k">'</span><span class="n">a</span><span class="o">)</span> <span class="nn">Slap</span><span class="p">.</span><span class="nn">Mat</span><span class="p">.</span><span class="n">t</span>
<span class="n">but</span> <span class="n">an</span> <span class="n">expression</span> <span class="n">was</span> <span class="n">expected</span> <span class="k">of</span> <span class="k">type</span>
  <span class="o">(</span><span class="n">z</span> <span class="n">s</span> <span class="n">s</span> <span class="n">s</span> <span class="n">s</span> <span class="n">s</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">,</span> <span class="k">'</span><span class="n">c</span><span class="o">)</span> <span class="n">mat</span> <span class="o">=</span>
  <span class="o">(</span><span class="n">z</span> <span class="n">s</span> <span class="n">s</span> <span class="n">s</span> <span class="n">s</span> <span class="n">s</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">,</span> <span class="kt">float</span><span class="o">,</span> <span class="n">rprec</span><span class="o">,</span> <span class="k">'</span><span class="n">c</span><span class="o">)</span> <span class="nn">Slap</span><span class="p">.</span><span class="nn">Mat</span><span class="p">.</span><span class="n">t</span>
<span class="nc">Type</span> <span class="n">z</span> <span class="n">is</span> <span class="n">not</span> <span class="n">compatible</span> <span class="k">with</span> <span class="k">type</span> <span class="n">z</span> <span class="n">s</span> <span class="n">s</span>
</pre></div>

<h3>
<a name="sizes-decided-at-runtime" class="anchor" href="#sizes-decided-at-runtime"><span class="octicon octicon-link"></span></a>Sizes decided at runtime</h3>

<p>SLAP can safely treat sizes that are unknown until runtime
(e.g., the dimension of a vector loaded from a file)!
Unfortunately, SLAP does not provide functions to load a
vector or a matrix from a file. (Maybe such operations will be implemented.)
You need to write a function to load a list or an array from a file
and call a SLAP function to convert it to a vector or a matrix.</p>

<p>Conversion of a list into a vector:</p>

<div class="highlight highlight-ocaml"><pre><span class="o">#</span> <span class="k">module</span> <span class="nc">X</span> <span class="o">=</span> <span class="o">(</span><span class="k">val</span> <span class="nn">Vec</span><span class="p">.</span><span class="n">of_list</span> <span class="o">[</span><span class="mi">1</span><span class="o">.;</span> <span class="mi">2</span><span class="o">.;</span> <span class="mi">3</span><span class="o">.]</span> <span class="o">:</span> <span class="nn">Vec</span><span class="p">.</span><span class="nc">CNTVEC</span><span class="o">);;</span>
<span class="k">module</span> <span class="nc">X</span> <span class="o">:</span> <span class="nn">Slap</span><span class="p">.</span><span class="nn">D</span><span class="p">.</span><span class="nn">Vec</span><span class="p">.</span><span class="nc">CNTVEC</span>
</pre></div>

<p>The returned module <code>X</code> has the following signature:</p>

<div class="highlight highlight-ocaml"><pre><span class="k">module</span> <span class="k">type</span> <span class="nn">Slap</span><span class="p">.</span><span class="nn">D</span><span class="p">.</span><span class="nn">Vec</span><span class="p">.</span><span class="nc">CNTVEC</span> <span class="o">=</span> <span class="k">sig</span>
  <span class="k">type</span> <span class="n">n</span> <span class="c">(* a type to represent the dimension of a vector *)</span>
  <span class="k">val</span> <span class="k">value</span> <span class="o">:</span> <span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="k">'</span><span class="n">cnt</span><span class="o">)</span> <span class="n">vec</span> <span class="c">(* the instance of a vector *)</span>
<span class="k">end</span>
</pre></div>

<p>The instance of a vector is <code>X.value</code>:</p>

<div class="highlight highlight-ocaml"><pre><span class="o">#</span> <span class="nn">X</span><span class="p">.</span><span class="n">value</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="o">(</span><span class="nn">X</span><span class="p">.</span><span class="n">n</span><span class="o">,</span> <span class="k">'</span><span class="n">cnt</span><span class="o">)</span> <span class="n">vec</span> <span class="o">=</span> <span class="nc">R1</span> <span class="nc">R2</span> <span class="nc">R3</span>
                       <span class="mi">1</span>  <span class="mi">2</span>  <span class="mi">3</span>
</pre></div>

<p>It can be treated as stated above. It's very easy!</p>

<p>You can also convert a list into a matrix:</p>

<div class="highlight highlight-ocaml"><pre><span class="o">#</span> <span class="k">module</span> <span class="nc">A</span> <span class="o">=</span> <span class="o">(</span><span class="k">val</span> <span class="nn">Mat</span><span class="p">.</span><span class="n">of_list</span> <span class="o">[[</span><span class="mi">1</span><span class="o">.;</span> <span class="mi">2</span><span class="o">.;</span> <span class="mi">3</span><span class="o">.];</span>
                               <span class="o">[</span><span class="mi">4</span><span class="o">.;</span> <span class="mi">5</span><span class="o">.;</span> <span class="mi">6</span><span class="o">.]]</span> <span class="o">:</span> <span class="nn">Mat</span><span class="p">.</span><span class="nc">CNTMAT</span><span class="o">);;</span>
<span class="o">#</span> <span class="nn">A</span><span class="p">.</span><span class="n">value</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="o">(</span><span class="nn">A</span><span class="p">.</span><span class="n">m</span><span class="o">,</span> <span class="nn">A</span><span class="p">.</span><span class="n">n</span><span class="o">,</span> <span class="k">'</span><span class="n">cnt</span><span class="o">)</span> <span class="n">mat</span> <span class="o">=</span>    <span class="nc">C1</span> <span class="nc">C2</span> <span class="nc">C3</span>
                           <span class="nc">R1</span>  <span class="mi">1</span>  <span class="mi">2</span>  <span class="mi">3</span>
                           <span class="nc">R2</span>  <span class="mi">4</span>  <span class="mi">5</span>  <span class="mi">6</span>
</pre></div>

<h4>
<a name="idea-of-generative-phantom-type" class="anchor" href="#idea-of-generative-phantom-type"><span class="octicon octicon-link"></span></a>Idea of generative phantom type</h4>

<p>In this section, we explain our basic idea of static size checking. For
example, let's think about the function <code>loadvec : string -&gt; (?, _) vec</code>.
It returns a vector of some dimension, loaded from the given path.
The dimension is decided at <strong>runtime</strong>, but we need to type it at
<strong>compile time</strong>. How do we represent the return type <code>?</code>?
Consider the following code for example:</p>

<div class="highlight highlight-ocaml"><pre><span class="k">let</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="o">(?</span><span class="mi">1</span><span class="o">,</span> <span class="o">_)</span> <span class="n">vec</span><span class="o">)</span> <span class="o">=</span> <span class="n">loadvec</span> <span class="s2">"file1"</span> <span class="k">in</span>
<span class="k">let</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="o">(?</span><span class="mi">2</span><span class="o">,</span> <span class="o">_)</span> <span class="n">vec</span><span class="o">)</span> <span class="o">=</span> <span class="n">loadvec</span> <span class="s2">"file2"</span> <span class="k">in</span>
<span class="nn">Vec</span><span class="p">.</span><span class="n">add</span> <span class="n">x</span> <span class="n">y</span>
</pre></div>

<p>The third line should be ill-typed because the dimensions of <code>x</code> and <code>y</code> are
probably different. (Even if <code>"file1"</code> and <code>"file2"</code> were the same path, the
addition should be ill-typed because the file might change between the two
loads.) Thus, the return type of <code>loadvec</code> should be different every time it is
called (regardless of the specific values of the argument). We call such a
return type <em>generative</em> because the function returns a value of a fresh type
for each call. The vector type with generative size information essentially
corresponds to an existentially quantified sized type like <code>exists n. n vec</code>.</p>

<p>Type parameters <code>'m</code>, <code>'n</code> and <code>'a</code> of types <code>'n Size.t</code>, <code>('n, 'a) vec</code> and
<code>('m, 'n, 'a) mat</code> are <em>phantom</em>, meaning that they do not appear on the right
hand side of the type definition. A phantom type parameter is often instantiated
with a type that has no value (i.e., no constructor) which we call a
<em>phantom type</em>. Then we call the type <code>?</code> a <em>generative phantom type</em>.</p>

<p>Actually, type <code>X.n</code> (returned by <code>Vec.of_list</code>) is different for each call of
the function, i.e., a generative phantom type:</p>

<div class="highlight highlight-ocaml"><pre><span class="o">#</span> <span class="k">module</span> <span class="nc">Y</span> <span class="o">=</span> <span class="o">(</span><span class="k">val</span> <span class="nn">Vec</span><span class="p">.</span><span class="n">of_list</span> <span class="o">[</span><span class="mi">4</span><span class="o">.;</span> <span class="mi">5</span><span class="o">.]</span> <span class="o">:</span> <span class="nn">Vec</span><span class="p">.</span><span class="nc">CNTVEC</span><span class="o">);;</span>
<span class="o">#</span> <span class="nn">Vec</span><span class="p">.</span><span class="n">add</span> <span class="nn">X</span><span class="p">.</span><span class="n">value</span> <span class="nn">Y</span><span class="p">.</span><span class="n">value</span><span class="o">;;</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">This</span> <span class="n">expression</span> <span class="n">has</span> <span class="k">type</span>
  <span class="o">(</span><span class="nn">Y</span><span class="p">.</span><span class="n">n</span><span class="o">,</span> <span class="k">'</span><span class="n">a</span><span class="o">)</span> <span class="n">vec</span> <span class="o">=</span> <span class="o">(</span><span class="nn">Y</span><span class="p">.</span><span class="n">n</span><span class="o">,</span> <span class="kt">float</span><span class="o">,</span> <span class="n">rprec</span><span class="o">,</span> <span class="k">'</span><span class="n">a</span><span class="o">)</span> <span class="nn">Slap</span><span class="p">.</span><span class="nn">Vec</span><span class="p">.</span><span class="n">t</span>
<span class="n">but</span> <span class="n">an</span> <span class="n">expression</span> <span class="n">was</span> <span class="n">expected</span> <span class="k">of</span> <span class="k">type</span>
  <span class="o">(</span><span class="nn">X</span><span class="p">.</span><span class="n">n</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="n">vec</span> <span class="o">=</span> <span class="o">(</span><span class="nn">X</span><span class="p">.</span><span class="n">n</span><span class="o">,</span> <span class="kt">float</span><span class="o">,</span> <span class="n">rprec</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="o">)</span> <span class="nn">Slap</span><span class="p">.</span><span class="nn">Vec</span><span class="p">.</span><span class="n">t</span>
<span class="nc">Type</span> <span class="nn">Y</span><span class="p">.</span><span class="n">n</span> <span class="n">is</span> <span class="n">not</span> <span class="n">compatible</span> <span class="k">with</span> <span class="k">type</span> <span class="nn">X</span><span class="p">.</span><span class="n">n</span>
</pre></div>

<h4>
<a name="addition-of-vectors-loaded-from-different-files" class="anchor" href="#addition-of-vectors-loaded-from-different-files"><span class="octicon octicon-link"></span></a>Addition of vectors loaded from different files</h4>

<p>When you want to add vectors loaded from different files, you can use
<code>Vec.of_list_dyn</code>:</p>

<div class="highlight highlight-ocaml"><pre><span class="k">val</span> <span class="nn">Vec</span><span class="p">.</span><span class="n">of_list_dyn</span> <span class="o">:</span> <span class="k">'</span><span class="n">n</span> <span class="nn">Size</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">float</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="k">'</span><span class="n">n</span><span class="o">,</span> <span class="k">'</span><span class="n">cnt</span><span class="o">)</span> <span class="n">vec</span>
</pre></div>

<p>It also converts a list into a vector, but differs from <code>Vec.of_list</code>: You need
to give the length of a list to the first parameter as a size. For example, if
you consider that two lists <code>lst1</code> and <code>lst2</code> (loaded from different files) have
the same length, you can add them as follows:</p>

<div class="highlight highlight-ocaml"><pre><span class="o">#</span> <span class="k">let</span> <span class="n">lst1</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">.;</span> <span class="mi">2</span><span class="o">.;</span> <span class="mi">3</span><span class="o">.;</span> <span class="mi">4</span><span class="o">.;</span> <span class="mi">5</span><span class="o">.];;</span> <span class="c">(* loaded from a file *)</span>
<span class="k">val</span> <span class="n">lst1</span> <span class="o">:</span> <span class="kt">float</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">.;</span> <span class="mi">2</span><span class="o">.;</span> <span class="mi">3</span><span class="o">.;</span> <span class="mi">4</span><span class="o">.;</span> <span class="mi">5</span><span class="o">.]</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">lst2</span> <span class="o">=</span> <span class="o">[</span><span class="mi">6</span><span class="o">.;</span> <span class="mi">7</span><span class="o">.;</span> <span class="mi">8</span><span class="o">.;</span> <span class="mi">9</span><span class="o">.;</span> <span class="mi">10</span><span class="o">.];;</span> <span class="c">(* loaded from another file *)</span>
<span class="k">val</span> <span class="n">lst2</span> <span class="o">:</span> <span class="kt">float</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">[</span><span class="mi">6</span><span class="o">.;</span> <span class="mi">7</span><span class="o">.;</span> <span class="mi">8</span><span class="o">.;</span> <span class="mi">9</span><span class="o">.;</span> <span class="mi">10</span><span class="o">.]</span>
<span class="o">#</span> <span class="k">module</span> <span class="nc">X</span> <span class="o">=</span> <span class="o">(</span><span class="k">val</span> <span class="nn">Vec</span><span class="p">.</span><span class="n">of_list</span> <span class="n">lst1</span> <span class="o">:</span> <span class="nn">Vec</span><span class="p">.</span><span class="nc">CNTVEC</span><span class="o">);;</span>
<span class="k">module</span> <span class="nc">X</span> <span class="o">:</span> <span class="nn">Slap</span><span class="p">.</span><span class="nn">D</span><span class="p">.</span><span class="nn">Vec</span><span class="p">.</span><span class="nc">CNTVEC</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">.</span><span class="n">of_list_dyn</span> <span class="o">(</span><span class="nn">Vec</span><span class="p">.</span><span class="n">dim</span> <span class="nn">X</span><span class="p">.</span><span class="n">value</span><span class="o">)</span> <span class="n">lst2</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">y</span> <span class="o">:</span> <span class="o">(</span><span class="nn">X</span><span class="p">.</span><span class="n">n</span><span class="o">,</span> <span class="k">'</span><span class="n">a</span><span class="o">)</span> <span class="n">vec</span> <span class="o">=</span> <span class="nc">R1</span> <span class="nc">R2</span> <span class="nc">R3</span> <span class="nc">R4</span> <span class="nc">R5</span>
                         <span class="mi">6</span>  <span class="mi">7</span>  <span class="mi">8</span>  <span class="mi">9</span> <span class="mi">10</span>
<span class="o">#</span> <span class="nn">Vec</span><span class="p">.</span><span class="n">add</span> <span class="nn">X</span><span class="p">.</span><span class="n">value</span> <span class="n">y</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="o">(</span><span class="nn">X</span><span class="p">.</span><span class="n">n</span><span class="o">,</span> <span class="k">'</span><span class="n">a</span><span class="o">)</span> <span class="n">vec</span> <span class="o">=</span> <span class="nc">R1</span> <span class="nc">R2</span> <span class="nc">R3</span> <span class="nc">R4</span> <span class="nc">R5</span>
                     <span class="mi">7</span>  <span class="mi">9</span> <span class="mi">11</span> <span class="mi">13</span> <span class="mi">15</span>
</pre></div>

<p><code>Vec.of_list</code> raises an <strong>exception</strong> (at runtime) if the given size is not
equal to the length, i.e., the lengths of <code>lst1</code> and <code>lst2</code>
are different in the above case. This dynamic check is unavoidable because the
equality of sizes of two vectors loaded from different files cannot be
statically guaranteed. We gave functions containing dynamic checks the suffix
<code>_dyn</code>.</p>

<h2>
<a name="advanced-information" class="anchor" href="#advanced-information"><span class="octicon octicon-link"></span></a>Advanced information</h2>

<h3>
<a name="size-constraints" class="anchor" href="#size-constraints"><span class="octicon octicon-link"></span></a>Size constraints</h3>

<p>When a matrix operation is implemented by low-level index-based accesses, its
size constraints cannot be inferred statically (since they are checked only at
runtime): For example, consider the function <code>axby</code>, which calculates
<code>alpha * x + beta * y</code> with scalar values <code>alpha</code> and <code>beta</code>, and vectors <code>x</code>
and <code>y</code>:</p>

<div class="highlight highlight-ocaml"><pre><span class="k">open</span> <span class="nn">Slap</span><span class="p">.</span><span class="nc">D</span>

<span class="k">let</span> <span class="n">axby</span> <span class="n">alpha</span> <span class="n">x</span> <span class="n">beta</span> <span class="n">y</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">.</span><span class="n">dim</span> <span class="n">x</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">.</span><span class="n">create</span> <span class="n">n</span> <span class="k">in</span>
  <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">to</span> <span class="nn">Slap</span><span class="p">.</span><span class="nn">Size</span><span class="p">.</span><span class="n">to_int</span> <span class="n">n</span> <span class="k">do</span>
    <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">*.</span> <span class="o">(</span><span class="nn">Vec</span><span class="p">.</span><span class="n">get_dyn</span> <span class="n">x</span> <span class="n">i</span><span class="o">)</span> <span class="o">+.</span> <span class="n">beta</span> <span class="o">*.</span> <span class="o">(</span><span class="nn">Vec</span><span class="p">.</span><span class="n">get_dyn</span> <span class="n">y</span> <span class="n">i</span><span class="o">)</span> <span class="k">in</span>
    <span class="nn">Vec</span><span class="p">.</span><span class="n">set_dyn</span> <span class="n">z</span> <span class="n">i</span> <span class="n">p</span>
  <span class="k">done</span><span class="o">;</span>
  <span class="n">z</span>
</pre></div>

<p>The dimensions of vectors <code>x</code> and <code>y</code> must be the same, but OCaml infers that
they may be different:</p>

<div class="highlight highlight-ocaml"><pre><span class="k">val</span> <span class="n">axby</span> <span class="o">:</span> <span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="k">'</span><span class="n">n</span><span class="o">,</span> <span class="o">_)</span> <span class="n">vec</span> <span class="o">-&gt;</span> <span class="kt">float</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="k">'</span><span class="n">m</span><span class="o">,</span> <span class="o">_)</span> <span class="n">vec</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="k">'</span><span class="n">n</span><span class="o">,</span> <span class="o">_)</span> <span class="n">vec</span>
</pre></div>

<p>There are two ways to solve this problem.</p>

<h5>
<a name="1-to-write-size-constraints-by-hand" class="anchor" href="#1-to-write-size-constraints-by-hand"><span class="octicon octicon-link"></span></a>1. To write size constraints by hand</h5>

<p>One is to type-annotate <code>axby</code> by hand:</p>

<div class="highlight highlight-ocaml"><pre><span class="k">let</span> <span class="n">axby</span> <span class="n">alpha</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="o">(</span><span class="k">'</span><span class="n">n</span><span class="o">,</span> <span class="o">_)</span> <span class="n">vec</span><span class="o">)</span> <span class="n">beta</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="o">(</span><span class="k">'</span><span class="n">n</span><span class="o">,</span> <span class="o">_)</span> <span class="n">vec</span><span class="o">)</span> <span class="o">=</span>
  <span class="o">...</span>
</pre></div>

<h5>
<a name="2-to-use-high-level-matrix-operations-recommended" class="anchor" href="#2-to-use-high-level-matrix-operations-recommended"><span class="octicon octicon-link"></span></a>2. To use high-level matrix operations (recommended)</h5>

<p>The other way is to use high-level operations such as <code>map</code>, <code>fold</code>, BLAS and
LAPACK functions instead of low-level operations such as <code>get_dyn</code> and
<code>set_dyn</code>:</p>

<div class="highlight highlight-ocaml"><pre><span class="k">let</span> <span class="n">axby</span> <span class="n">alpha</span> <span class="n">x</span> <span class="n">beta</span> <span class="n">y</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="n">copy</span> <span class="n">y</span> <span class="k">in</span> <span class="c">(* z = y *)</span>
  <span class="n">scal</span> <span class="n">beta</span> <span class="n">z</span><span class="o">;</span> <span class="c">(* z := beta * z *)</span>
  <span class="n">axpy</span> <span class="o">~</span><span class="n">alpha</span> <span class="o">~</span><span class="n">x</span> <span class="n">y</span><span class="o">;</span> <span class="c">(* z := alpha * x + z *)</span>
  <span class="n">z</span>
</pre></div>

<p>or</p>

<div class="highlight highlight-ocaml"><pre><span class="k">let</span> <span class="n">axby</span> <span class="n">alpha</span> <span class="n">x</span> <span class="n">beta</span> <span class="n">y</span> <span class="o">=</span>
  <span class="nn">Vec</span><span class="p">.</span><span class="n">map2</span> <span class="o">(</span><span class="k">fun</span> <span class="n">xi</span> <span class="n">yi</span> <span class="o">-&gt;</span> <span class="n">alpha</span> <span class="o">*.</span> <span class="n">xi</span> <span class="o">+.</span> <span class="n">beta</span> <span class="o">*.</span> <span class="n">yi</span><span class="o">)</span> <span class="n">x</span> <span class="n">y</span>
</pre></div>

<p>In this case, size constraints are automatically inferred by OCaml.
We strongly recommend this way.</p>

<h3>
<a name="escaping-generative-phantom-types" class="anchor" href="#escaping-generative-phantom-types"><span class="octicon octicon-link"></span></a>Escaping generative phantom types</h3>

<p>Consider a function that converts an array of strings into a vector:</p>

<div class="highlight highlight-ocaml"><pre><span class="k">open</span> <span class="nn">Slap</span><span class="p">.</span><span class="nc">D</span>

<span class="k">let</span> <span class="n">vec_of_str_array</span> <span class="n">a</span> <span class="o">=</span>
  <span class="k">let</span> <span class="k">module</span> <span class="nc">N</span> <span class="o">=</span> <span class="nn">Slap</span><span class="p">.</span><span class="nn">Size</span><span class="p">.</span><span class="nc">Of_int_dyn</span><span class="o">(</span><span class="k">struct</span> <span class="k">let</span> <span class="k">value</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">a</span> <span class="k">end</span><span class="o">)</span> <span class="k">in</span>
  <span class="nn">Vec</span><span class="p">.</span><span class="n">init</span> <span class="nn">N</span><span class="p">.</span><span class="n">value</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="n">float_of_string</span> <span class="n">a</span><span class="o">.(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">))</span>

<span class="k">let</span> <span class="n">main</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="o">[|</span> <span class="s2">"1"</span><span class="o">;</span> <span class="s2">"2"</span><span class="o">;</span> <span class="s2">"3"</span> <span class="o">|]</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">v</span> <span class="o">=</span> <span class="n">vec_of_str_array</span> <span class="n">a</span> <span class="k">in</span>
  <span class="nn">Format</span><span class="p">.</span><span class="n">printf</span> <span class="s2">"%a</span><span class="se">\n</span><span class="s2">"</span> <span class="n">pp_vec</span> <span class="n">v</span>
</pre></div>

<p><code>Slap.Size.Of_int_dyn</code> converts an integer into a size and returns a module
containing a generative phantom type (cf. <code>Vec.of_list</code>).
OCaml cannot compile this code because the generative phantom type <code>N.n</code>
escapes its scope:</p>

<pre><code>Error: This expression has type
  (N.n, 'a) vec = ('b, float, rprec, 'c) Slap.Vec.t
but an expression was expected of type (N.n, 'a) vec
The type constructor N.n would escape its scope
</code></pre>

<p>There are two ways to handle this in SLAP.</p>

<h5>
<a name="1-to-add-extra-arguments" class="anchor" href="#1-to-add-extra-arguments"><span class="octicon octicon-link"></span></a>1. To add extra arguments</h5>

<p>One is to insert the argument <code>n</code> for the size of the array, and remove the
generative phantom type from the function:</p>

<div class="highlight highlight-ocaml"><pre><span class="k">open</span> <span class="nn">Slap</span><span class="p">.</span><span class="nc">Size</span>
<span class="k">open</span> <span class="nn">Slap</span><span class="p">.</span><span class="nc">D</span>

<span class="c">(* val vec_of_str_array : 'n Size.t -&gt; string array -&gt; ('n, _) vec *)</span>
<span class="k">let</span> <span class="n">vec_of_str_array</span> <span class="n">n</span> <span class="n">a</span> <span class="o">=</span>
  <span class="k">if</span> <span class="n">to_int</span> <span class="n">n</span> <span class="o">&lt;&gt;</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">a</span> <span class="k">then</span> <span class="n">invalid_arg</span> <span class="s2">"error"</span><span class="o">;</span>
  <span class="nn">Vec</span><span class="p">.</span><span class="n">init</span> <span class="n">n</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="n">float_of_string</span> <span class="n">a</span><span class="o">.(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">))</span>

<span class="k">let</span> <span class="n">main</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="o">[|</span> <span class="s2">"1"</span><span class="o">;</span> <span class="s2">"2"</span><span class="o">;</span> <span class="s2">"3"</span> <span class="o">|]</span> <span class="k">in</span>
  <span class="k">let</span> <span class="k">module</span> <span class="nc">N</span> <span class="o">=</span> <span class="o">(</span><span class="k">val</span> <span class="n">of_int_dyn</span> <span class="o">(</span><span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="nc">SIZE</span><span class="o">)</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">v</span> <span class="o">=</span> <span class="n">vec_of_str_array</span> <span class="nn">N</span><span class="p">.</span><span class="n">value</span> <span class="n">a</span> <span class="k">in</span>
  <span class="nn">Format</span><span class="p">.</span><span class="n">printf</span> <span class="s2">"%a</span><span class="se">\n</span><span class="s2">"</span> <span class="n">pp_vec</span> <span class="n">v</span>
</pre></div>

<p>In this case, programming is easy because the code is simple, but whether <code>n</code> is
equal to the length of <code>a</code> should be <strong>dynamically</strong> checked.</p>

<h5>
<a name="2-to-use-first-class-modules" class="anchor" href="#2-to-use-first-class-modules"><span class="octicon octicon-link"></span></a>2. To use first-class modules</h5>

<p>Another way is to use a first-class module and
return a module containing the generative phantom type:</p>

<div class="highlight highlight-ocaml"><pre><span class="k">open</span> <span class="nn">Slap</span><span class="p">.</span><span class="nc">Size</span>
<span class="k">open</span> <span class="nn">Slap</span><span class="p">.</span><span class="nc">D</span>

<span class="c">(* val vec_of_str_array : string array -&gt; (module SIZE) *)</span>
<span class="k">let</span> <span class="n">vec_of_str_array</span> <span class="n">a</span> <span class="o">=</span>
  <span class="k">let</span> <span class="k">module</span> <span class="nc">N</span> <span class="o">=</span> <span class="o">(</span><span class="k">val</span> <span class="n">of_int_dyn</span> <span class="o">(</span><span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="nc">SIZE</span><span class="o">)</span> <span class="k">in</span>
  <span class="k">let</span> <span class="k">module</span> <span class="nc">V</span> <span class="o">=</span> <span class="k">struct</span>
    <span class="k">type</span> <span class="n">n</span> <span class="o">=</span> <span class="nn">N</span><span class="p">.</span><span class="n">n</span>
    <span class="k">let</span> <span class="k">value</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">.</span><span class="n">init</span> <span class="nn">N</span><span class="p">.</span><span class="n">value</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="n">float_of_string</span> <span class="n">a</span><span class="o">.(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">))</span>
  <span class="k">end</span> <span class="k">in</span>
  <span class="o">(</span><span class="k">module</span> <span class="nc">V</span> <span class="o">:</span> <span class="nn">Vec</span><span class="p">.</span><span class="nc">CNTVEC</span><span class="o">)</span>

<span class="k">let</span> <span class="n">main</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="o">[|</span> <span class="s2">"1"</span><span class="o">;</span> <span class="s2">"2"</span><span class="o">;</span> <span class="s2">"3"</span> <span class="o">|]</span> <span class="k">in</span>
  <span class="k">let</span> <span class="k">module</span> <span class="nc">V</span> <span class="o">=</span> <span class="o">(</span><span class="k">val</span> <span class="n">vec_of_str_array</span> <span class="n">a</span> <span class="o">:</span> <span class="nn">Vec</span><span class="p">.</span><span class="nc">CNTVEC</span><span class="o">)</span> <span class="k">in</span>
  <span class="nn">Format</span><span class="p">.</span><span class="n">printf</span> <span class="s2">"%a</span><span class="se">\n</span><span class="s2">"</span> <span class="n">pp_vec</span> <span class="nn">V</span><span class="p">.</span><span class="n">value</span>
</pre></div>

<p>In the latter case, dynamic check is not needed, but programming is (slightly)
hard due to the heavy syntax and the type annotations (i.e., signatures) of
modules.</p>

<h5>
<a name="trade-off-of-two-solutions" class="anchor" href="#trade-off-of-two-solutions"><span class="octicon octicon-link"></span></a>Trade-off of two solutions</h5>

<p>Both solutions have merits and demerits. In practical cases, they are in a
trade-off relationship:</p>

<table>
<thead>
<tr>
<th align="left"></th>
<th align="center">generative phantom types</th>
<th align="center">static size checking</th>
<th align="center">programming</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">1. extra arguments</td>
<td align="center">given from outside of a function</td>
<td align="center">no</td>
<td align="center"><strong>easy</strong></td>
</tr>
<tr>
<td align="left">2. first-class modules</td>
<td align="center">created in a function</td>
<td align="center"><strong>yes</strong></td>
<td align="center">(slightly) hard</td>
</tr>
</tbody>
</table>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Slap maintained by <a href="https://github.com/akabe">akabe</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
