{"name":"Slap","tagline":"BLAS and LAPACK binding in OCaml with type-based static size checking for matrix operations","body":"Sized Linear Algebra Package (SLAP)\r\n===================================\r\n\r\nSLAP is a linear algebra library with type-based static size checking for\r\nmatrix operations.\r\n\r\nThis [OCaml](http://ocaml.org/)-library is a wrapper of\r\n[Lacaml](https://bitbucket.org/mmottl/lacaml), a binding of two widely used\r\nlinear algebra libraries [BLAS](http://www.netlib.org/blas/) (Basic Linear\r\nAlgebra Subprograms) and [LAPACK](http://www.netlib.org/lapack/) (Linear Algebra\r\nPACKage) for FORTRAN.\r\nSLAP guarantees **statically** (i.e., at compile time) consistency (with respect\r\nto dimensions) of most high-level matrix (and vector) operations by using\r\n_generative phantom types_. For example, addition of two- and three-dimensional\r\nvectors causes type error at **compile time**, and dynamic errors like\r\nexceptions do **not** happen.\r\n(Certain low-level operations, like accesses to elements by indices, need\r\ndynamic checks.)\r\n\r\nThis provides many useful and high-performance linear algebraic operations in\r\nLacaml, e.g., least squares problems, linear equations, Cholesky,\r\nQR-factorization, eigenvalue problems and singular value decomposition (SVD).\r\nMost of their interfaces are compatible with Lacaml functions.\r\n(Several functions have not been implemented yet, but they will be supported\r\nsoon.)\r\n\r\nInstall\r\n-------\r\n\r\nOPAM installation:\r\n\r\n```\r\nopam install slap\r\n```\r\n\r\nManual build (requiring [Lacaml](https://github.com/mmottl/lacaml) and\r\n[cppo](http://mjambon.com/cppo.html)):\r\n\r\n```\r\n./configure\r\nmake\r\nmake install\r\n```\r\n\r\nDocumentation\r\n-------------\r\n\r\n- Online API documentation is available at http://akabe.github.io/slap/\r\n  (generated by `make doc`).\r\n- This library interface was announced at\r\n  [ML Family Workshop 2014](http://okmij.org/ftp/ML/ML14.html) in Gothenburg,\r\n  Sweden: A Simple and Practical Linear Algebra Library Interface with Static\r\n  Size Checking, by Akinori Abe and Eijiro Sumii (Tohoku University).\r\n  [PDF Abstract](https://ocaml.org/meetings/ocaml/2014/ocaml2014_19.pdf),\r\n  [PDF Slides](https://ocaml.org/meetings/ocaml/2014/abe-sumii-slides.pdf),\r\n  [PDF Supplement](https://akabe.github.io/sgpr/changes.pdf).\r\n  (The talk was accepted by\r\n  [OCaml Workshop 2014](https://ocaml.org/meetings/ocaml/2014/), but it was\r\n  presented at ML Workshop.)\r\n\r\nDemo\r\n----\r\n\r\nThe following code ([examples/linsys/jacobi.ml](examples/linsys/jacobi.ml))\r\nis an implementation of\r\n[Jacobi method](http://en.wikipedia.org/wiki/Jacobi_method) (to solve\r\nsystem of linear equations).\r\n\r\n```ocaml\r\nopen Slap.Io\r\nopen Slap.D\r\nopen Slap.Size\r\nopen Slap.Common\r\n\r\nlet jacobi a b =\r\n  let d_inv = Vec.reci (Mat.diag a) in (* reciprocal diagonal elements *)\r\n  let r = Mat.mapi (fun i j aij -> if i = j then 0.0 else aij) a in\r\n  let y = Vec.create (Vec.dim b) in (* temporary memory *)\r\n  let rec loop z x =\r\n    ignore (copy ~y b); (* y := b *)\r\n    ignore (gemv ~y ~trans:normal ~alpha:(-1.0) ~beta:1.0 r x); (* y := y-r*x *)\r\n    ignore (Vec.mul ~z d_inv y); (* z := element-wise mult. of d_inv and y *)\r\n    if Vec.ssqr_diff x z < 1e-10 then z else loop x z (* Check convergence *)\r\n  in\r\n  let x0 = Vec.make (Vec.dim b) 1.0 in (* the initial values of `x' *)\r\n  let z = Vec.create (Vec.dim b) in (* temporary memory *)\r\n  loop z x0\r\n\r\nlet _ =\r\n  let a = Mat.init four four (fun i j -> let p = float_of_int (i - j) in\r\n                                         exp (~-. p *. p)) in\r\n  let b = Vec.init four (fun i -> float_of_int i) in\r\n  let x = jacobi a b in\r\n  Format.printf \"a = @[%a@]@.b = @[%a@]@.\" pp_fmat a pp_rfvec b;\r\n  Format.printf \"x = @[%a@]@.\" pp_rfvec x;\r\n  Format.printf \"a*x = @[%a@]@.\" pp_rfvec (gemv ~trans:normal a x)\r\n```\r\n\r\n`jacobi a b` solves a system of linear equations `a * x = b` where `a` is\r\na n-by-n matrix, and `x` and `b` is a n-dimensional vectors. This code can\r\nbe compiled by `ocamlfind ocamlc -linkpkg -package slap jacobi.ml`, and\r\n`a.out` outputs:\r\n\r\n```ocaml\r\na =          1  0.367879 0.0183156 0.00012341\r\n      0.367879         1  0.367879  0.0183156\r\n     0.0183156  0.367879         1   0.367879\r\n    0.00012341 0.0183156  0.367879          1\r\nb = 1 2 3 4\r\nx = 0.496539 1.30705 1.21131 3.53038\r\na*x = 0.999998 2 3 4\r\n```\r\n\r\nOK. Vector `x` is computed. Try to modify any one of\r\nthe dimensions of `a`, `b` and `x` in the above code, e.g.,\r\n\r\n```ocaml\r\n...\r\n\r\nlet _ =\r\n  let a = Mat.init four five (fun i j -> ...\r\n  ...\r\n```\r\n\r\nand compile the changed code. Then OCaml reports a type error (not a runtime\r\nerror like an exception):\r\n\r\n```ocaml\r\nError: This expression has type\r\n  (z s s s s, z s s s s s, 'a) mat = (z s s s s, z s s s s s, float, rprec, 'a) Slap.Mat.t\r\nbut an expression was expected of type\r\n  (z s s s s, z s s s s, 'b) mat = (z s s s s, z s s s s, float, rprec, 'b) Slap.Mat.t\r\nType z s is not compatible with type z\r\n```\r\n\r\nBy using SLAP, your mistake (i.e., a bug) is captured at **compile time**!\r\n\r\nUsage\r\n-----\r\n\r\nThe following modules provide useful linear algebraic operations including\r\nBLAS and LAPACK functions.\r\n\r\n- `Slap.S`: Single-precision (32-bit) real numbers\r\n- `Slap.D`: Double-precision (64-bit) real numbers\r\n- `Slap.C`: Single-precision (32-bit) complex numbers\r\n- `Slap.Z`: Double-precision (64-bit) complex numbers\r\n\r\n### Simple computation\r\n\r\n#### Dimensions (sizes)\r\n\r\n`Slap.Size` provides operations on _sizes_ (i.e., natural numbers as dimensions\r\nof vectors and matrices) of curious types. Look at the type of `Slap.Size.four`:\r\n\r\n```ocaml\r\n# open Slap.Size;;\r\n# four;;\r\n- : z s s s s t = 4\r\n```\r\n\r\nTypes `z` and `'n s` correspond to zero and `'n + 1`, respectively. Thus,\r\n`z s s s s` represents 0+1+1+1+1 = 4. `'n t` (= `'n Slap.Size.t`) is a\r\n_singleton type_ on natural numbers; i.e., evaluation of a term (i.e.,\r\nexpression) of type `'n t` **always** results in the natural number\r\ncorresponding to  `'n`. Therefore `z s s s s t` is the type of terms always\r\nevaluated to four.\r\n\r\n#### Vectors\r\n\r\nCreation of a four-dimensional vector:\r\n\r\n```ocaml\r\n# open Slap.D;;\r\n# let x = Vec.init four (fun i -> float_of_int i);;\r\nval x : (z s s s s, 'a) vec = R1 R2 R3 R4\r\n                               1  2  3  4\r\n```\r\n\r\n`Vec.init` creates a vector initialized by the given function. `('n, 'a) vec` is\r\nthe type of `'n`-dimensional vectors. So `(z s s s s, 'a) vec` is the type of\r\nfour-dimensional vectors. (Description of the second type parameter is omitted.)\r\n\r\nVectors of different dimensions **always** have different types:\r\n\r\n```ocaml\r\n# let y = Vec.init five (fun i -> float_of_int i);;\r\nval y : (z s s s s s, 'a) vec = R1 R2 R3 R4 R5\r\n                                 1  2  3  4  5\r\n```\r\n\r\nThe addition of four-dimensional vector `x` and five-dimensional vector `y`\r\ncauses a type error (at compile time):\r\n\r\n```ocaml\r\n# Vec.add x y;;\r\nError: This expression has type\r\n  (z s s s s s, 'a) vec = (z s s s s s, float, rprec, 'a) Slap.Vec.t\r\nbut an expression was expected of type\r\n  (z s s s s, 'b) vec = (z s s s s, float, rprec, 'b) Slap.Vec.t\r\nType z s is not compatible with type z\r\n```\r\n\r\nOf course, addition of vectors of the same dimension succeeds:\r\n\r\n```ocaml\r\n# let z = Vec.map (fun c -> c *. 2.0) x;;\r\nval z : (z s s s s, 'a) vec = R1 R2 R3 R4\r\n                               2  4  6  8\r\n# Vec.add x z;;\r\n- : (z s s s s, 'a) vec = R1 R2 R3 R4\r\n                           3  6  9 12\r\n```\r\n\r\n#### Matrices\r\n\r\nCreation of a 3-by-5 matrix:\r\n\r\n```ocaml\r\n# let a = Mat.init three five (fun i j -> float_of_int (10 * i + j));;\r\nval a : (z s s s, z s s s s s, 'a) mat =\r\n     C1 C2 C3 C4 C5\r\n  R1 11 12 13 14 15\r\n  R2 21 22 23 24 25\r\n  R3 31 32 33 34 35\r\n```\r\n\r\n`('m, 'n, 'a) mat` is the type of `'m`-by-`'n` matrices. Thus\r\n`(z s s s, z s s s s s, 'a) mat` is the type of 3-by-5 matrices. (Description of\r\nthe third type parameter is omitted.)\r\n\r\nBLAS function `gemm` multiplies two general matrices:\r\n\r\n```ocaml\r\ngemm ?beta ?c ~transa ?alpha a ~transb b\r\n```\r\n\r\nexecutes `c := alpha * a * b + beta * c` with matrices `a`, `b` and `c`, and\r\nscalar values `alpha` and `beta`. The parameters `transa` and `transb` specify\r\nno transpose (`Slap.Common.normal`), transpose (`Slap.Common.trans`) or\r\nconjugate transpose (`Slap.Common.conjtr`) of matrices `a` and `b`,\r\nrespectively. (`conjtr` can be used only for complex operations in `Slap.C`\r\nand `Slap.Z`.) For example, if `transa`=`normal` and `transb`=`trans`, then\r\n`gemm` executes `c := alpha * a * b^T + beta * c` (where `b^T` is the transpose\r\nof `b`). When you compute `a * a^T` by `gemm`, a 3-by-3 matrix is returned since\r\n`a` is a 3-by-5 matrix:\r\n\r\n```ocaml\r\n# open Slap.Common;;\r\n# gemm ~transa:normal ~transb:trans a a;;\r\n- : (z s s s, z s s s, 'a) mat =\r\n     C1   C2   C3\r\nR1  855 1505 2155\r\nR2 1505 2655 3805\r\nR3 2155 3805 5455\r\n```\r\n\r\n`a * a` causes a type error since the number of columns of the first matrix is\r\nnot equal to the number of rows of the second matrix:\r\n\r\n```ocaml\r\n# gemm ~transa:normal ~transb:normal a a;;\r\nError: This expression has type\r\n  (z s s s, z s s s s s, 'a) mat =\r\n  (z s s s, z s s s s s, float, rprec, 'a) Slap.Mat.t\r\nbut an expression was expected of type\r\n  (z s s s s s, 'b, 'c) mat =\r\n  (z s s s s s, 'b, float, rprec, 'c) Slap.Mat.t\r\nType z is not compatible with type z s s\r\n```\r\n\r\n### Sizes decided at runtime\r\n\r\nSLAP can safely treat sizes that are unknown until runtime\r\n(e.g., the dimension of a vector loaded from a file)!\r\nUnfortunately, SLAP does not provide functions to load a\r\nvector or a matrix from a file. (Maybe such operations will be implemented.)\r\nYou need to write a function to load a list or an array from a file\r\nand call a SLAP function to convert it to a vector or a matrix.\r\n\r\nConversion of a list into a vector:\r\n\r\n```ocaml\r\n# module X = (val Vec.of_list [1.; 2.; 3.] : Vec.CNTVEC);;\r\nmodule X : Slap.D.Vec.CNTVEC\r\n```\r\n\r\nThe returned module `X` has the following signature:\r\n\r\n```ocaml\r\nmodule type Slap.D.Vec.CNTVEC = sig\r\n  type n (* a type to represent the dimension of a vector *)\r\n  val value : (n, 'cnt) vec (* the instance of a vector *)\r\nend\r\n```\r\n\r\nThe instance of a vector is `X.value`:\r\n\r\n```ocaml\r\n# X.value;;\r\n- : (X.n, 'cnt) vec = R1 R2 R3\r\n                       1  2  3\r\n```\r\n\r\nIt can be treated as stated above. It's very easy!\r\n\r\nYou can also convert a list into a matrix:\r\n\r\n```ocaml\r\n# module A = (val Mat.of_list [[1.; 2.; 3.];\r\n                               [4.; 5.; 6.]] : Mat.CNTMAT);;\r\n# A.value;;\r\n- : (A.m, A.n, 'cnt) mat =    C1 C2 C3\r\n                           R1  1  2  3\r\n                           R2  4  5  6\r\n```\r\n\r\n#### Idea of generative phantom type\r\n\r\nIn this section, we explain our basic idea of static size checking. For\r\nexample, let's think about the function `loadvec : string -> (?, _) vec`.\r\nIt returns a vector of some dimension, loaded from the given path.\r\nThe dimension is decided at **runtime**, but we need to type it at\r\n**compile time**. How do we represent the return type `?`?\r\nConsider the following code for example:\r\n\r\n```ocaml\r\nlet (x : (?1, _) vec) = loadvec \"file1\" in\r\nlet (y : (?2, _) vec) = loadvec \"file2\" in\r\nVec.add x y\r\n```\r\n\r\nThe third line should be ill-typed because the dimensions of `x` and `y` are\r\nprobably different. (Even if `\"file1\"` and `\"file2\"` were the same path, the\r\naddition should be ill-typed because the file might change between the two\r\nloads.) Thus, the return type of `loadvec` should be different every time it is\r\ncalled (regardless of the specific values of the argument). We call such a\r\nreturn type _generative_ because the function returns a value of a fresh type\r\nfor each call. The vector type with generative size information essentially\r\ncorresponds to an existentially quantified sized type like `exists n. n vec`.\r\n\r\nType parameters `'m`, `'n` and `'a` of types `'n Size.t`, `('n, 'a) vec` and\r\n`('m, 'n, 'a) mat` are _phantom_, meaning that they do not appear on the right\r\nhand side of the type definition. A phantom type parameter is often instantiated\r\nwith a type that has no value (i.e., no constructor) which we call a\r\n_phantom type_. Then we call the type `?` a _generative phantom type_.\r\n\r\nActually, type `X.n` (returned by `Vec.of_list`) is different for each call of\r\nthe function, i.e., a generative phantom type:\r\n\r\n```ocaml\r\n# module Y = (val Vec.of_list [4.; 5.] : Vec.CNTVEC);;\r\n# Vec.add X.value Y.value;;\r\nError: This expression has type\r\n  (Y.n, 'a) vec = (Y.n, float, rprec, 'a) Slap.Vec.t\r\nbut an expression was expected of type\r\n  (X.n, 'b) vec = (X.n, float, rprec, 'b) Slap.Vec.t\r\nType Y.n is not compatible with type X.n\r\n```\r\n\r\n#### Addition of vectors loaded from different files\r\n\r\nWhen you want to add vectors loaded from different files, you can use\r\n`Vec.of_list_dyn`:\r\n\r\n```ocaml\r\nval Vec.of_list_dyn : 'n Size.t -> float list -> ('n, 'cnt) vec\r\n```\r\n\r\nIt also converts a list into a vector, but differs from `Vec.of_list`: You need\r\nto give the length of a list to the first parameter as a size. For example, if\r\nyou consider that two lists `lst1` and `lst2` (loaded from different files) have\r\nthe same length, you can add them as follows:\r\n\r\n```ocaml\r\n# let lst1 = [1.; 2.; 3.; 4.; 5.];; (* loaded from a file *)\r\nval lst1 : float list = [1.; 2.; 3.; 4.; 5.]\r\n# let lst2 = [6.; 7.; 8.; 9.; 10.];; (* loaded from another file *)\r\nval lst2 : float list = [6.; 7.; 8.; 9.; 10.]\r\n# module X = (val Vec.of_list lst1 : Vec.CNTVEC);;\r\nmodule X : Slap.D.Vec.CNTVEC\r\n# let y = Vec.of_list_dyn (Vec.dim X.value) lst2;;\r\nval y : (X.n, 'a) vec = R1 R2 R3 R4 R5\r\n                         6  7  8  9 10\r\n# Vec.add X.value y;;\r\n- : (X.n, 'a) vec = R1 R2 R3 R4 R5\r\n                     7  9 11 13 15\r\n```\r\n\r\n`Vec.of_list` raises an **exception** (at runtime) if the given size is not\r\nequal to the length, i.e., the lengths of `lst1` and `lst2`\r\nare different in the above case. This dynamic check is unavoidable because the\r\nequality of sizes of two vectors loaded from different files cannot be\r\nstatically guaranteed. We gave functions containing dynamic checks the suffix\r\n`_dyn`.\r\n\r\nAdvanced information\r\n--------------------\r\n\r\n### Size constraints\r\n\r\nWhen a matrix operation is implemented by low-level index-based accesses, its\r\nsize constraints cannot be inferred statically (since they are checked only at\r\nruntime): For example, consider the function `axby`, which calculates\r\n`alpha * x + beta * y` with scalar values `alpha` and `beta`, and vectors `x`\r\nand `y`:\r\n\r\n```ocaml\r\nopen Slap.D\r\n\r\nlet axby alpha x beta y =\r\n  let n = Vec.dim x in\r\n  let z = Vec.create n in\r\n  for i = 1 to Slap.Size.to_int n do\r\n    let p = alpha *. (Vec.get_dyn x i) +. beta *. (Vec.get_dyn y i) in\r\n    Vec.set_dyn z i p\r\n  done;\r\n  z\r\n```\r\n\r\nThe dimensions of vectors `x` and `y` must be the same, but OCaml infers that\r\nthey may be different:\r\n\r\n```ocaml\r\nval axby : float -> ('n, _) vec -> float -> ('m, _) vec -> ('n, _) vec\r\n```\r\n\r\nThere are two ways to solve this problem.\r\n\r\n##### 1. To write size constraints by hand\r\n\r\nOne is to type-annotate `axby` by hand:\r\n\r\n```ocaml\r\nlet axby alpha (x : ('n, _) vec) beta (y : ('n, _) vec) =\r\n  ...\r\n```\r\n\r\n##### 2. To use high-level matrix operations (recommended)\r\n\r\nThe other way is to use high-level operations such as `map`, `fold`, BLAS and\r\nLAPACK functions instead of low-level operations such as `get_dyn` and\r\n`set_dyn`:\r\n\r\n```ocaml\r\nlet axby alpha x beta y =\r\n  let z = copy y in (* z = y *)\r\n  scal beta z; (* z := beta * z *)\r\n  axpy ~alpha ~x y; (* z := alpha * x + z *)\r\n  z\r\n```\r\n\r\nor\r\n\r\n```ocaml\r\nlet axby alpha x beta y =\r\n  Vec.map2 (fun xi yi -> alpha *. xi +. beta *. yi) x y\r\n```\r\n\r\nIn this case, size constraints are automatically inferred by OCaml.\r\nWe strongly recommend this way.\r\n\r\n### Escaping generative phantom types\r\n\r\nConsider a function that converts an array of strings into a vector:\r\n\r\n```ocaml\r\nopen Slap.D\r\n\r\nlet vec_of_str_array a =\r\n  let module N = Slap.Size.Of_int_dyn(struct let value = Array.length a end) in\r\n  Vec.init N.value (fun i -> float_of_string a.(i-1))\r\n\r\nlet main () =\r\n  let a = [| \"1\"; \"2\"; \"3\" |] in\r\n  let v = vec_of_str_array a in\r\n  Format.printf \"%a\\n\" pp_vec v\r\n```\r\n\r\n`Slap.Size.Of_int_dyn` converts an integer into a size and returns a module\r\ncontaining a generative phantom type (cf. `Vec.of_list`).\r\nOCaml cannot compile this code because the generative phantom type `N.n`\r\nescapes its scope:\r\n\r\n```\r\nError: This expression has type\r\n  (N.n, 'a) vec = ('b, float, rprec, 'c) Slap.Vec.t\r\nbut an expression was expected of type (N.n, 'a) vec\r\nThe type constructor N.n would escape its scope\r\n```\r\n\r\nThere are two ways to handle this in SLAP.\r\n\r\n##### 1. To add extra arguments\r\n\r\nOne is to insert the argument `n` for the size of the array, and remove the\r\ngenerative phantom type from the function:\r\n\r\n```ocaml\r\nopen Slap.Size\r\nopen Slap.D\r\n\r\n(* val vec_of_str_array : 'n Size.t -> string array -> ('n, _) vec *)\r\nlet vec_of_str_array n a =\r\n  if to_int n <> Array.length a then invalid_arg \"error\";\r\n  Vec.init n (fun i -> float_of_string a.(i-1))\r\n\r\nlet main () =\r\n  let a = [| \"1\"; \"2\"; \"3\" |] in\r\n  let module N = (val of_int_dyn (Array.length a) : SIZE) in\r\n  let v = vec_of_str_array N.value a in\r\n  Format.printf \"%a\\n\" pp_vec v\r\n```\r\n\r\nIn this case, programming is easy because the code is simple, but whether `n` is\r\nequal to the length of `a` should be **dynamically** checked.\r\n\r\n##### 2. To use first-class modules\r\n\r\nAnother way is to use a first-class module and\r\nreturn a module containing the generative phantom type:\r\n\r\n```ocaml\r\nopen Slap.Size\r\nopen Slap.D\r\n\r\n(* val vec_of_str_array : string array -> (module SIZE) *)\r\nlet vec_of_str_array a =\r\n  let module N = (val of_int_dyn (Array.length a) : SIZE) in\r\n  let module V = struct\r\n    type n = N.n\r\n    let value = Vec.init N.value (fun i -> float_of_string a.(i-1))\r\n  end in\r\n  (module V : Vec.CNTVEC)\r\n\r\nlet main () =\r\n  let a = [| \"1\"; \"2\"; \"3\" |] in\r\n  let module V = (val vec_of_str_array a : Vec.CNTVEC) in\r\n  Format.printf \"%a\\n\" pp_vec V.value\r\n```\r\n\r\nIn the latter case, dynamic check is not needed, but programming is (slightly)\r\nhard due to the heavy syntax and the type annotations (i.e., signatures) of\r\nmodules.\r\n\r\n##### Trade-off of two solutions\r\n\r\nBoth solutions have merits and demerits. In practical cases, they are in a\r\ntrade-off relationship:\r\n\r\n|                        | generative phantom types         | static size checking | programming     |\r\n|:-----------------------|:--------------------------------:|:--------------------:|:---------------:|\r\n| 1. extra arguments     | given from outside of a function | no                   | **easy**        |\r\n| 2. first-class modules | created in a function            | **yes**              | (slightly) hard |\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}